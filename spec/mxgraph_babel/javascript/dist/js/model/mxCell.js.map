{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/model/mxCell.js"],"names":["mxCell","value","geometry","style","setGeometry","setStyle","onInit","prototype","id","vertex","edge","connectable","visible","collapsed","parent","source","target","children","edges","mxTransient","getId","setId","getValue","setValue","valueChanged","newValue","previous","getGeometry","getStyle","isVertex","setVertex","isEdge","setEdge","isConnectable","setConnectable","isVisible","setVisible","isCollapsed","setCollapsed","getParent","setParent","getTerminal","setTerminal","terminal","isSource","getChildCount","length","getIndex","child","mxUtils","indexOf","getChildAt","index","insert","removeFromParent","push","splice","remove","getEdgeCount","getEdgeIndex","getEdgeAt","insertEdge","isOutgoing","removeFromTerminal","removeEdge","hasAttribute","name","userObject","nodeType","mxConstants","NODETYPE_ELEMENT","getAttribute","defaultValue","val","setAttribute","clone","cloneValue","isNaN","cloneNode","__mxOutput","undefined"],"mappings":"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","file":"mxCell.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCell\n *\n * Cells are the elements of the graph model. They represent the state\n * of the groups, vertices and edges in a graph.\n * \n * Custom attributes:\n * \n * For custom attributes we recommend using an XML node as the value of a cell.\n * The following code can be used to create a cell with an XML node as the\n * value:\n * \n * (code)\n * var doc = mxUtils.createXmlDocument();\n * var node = doc.createElement('MyNode')\n * node.setAttribute('label', 'MyLabel');\n * node.setAttribute('attribute1', 'value1');\n * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\n * (end)\n * \n * For the label to work, <mxGraph.convertValueToString> and\n * <mxGraph.cellLabelChanged> should be overridden as follows:\n * \n * (code)\n * graph.convertValueToString = function(cell)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     return cell.getAttribute('label', '')\n *   }\n * };\n * \n * var cellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     // Clones the value for correct undo/redo\n *     var elt = cell.value.cloneNode(true);\n *     elt.setAttribute('label', newValue);\n *     newValue = elt;\n *   }\n *   \n *   cellLabelChanged.apply(this, arguments);\n * };\n * (end)\n * \n * Callback: onInit\n *\n * Called from within the constructor.\n * \n * Constructor: mxCell\n *\n * Constructs a new cell to be used in a graph model.\n * This method invokes <onInit> upon completion.\n * \n * Parameters:\n * \n * value - Optional object that represents the cell value.\n * geometry - Optional <mxGeometry> that specifies the geometry.\n * style - Optional formatted string that defines the style.\n */\nfunction mxCell(value, geometry, style)\n{\n\tthis.value = value;\n\tthis.setGeometry(geometry);\n\tthis.setStyle(style);\n\t\n\tif (this.onInit != null)\n\t{\n\t\tthis.onInit();\n\t}\n};\n\n/**\n * Variable: id\n *\n * Holds the Id. Default is null.\n */\nmxCell.prototype.id = null;\n\n/**\n * Variable: value\n *\n * Holds the user object. Default is null.\n */\nmxCell.prototype.value = null;\n\n/**\n * Variable: geometry\n *\n * Holds the <mxGeometry>. Default is null.\n */\nmxCell.prototype.geometry = null;\n\n/**\n * Variable: style\n *\n * Holds the style as a string of the form [(stylename|key=value);]. Default is\n * null.\n */\nmxCell.prototype.style = null;\n\n/**\n * Variable: vertex\n *\n * Specifies whether the cell is a vertex. Default is false.\n */\nmxCell.prototype.vertex = false;\n\n/**\n * Variable: edge\n *\n * Specifies whether the cell is an edge. Default is false.\n */\nmxCell.prototype.edge = false;\n\n/**\n * Variable: connectable\n *\n * Specifies whether the cell is connectable. Default is true.\n */\nmxCell.prototype.connectable = true;\n\n/**\n * Variable: visible\n *\n * Specifies whether the cell is visible. Default is true.\n */\nmxCell.prototype.visible = true;\n\n/**\n * Variable: collapsed\n *\n * Specifies whether the cell is collapsed. Default is false.\n */\nmxCell.prototype.collapsed = false;\n\n/**\n * Variable: parent\n *\n * Reference to the parent cell.\n */\nmxCell.prototype.parent = null;\n\n/**\n * Variable: source\n *\n * Reference to the source terminal.\n */\nmxCell.prototype.source = null;\n\n/**\n * Variable: target\n *\n * Reference to the target terminal.\n */\nmxCell.prototype.target = null;\n\n/**\n * Variable: children\n *\n * Holds the child cells.\n */\nmxCell.prototype.children = null;\n\n/**\n * Variable: edges\n *\n * Holds the edges.\n */\nmxCell.prototype.edges = null;\n\n/**\n * Variable: mxTransient\n *\n * List of members that should not be cloned inside <clone>. This field is\n * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.\n * This is not a convention for all classes, it is only used in this class\n * to mark transient fields since transient modifiers are not supported by\n * the language.\n */\nmxCell.prototype.mxTransient = ['id', 'value', 'parent', 'source',\n                                'target', 'children', 'edges'];\n\n/**\n * Function: getId\n *\n * Returns the Id of the cell as a string.\n */\nmxCell.prototype.getId = function()\n{\n\treturn this.id;\n};\n\t\t\n/**\n * Function: setId\n *\n * Sets the Id of the cell to the given string.\n */\nmxCell.prototype.setId = function(id)\n{\n\tthis.id = id;\n};\n\n/**\n * Function: getValue\n *\n * Returns the user object of the cell. The user\n * object is stored in <value>.\n */\nmxCell.prototype.getValue = function()\n{\n\treturn this.value;\n};\n\t\t\n/**\n * Function: setValue\n *\n * Sets the user object of the cell. The user object\n * is stored in <value>.\n */\nmxCell.prototype.setValue = function(value)\n{\n\tthis.value = value;\n};\n\n/**\n * Function: valueChanged\n *\n * Changes the user object after an in-place edit\n * and returns the previous value. This implementation\n * replaces the user object with the given value and\n * returns the old user object.\n */\nmxCell.prototype.valueChanged = function(newValue)\n{\n\tvar previous = this.getValue();\n\tthis.setValue(newValue);\n\t\n\treturn previous;\n};\n\n/**\n * Function: getGeometry\n *\n * Returns the <mxGeometry> that describes the <geometry>.\n */\nmxCell.prototype.getGeometry = function()\n{\n\treturn this.geometry;\n};\n\n/**\n * Function: setGeometry\n *\n * Sets the <mxGeometry> to be used as the <geometry>.\n */\nmxCell.prototype.setGeometry = function(geometry)\n{\n\tthis.geometry = geometry;\n};\n\n/**\n * Function: getStyle\n *\n * Returns a string that describes the <style>.\n */\nmxCell.prototype.getStyle = function()\n{\n\treturn this.style;\n};\n\n/**\n * Function: setStyle\n *\n * Sets the string to be used as the <style>.\n */\nmxCell.prototype.setStyle = function(style)\n{\n\tthis.style = style;\n};\n\n/**\n * Function: isVertex\n *\n * Returns true if the cell is a vertex.\n */\nmxCell.prototype.isVertex = function()\n{\n\treturn this.vertex != 0;\n};\n\n/**\n * Function: setVertex\n *\n * Specifies if the cell is a vertex. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n * \n * Parameters:\n * \n * vertex - Boolean that specifies if the cell is a vertex.\n */\nmxCell.prototype.setVertex = function(vertex)\n{\n\tthis.vertex = vertex;\n};\n\n/**\n * Function: isEdge\n *\n * Returns true if the cell is an edge.\n */\nmxCell.prototype.isEdge = function()\n{\n\treturn this.edge != 0;\n};\n\t\n/**\n * Function: setEdge\n * \n * Specifies if the cell is an edge. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n * \n * Parameters:\n * \n * edge - Boolean that specifies if the cell is an edge.\n */\nmxCell.prototype.setEdge = function(edge)\n{\n\tthis.edge = edge;\n};\n\n/**\n * Function: isConnectable\n *\n * Returns true if the cell is connectable.\n */\nmxCell.prototype.isConnectable = function()\n{\n\treturn this.connectable != 0;\n};\n\n/**\n * Function: setConnectable\n *\n * Sets the connectable state.\n * \n * Parameters:\n * \n * connectable - Boolean that specifies the new connectable state.\n */\nmxCell.prototype.setConnectable = function(connectable)\n{\n\tthis.connectable = connectable;\n};\n\n/**\n * Function: isVisible\n *\n * Returns true if the cell is visibile.\n */\nmxCell.prototype.isVisible = function()\n{\n\treturn this.visible != 0;\n};\n\n/**\n * Function: setVisible\n *\n * Specifies if the cell is visible.\n * \n * Parameters:\n * \n * visible - Boolean that specifies the new visible state.\n */\nmxCell.prototype.setVisible = function(visible)\n{\n\tthis.visible = visible;\n};\n\n/**\n * Function: isCollapsed\n *\n * Returns true if the cell is collapsed.\n */\nmxCell.prototype.isCollapsed = function()\n{\n\treturn this.collapsed != 0;\n};\n\n/**\n * Function: setCollapsed\n *\n * Sets the collapsed state.\n * \n * Parameters:\n * \n * collapsed - Boolean that specifies the new collapsed state.\n */\nmxCell.prototype.setCollapsed = function(collapsed)\n{\n\tthis.collapsed = collapsed;\n};\n\n/**\n * Function: getParent\n *\n * Returns the cell's parent.\n */\nmxCell.prototype.getParent = function()\n{\n\treturn this.parent;\n};\n\n/**\n * Function: setParent\n *\n * Sets the parent cell.\n * \n * Parameters:\n * \n * parent - <mxCell> that represents the new parent.\n */\nmxCell.prototype.setParent = function(parent)\n{\n\tthis.parent = parent;\n};\n\n/**\n * Function: getTerminal\n *\n * Returns the source or target terminal.\n * \n * Parameters:\n * \n * source - Boolean that specifies if the source terminal should be\n * returned.\n */\nmxCell.prototype.getTerminal = function(source)\n{\n\treturn (source) ? this.source : this.target;\n};\n\n/**\n * Function: setTerminal\n *\n * Sets the source or target terminal and returns the new terminal.\n * \n * Parameters:\n * \n * terminal - <mxCell> that represents the new source or target terminal.\n * isSource - Boolean that specifies if the source or target terminal\n * should be set.\n */\nmxCell.prototype.setTerminal = function(terminal, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.source = terminal;\n\t}\n\telse\n\t{\n\t\tthis.target = terminal;\n\t}\n\t\n\treturn terminal;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of child cells.\n */\nmxCell.prototype.getChildCount = function()\n{\n\treturn (this.children == null) ? 0 : this.children.length;\n};\n\n/**\n * Function: getIndex\n *\n * Returns the index of the specified child in the child array.\n * \n * Parameters:\n * \n * child - Child whose index should be returned.\n */\nmxCell.prototype.getIndex = function(child)\n{\n\treturn mxUtils.indexOf(this.children, child);\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child at the specified index.\n * \n * Parameters:\n * \n * index - Integer that specifies the child to be returned.\n */\nmxCell.prototype.getChildAt = function(index)\n{\n\treturn (this.children == null) ? null : this.children[index];\n};\n\n/**\n * Function: insert\n *\n * Inserts the specified child into the child array at the specified index\n * and updates the parent reference of the child. If not childIndex is\n * specified then the child is appended to the child array. Returns the\n * inserted child.\n * \n * Parameters:\n * \n * child - <mxCell> to be inserted or appended to the child array.\n * index - Optional integer that specifies the index at which the child\n * should be inserted into the child array.\n */\nmxCell.prototype.insert = function(child, index)\n{\n\tif (child != null)\n\t{\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount();\n\t\t\t\n\t\t\tif (child.getParent() == this)\n\t\t\t{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\n\t\tchild.removeFromParent();\n\t\tchild.setParent(this);\n\t\t\n\t\tif (this.children == null)\n\t\t{\n\t\t\tthis.children = [];\n\t\t\tthis.children.push(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.children.splice(index, 0, child);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: remove\n *\n * Removes the child at the specified index from the child array and\n * returns the child that was removed. Will remove the parent reference of\n * the child.\n * \n * Parameters:\n * \n * index - Integer that specifies the index of the child to be\n * removed.\n */\nmxCell.prototype.remove = function(index)\n{\n\tvar child = null;\n\t\n\tif (this.children != null && index >= 0)\n\t{\n\t\tchild = this.getChildAt(index);\n\t\t\n\t\tif (child != null)\n\t\t{\n\t\t\tthis.children.splice(index, 1);\n\t\t\tchild.setParent(null);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: removeFromParent\n *\n * Removes the cell from its parent.\n */\nmxCell.prototype.removeFromParent = function()\n{\n\tif (this.parent != null)\n\t{\n\t\tvar index = this.parent.getIndex(this);\n\t\tthis.parent.remove(index);\n\t}\n};\n\n/**\n * Function: getEdgeCount\n *\n * Returns the number of edges in the edge array.\n */\nmxCell.prototype.getEdgeCount = function()\n{\n\treturn (this.edges == null) ? 0 : this.edges.length;\n};\n\n/**\n * Function: getEdgeIndex\n *\n * Returns the index of the specified edge in <edges>.\n * \n * Parameters:\n * \n * edge - <mxCell> whose index in <edges> should be returned.\n */\nmxCell.prototype.getEdgeIndex = function(edge)\n{\n\treturn mxUtils.indexOf(this.edges, edge);\n};\n\n/**\n * Function: getEdgeAt\n *\n * Returns the edge at the specified index in <edges>.\n * \n * Parameters:\n * \n * index - Integer that specifies the index of the edge to be returned.\n */\nmxCell.prototype.getEdgeAt = function(index)\n{\n\treturn (this.edges == null) ? null : this.edges[index];\n};\n\n/**\n * Function: insertEdge\n *\n * Inserts the specified edge into the edge array and returns the edge.\n * Will update the respective terminal reference of the edge.\n * \n * Parameters:\n * \n * edge - <mxCell> to be inserted into the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.insertEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tedge.removeFromTerminal(isOutgoing);\n\t\tedge.setTerminal(this, isOutgoing);\n\t\t\n\t\tif (this.edges == null ||\n\t\t\tedge.getTerminal(!isOutgoing) != this ||\n\t\t\tmxUtils.indexOf(this.edges, edge) < 0)\n\t\t{\n\t\t\tif (this.edges == null)\n\t\t\t{\n\t\t\t\tthis.edges = [];\n\t\t\t}\n\t\t\t\n\t\t\tthis.edges.push(edge);\n\t\t}\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: removeEdge\n *\n * Removes the specified edge from the edge array and returns the edge.\n * Will remove the respective terminal reference from the edge.\n * \n * Parameters:\n * \n * edge - <mxCell> to be removed from the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.removeEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tif (edge.getTerminal(!isOutgoing) != this &&\n\t\t\tthis.edges != null)\n\t\t{\n\t\t\tvar index = this.getEdgeIndex(edge);\n\t\t\t\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\tthis.edges.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tedge.setTerminal(null, isOutgoing);\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: removeFromTerminal\n *\n * Removes the edge from its source or target terminal.\n * \n * Parameters:\n * \n * isSource - Boolean that specifies if the edge should be removed from its\n * source or target terminal.\n */\nmxCell.prototype.removeFromTerminal = function(isSource)\n{\n\tvar terminal = this.getTerminal(isSource);\n\t\n\tif (terminal != null)\n\t{\n\t\tterminal.removeEdge(this, isSource);\n\t}\n};\n\n/**\n * Function: hasAttribute\n * \n * Returns true if the user object is an XML node that contains the given\n * attribute.\n * \n * Parameters:\n * \n * name - Name of the attribute.\n */\nmxCell.prototype.hasAttribute = function(name)\n{\n\tvar userObject = this.getValue();\n\t\n\treturn (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT && userObject.hasAttribute) ?\n\t\tuserObject.hasAttribute(name) : userObject.getAttribute(name) != null;\n};\n\n/**\n * Function: getAttribute\n *\n * Returns the specified attribute from the user object if it is an XML\n * node.\n * \n * Parameters:\n * \n * name - Name of the attribute whose value should be returned.\n * defaultValue - Optional default value to use if the attribute has no\n * value.\n */\nmxCell.prototype.getAttribute = function(name, defaultValue)\n{\n\tvar userObject = this.getValue();\n\t\n\tvar val = (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT) ?\n\t\tuserObject.getAttribute(name) : null;\n\t\t\n\treturn val || defaultValue;\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the specified attribute on the user object if it is an XML node.\n * \n * Parameters:\n * \n * name - Name of the attribute whose value should be set.\n * value - New value of the attribute.\n */\nmxCell.prototype.setAttribute = function(name, value)\n{\n\tvar userObject = this.getValue();\n\t\n\tif (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tuserObject.setAttribute(name, value);\n\t}\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of the cell. Uses <cloneValue> to clone\n * the user object. All fields in <mxTransient> are ignored\n * during the cloning.\n */\nmxCell.prototype.clone = function()\n{\n\tvar clone = mxUtils.clone(this, this.mxTransient);\n\tclone.setValue(this.cloneValue());\n\t\n\treturn clone;\n};\n\n/**\n * Function: cloneValue\n *\n * Returns a clone of the cell's user object.\n */\nmxCell.prototype.cloneValue = function()\n{\n\tvar value = this.getValue();\n\t\n\tif (value != null)\n\t{\n\t\tif (typeof(value.clone) == 'function')\n\t\t{\n\t\t\tvalue = value.clone();\n\t\t}\n\t\telse if (!isNaN(value.nodeType))\n\t\t{\n\t\t\tvalue = value.cloneNode(true);\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n__mxOutput.mxCell = typeof mxCell !== 'undefined' ? mxCell : undefined;\n"]}