{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/model/mxCellPath.js"],"names":["mxCellPath","PATH_SEPARATOR","create","cell","result","parent","getParent","index","getIndex","n","length","substring","getParentPath","path","lastIndexOf","resolve","root","tokens","split","i","getChildAt","parseInt","compare","p1","p2","min","Math","comp","t1","t2","__mxOutput","undefined"],"mappings":"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","file":"mxCellPath.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxCellPath =\n{\n\n\t/**\n\t * Class: mxCellPath\n\t * \n\t * Implements a mechanism for temporary cell Ids.\n\t * \n\t * Variable: PATH_SEPARATOR\n\t * \n\t * Defines the separator between the path components. Default is \".\".\n\t */\n\tPATH_SEPARATOR: '.',\n\t\n\t/**\n\t * Function: create\n\t * \n\t * Creates the cell path for the given cell. The cell path is a\n\t * concatenation of the indices of all ancestors on the (finite) path to\n\t * the root, eg. \"0.0.0.1\".\n\t * \n\t * Parameters:\n\t * \n\t * cell - Cell whose path should be returned.\n\t */\n\tcreate: function(cell)\n\t{\n\t\tvar result = '';\n\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tvar parent = cell.getParent();\n\t\t\t\n\t\t\twhile (parent != null)\n\t\t\t{\n\t\t\t\tvar index = parent.getIndex(cell);\n\t\t\t\tresult = index + mxCellPath.PATH_SEPARATOR + result;\n\t\t\t\t\n\t\t\t\tcell = parent;\n\t\t\t\tparent = cell.getParent();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes trailing separator\n\t\tvar n = result.length;\n\t\t\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult = result.substring(0, n - 1);\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: getParentPath\n\t * \n\t * Returns the path for the parent of the cell represented by the given\n\t * path. Returns null if the given path has no parent.\n\t * \n\t * Parameters:\n\t * \n\t * path - Path whose parent path should be returned.\n\t */\n\tgetParentPath: function(path)\n\t{\n\t\tif (path != null)\n\t\t{\n\t\t\tvar index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);\n\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\treturn path.substring(0, index);\n\t\t\t}\n\t\t\telse if (path.length > 0)\n\t\t\t{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: resolve\n\t * \n\t * Returns the cell for the specified cell path using the given root as the\n\t * root of the path.\n\t * \n\t * Parameters:\n\t * \n\t * root - Root cell of the path to be resolved.\n\t * path - String that defines the path.\n\t */\n\tresolve: function(root, path)\n\t{\n\t\tvar parent = root;\n\t\t\n\t\tif (path != null)\n\t\t{\n\t\t\tvar tokens = path.split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\n\t\t\tfor (var i=0; i<tokens.length; i++)\n\t\t\t{\n\t\t\t\tparent = parent.getChildAt(parseInt(tokens[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn parent;\n\t},\n\t\n\t/**\n\t * Function: compare\n\t * \n\t * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n\t * p1 is equal and 1 if p1 is greater than p2.\n\t */\n\tcompare: function(p1, p2)\n\t{\n\t\tvar min = Math.min(p1.length, p2.length);\n\t\tvar comp = 0;\n\t\t\n\t\tfor (var i = 0; i < min; i++)\n\t\t{\n\t\t\tif (p1[i] != p2[i])\n\t\t\t{\n\t\t\t\tif (p1[i].length == 0 ||\n\t\t\t\t\tp2[i].length == 0)\n\t\t\t\t{\n\t\t\t\t\tcomp = (p1[i] == p2[i]) ? 0 : ((p1[i] > p2[i]) ? 1 : -1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar t1 = parseInt(p1[i]);\n\t\t\t\t\tvar t2 = parseInt(p2[i]);\n\t\t\t\t\t\n\t\t\t\t\tcomp = (t1 == t2) ? 0 : ((t1 > t2) ? 1 : -1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Compares path length if both paths are equal to this point\n\t\tif (comp == 0)\n\t\t{\n\t\t\tvar t1 = p1.length;\n\t\t\tvar t2 = p2.length;\n\t\t\t\n\t\t\tif (t1 != t2)\n\t\t\t{\n\t\t\t\tcomp = (t1 > t2) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn comp;\n\t}\n\n};\n\n__mxOutput.mxCellPath = typeof mxCellPath !== 'undefined' ? mxCellPath : undefined;\n"]}