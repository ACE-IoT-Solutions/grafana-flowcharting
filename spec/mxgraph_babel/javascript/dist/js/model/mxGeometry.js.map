{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/model/mxGeometry.js"],"names":["mxGeometry","x","y","width","height","mxRectangle","call","prototype","constructor","TRANSLATE_CONTROL_POINTS","alternateBounds","sourcePoint","targetPoint","points","offset","relative","swap","old","getTerminalPoint","isSource","setTerminalPoint","point","rotate","angle","cx","rad","mxUtils","toRadians","cos","Math","sin","ct","mxPoint","getCenterX","getCenterY","pt","getRotatedPoint","round","i","length","translate","dx","dy","parseFloat","scale","sx","sy","fixedAspect","min","equals","obj","apply","arguments","equalPoints","__mxOutput","undefined"],"mappings":"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","file":"mxGeometry.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGeometry\n * \n * Extends <mxRectangle> to represent the geometry of a cell.\n * \n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the sourcePoint> and <targetPoint>\n * variables, respectively.\n * \n * Example:\n * \n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n * \n * (code)\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points = [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * (end)\n * \n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's <mxEdgeStyle>.\n * \n * To disable automatic reset of control points after a cell has been moved or\n * resized, the the <mxGraph.resizeEdgesOnMove> and\n * <mxGraph.resetEdgesOnResize> may be used.\n *\n * Edge Labels:\n * \n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the <mxGeometry.offset> is used as an\n * absolute offset vector from the resulting point.\n * \n * This coordinate system is applied if <relative> is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for <x> and <y> are ignored.\n * \n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n * \n * Ports:\n * \n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n * \n * Offsets:\n * \n * The <offset> field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n * \n * Constructor: mxGeometry\n *\n * Constructs a new object to describe the size and location of a vertex or\n * the control points of an edge.\n */\nfunction mxGeometry(x, y, width, height)\n{\n\tmxRectangle.call(this, x, y, width, height);\n};\n\n/**\n * Extends mxRectangle.\n */\nmxGeometry.prototype = new mxRectangle();\nmxGeometry.prototype.constructor = mxGeometry;\n\n/**\n * Variable: TRANSLATE_CONTROL_POINTS\n * \n * Global switch to translate the points in translate. Default is true.\n */\nmxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;\n\n/**\n * Variable: alternateBounds\n *\n * Stores alternate values for x, y, width and height in a rectangle. See\n * <swap> to exchange the values. Default is null.\n */\nmxGeometry.prototype.alternateBounds = null;\n\n/**\n * Variable: sourcePoint\n *\n * Defines the source <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a source vertex. Otherwise it is\n * ignored. Default is  null.\n */\nmxGeometry.prototype.sourcePoint = null;\n\n/**\n * Variable: targetPoint\n *\n * Defines the target <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a target vertex. Otherwise it is\n * ignored. Default is null.\n */\nmxGeometry.prototype.targetPoint = null;\n\n/**\n * Variable: points\n *\n * Array of <mxPoints> which specifies the control points along the edge.\n * These points are the intermediate points on the edge, for the endpoints\n * use <targetPoint> and <sourcePoint> or set the terminals of the edge to\n * a non-null value. Default is null.\n */\nmxGeometry.prototype.points = null;\n\n/**\n * Variable: offset\n *\n * For edges, this holds the offset (in pixels) from the position defined\n * by <x> and <y> on the edge. For relative geometries (for vertices), this\n * defines the absolute offset from the point defined by the relative\n * coordinates. For absolute geometries (for vertices), this defines the\n * offset for the label. Default is null.\n */\nmxGeometry.prototype.offset = null;\n\n/**\n * Variable: relative\n *\n * Specifies if the coordinates in the geometry are to be interpreted as\n * relative coordinates. For edges, this is used to define the location of\n * the edge label relative to the edge as rendered on the display. For\n * vertices, this specifies the relative location inside the bounds of the\n * parent cell.\n * \n * If this is false, then the coordinates are relative to the origin of the\n * parent cell or, for edges, the edge label position is relative to the\n * center of the edge as rendered on screen.\n * \n * Default is false.\n */\nmxGeometry.prototype.relative = false;\n\n/**\n * Function: swap\n * \n * Swaps the x, y, width and height with the values stored in\n * <alternateBounds> and puts the previous values into <alternateBounds> as\n * a rectangle. This operation is carried-out in-place, that is, using the\n * existing geometry instance. If this operation is called during a graph\n * model transactional change, then the geometry should be cloned before\n * calling this method and setting the geometry of the cell using\n * <mxGraphModel.setGeometry>.\n */\nmxGeometry.prototype.swap = function()\n{\n\tif (this.alternateBounds != null)\n\t{\n\t\tvar old = new mxRectangle(\n\t\t\tthis.x, this.y, this.width, this.height);\n\n\t\tthis.x = this.alternateBounds.x;\n\t\tthis.y = this.alternateBounds.y;\n\t\tthis.width = this.alternateBounds.width;\n\t\tthis.height = this.alternateBounds.height;\n\n\t\tthis.alternateBounds = old;\n\t}\n};\n\n/**\n * Function: getTerminalPoint\n * \n * Returns the <mxPoint> representing the source or target point of this\n * edge. This is only used if the edge has no source or target vertex.\n * \n * Parameters:\n * \n * isSource - Boolean that specifies if the source or target point\n * should be returned.\n */\nmxGeometry.prototype.getTerminalPoint = function(isSource)\n{\n\treturn (isSource) ? this.sourcePoint : this.targetPoint;\n};\n\n/**\n * Function: setTerminalPoint\n * \n * Sets the <sourcePoint> or <targetPoint> to the given <mxPoint> and\n * returns the new point.\n * \n * Parameters:\n * \n * point - Point to be used as the new source or target point.\n * isSource - Boolean that specifies if the source or target point\n * should be set.\n */\nmxGeometry.prototype.setTerminalPoint = function(point, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.sourcePoint = point;\n\t}\n\telse\n\t{\n\t\tthis.targetPoint = point;\n\t}\n\t\n\treturn point;\n};\n\n/**\n * Function: rotate\n * \n * Rotates the geometry by the given angle around the given center. That is,\n * <x> and <y> of the geometry, the <sourcePoint>, <targetPoint> and all\n * <points> are translated by the given amount. <x> and <y> are only\n * translated if <relative> is false.\n * \n * Parameters:\n * \n * angle - Number that specifies the rotation angle in degrees.\n * cx - <mxPoint> that specifies the center of the rotation.\n */\nmxGeometry.prototype.rotate = function(angle, cx)\n{\n\tvar rad = mxUtils.toRadians(angle);\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(rad);\n\t\n\t// Rotates the geometry\n\tif (!this.relative)\n\t{\n\t\tvar ct = new mxPoint(this.getCenterX(), this.getCenterY());\n\t\tvar pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);\n\t\t\n\t\tthis.x = Math.round(pt.x - this.width / 2);\n\t\tthis.y = Math.round(pt.y - this.height / 2);\n\t}\n\n\t// Rotates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.sourcePoint, cos, sin, cx);\n\t\tthis.sourcePoint.x = Math.round(pt.x);\n\t\tthis.sourcePoint.y = Math.round(pt.y);\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.targetPoint, cos, sin, cx);\n\t\tthis.targetPoint.x = Math.round(pt.x);\n\t\tthis.targetPoint.y = Math.round(pt.y);\t\n\t}\n\t\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(this.points[i], cos, sin, cx);\n\t\t\t\tthis.points[i].x = Math.round(pt.x);\n\t\t\t\tthis.points[i].y = Math.round(pt.y);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: translate\n * \n * Translates the geometry by the specified amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are translated\n * by the given amount. <x> and <y> are only translated if <relative> is false.\n * If <TRANSLATE_CONTROL_POINTS> is false, then <points> are not modified by\n * this function.\n * \n * Parameters:\n * \n * dx - Number that specifies the x-coordinate of the translation.\n * dy - Number that specifies the y-coordinate of the translation.\n */\nmxGeometry.prototype.translate = function(dx, dy)\n{\n\tdx = parseFloat(dx);\n\tdy = parseFloat(dy);\n\t\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) + dx;\n\t\tthis.y = parseFloat(this.y) + dy;\n\t}\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) + dx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) + dy;\t\t\n\t}\n\n\t// Translate the control points\n\tif (this.TRANSLATE_CONTROL_POINTS && this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) + dx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) + dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: scale\n * \n * Scales the geometry by the given amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are scaled\n * by the given amount. <x>, <y>, <width> and <height> are only scaled if\n * <relative> is false. If <fixedAspect> is true, then the smaller value\n * is used to scale the width and the height.\n * \n * Parameters:\n * \n * sx - Number that specifies the horizontal scale factor.\n * sy - Number that specifies the vertical scale factor.\n * fixedAspect - Optional boolean to keep the aspect ratio fixed.\n */\nmxGeometry.prototype.scale = function(sx, sy, fixedAspect)\n{\n\tsx = parseFloat(sx);\n\tsy = parseFloat(sy);\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) * sx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) * sy;\t\t\n\t}\n\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) * sx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) * sy;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) * sx;\n\t\tthis.y = parseFloat(this.y) * sy;\n\n\t\tif (fixedAspect)\n\t\t{\n\t\t\tsy = sx = Math.min(sx, sy);\n\t\t}\n\t\t\n\t\tthis.width = parseFloat(this.width) * sx;\n\t\tthis.height = parseFloat(this.height) * sy;\n\t}\n};\n\n/**\n * Function: equals\n * \n * Returns true if the given object equals this geometry.\n */\nmxGeometry.prototype.equals = function(obj)\n{\n\treturn mxRectangle.prototype.equals.apply(this, arguments) &&\n\t\tthis.relative == obj.relative &&\n\t\t((this.sourcePoint == null && obj.sourcePoint == null) || (this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint))) &&\n\t\t((this.targetPoint == null && obj.targetPoint == null) || (this.targetPoint != null && this.targetPoint.equals(obj.targetPoint))) &&\n\t\t((this.points == null && obj.points == null) || (this.points != null && mxUtils.equalPoints(this.points, obj.points))) &&\n\t\t((this.alternateBounds == null && obj.alternateBounds == null) || (this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds))) &&\n\t\t((this.offset == null && obj.offset == null) || (this.offset != null && this.offset.equals(obj.offset)));\n};\n\n__mxOutput.mxGeometry = typeof mxGeometry !== 'undefined' ? mxGeometry : undefined;\n"]}