{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/model/mxGraphModel.js"],"names":["mxGraphModel","root","currentEdit","createUndoableEdit","setRoot","clear","mxRootChange","model","previous","mxChildChange","parent","child","index","previousIndex","mxTerminalChange","cell","terminal","source","mxValueChange","value","mxStyleChange","style","mxGeometryChange","geometry","mxCollapseChange","collapsed","mxVisibleChange","visible","mxCellAttributeChange","attribute","prototype","mxEventSource","constructor","cells","maintainEdgeParent","ignoreRelativeEdgeParent","createIds","prefix","postfix","nextId","updateLevel","endingUpdate","createRoot","isCreateIds","setCreateIds","mxCell","insert","getCell","id","filterCells","filter","result","i","length","push","getDescendants","filterDescendants","getRoot","childCount","getChildCount","getChildAt","concat","getParent","execute","rootChanged","oldRoot","cellAdded","isRoot","isLayer","isAncestor","contains","add","parentChanged","updateEdgeParents","getId","setId","createId","collision","Object","mxUtils","isNumeric","Math","max","edgeCount","getEdgeCount","edges","getEdgeAt","edge","updateEdgeParent","getTerminal","target","isEdge","relative","getNearestCommonAncestor","geo","getGeometry","origin1","getOrigin","origin2","dx","x","dy","y","clone","translate","setGeometry","mxPoint","cell1","cell2","path","mxCellPath","create","current","tmp","indexOf","PATH_SEPARATOR","getParentPath","remove","cellRemoved","parentForCellChanged","getIndex","oldIndex","getChildren","children","getChildVertices","getChildCells","getChildEdges","vertices","isVertex","isSource","setTerminal","terminalChanged","setTerminals","beginUpdate","endUpdate","terminalForCellChanged","insertEdge","removeEdge","getDirectedEdgeCount","outgoing","ignoredEdge","count","getConnections","getEdges","getIncomingEdges","getOutgoingEdges","incoming","includeLoops","getEdgesBetween","directed","tmp1","tmp2","src","trg","directedMatch","oppositeMatch","getOpposites","sources","targets","terminals","getTopmostCells","dict","mxDictionary","put","topmost","get","isConnectable","getValue","setValue","valueForCellChanged","valueChanged","geometryForCellChanged","getStyle","setStyle","styleForCellChanged","isCollapsed","setCollapsed","collapsedStateForCellChanged","isVisible","setVisible","visibleStateForCellChanged","change","fireEvent","mxEventObject","mxEvent","EXECUTE","EXECUTED","BEGIN_UPDATE","START_EDIT","END_EDIT","END_UPDATE","isEmpty","BEFORE_UNDO","notify","UNDO","significant","edit","mxUndoableEdit","CHANGE","changes","NOTIFY","mergeChildren","from","to","cloneAllEdges","mapping","mergeChildrenImpl","key","getParents","parents","cloneCell","cloneCells","includeChildren","clones","cloneCellImpl","restoreClone","ident","mxObjectIdentity","cellCloned","cloneChild","connect","isConnect","getAttribute","removeAttribute","setAttribute","__mxOutput","undefined"],"mappings":"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","file":"mxGraphModel.js","sourcesContent":["/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphModel\n * \n * Extends <mxEventSource> to implement a graph model. The graph model acts as\n * a wrapper around the cells which are in charge of storing the actual graph\n * datastructure. The model acts as a transactional wrapper with event\n * notification for all changes, whereas the cells contain the atomic\n * operations for updating the actual datastructure.\n * \n * Layers:\n * \n * The cell hierarchy in the model must have a top-level root cell which\n * contains the layers (typically one default layer), which in turn contain the\n * top-level cells of the layers. This means each cell is contained in a layer.\n * If no layers are required, then all new cells should be added to the default\n * layer.\n * \n * Layers are useful for hiding and showing groups of cells, or for placing\n * groups of cells on top of other cells in the display. To identify a layer,\n * the <isLayer> function is used. It returns true if the parent of the given\n * cell is the root of the model.\n * \n * Events:\n * \n * See events section for more details. There is a new set of events for\n * tracking transactional changes as they happen. The events are called\n * startEdit for the initial beginUpdate, executed for each executed change\n * and endEdit for the terminal endUpdate. The executed event contains a\n * property called change which represents the change after execution.\n * \n * Encoding the model:\n * \n * To encode a graph model, use the following code:\n * \n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(graph.getModel());\n * (end)\n * \n * This will create an XML node that contains all the model information.\n * \n * Encoding and decoding changes:\n * \n * For the encoding of changes, a graph model listener is required that encodes\n * each change from the given array of changes.\n * \n * (code)\n * model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *   var nodes = [];\n *   var codec = new mxCodec();\n * \n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     nodes.push(codec.encode(changes[i]));\n *   }\n *   // do something with the nodes\n * });\n * (end)\n * \n * For the decoding and execution of changes, the codec needs a lookup function\n * that allows it to resolve cell IDs as follows:\n * \n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * }\n * (end)\n * \n * For each encoded change (represented by a node), the following code can be\n * used to carry out the decoding and create a change object.\n * \n * (code)\n * var changes = [];\n * var change = codec.decode(node);\n * change.model = model;\n * change.execute();\n * changes.push(change);\n * (end)\n * \n * The changes can then be dispatched using the model as follows.\n * \n * (code)\n * var edit = new mxUndoableEdit(model, false);\n * edit.changes = changes;\n * \n * edit.notify = function()\n * {\n *   edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n *   \t'edit', edit, 'changes', edit.changes));\n *   edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n *   \t'edit', edit, 'changes', edit.changes));\n * }\n * \n * model.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n * model.fireEvent(new mxEventObject(mxEvent.CHANGE,\n * \t\t'edit', edit, 'changes', changes));\n * (end)\n *\n * Event: mxEvent.CHANGE\n *\n * Fires when an undoable edit is dispatched. The <code>edit</code> property\n * contains the <mxUndoableEdit>. The <code>changes</code> property contains\n * the array of atomic changes inside the undoable edit. The changes property\n * is <strong>deprecated</strong>, please use edit.changes instead.\n *\n * Example:\n * \n * For finding newly inserted cells, the following code can be used:\n * \n * (code)\n * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n * \n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     var change = changes[i];\n *     \n *     if (change instanceof mxChildChange &&\n *       change.change.previous == null)\n *     {\n *       graph.startEditingAtCell(change.child);\n *       break;\n *     }\n *   }\n * });\n * (end)\n * \n * \n * Event: mxEvent.NOTIFY\n *\n * Same as <mxEvent.CHANGE>, this event can be used for classes that need to\n * implement a sync mechanism between this model and, say, a remote model. In\n * such a setup, only local changes should trigger a notify event and all\n * changes should trigger a change event.\n * \n * Event: mxEvent.EXECUTE\n * \n * Fires between begin- and endUpdate and after an atomic change was executed\n * in the model. The <code>change</code> property contains the atomic change\n * that was executed.\n * \n * Event: mxEvent.EXECUTED\n * \n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n *\n * Event: mxEvent.BEGIN_UPDATE\n *\n * Fires after the <updateLevel> was incremented in <beginUpdate>. This event\n * contains no properties.\n * \n * Event: mxEvent.START_EDIT\n *\n * Fires after the <updateLevel> was changed from 0 to 1. This event\n * contains no properties.\n * \n * Event: mxEvent.END_UPDATE\n * \n * Fires after the <updateLevel> was decreased in <endUpdate> but before any\n * notification or change dispatching. The <code>edit</code> property contains\n * the <currentEdit>.\n * \n * Event: mxEvent.END_EDIT\n *\n * Fires after the <updateLevel> was changed from 1 to 0. This event\n * contains no properties.\n * \n * Event: mxEvent.BEFORE_UNDO\n * \n * Fires before the change is dispatched after the update level has reached 0\n * in <endUpdate>. The <code>edit</code> property contains the <curreneEdit>.\n * \n * Event: mxEvent.UNDO\n * \n * Fires after the change was dispatched in <endUpdate>. The <code>edit</code>\n * property contains the <currentEdit>.\n * \n * Constructor: mxGraphModel\n * \n * Constructs a new graph model. If no root is specified then a new root\n * <mxCell> with a default layer is created.\n * \n * Parameters:\n * \n * root - <mxCell> that represents the root cell.\n */\nfunction mxGraphModel(root)\n{\n\tthis.currentEdit = this.createUndoableEdit();\n\t\n\tif (root != null)\n\t{\n\t\tthis.setRoot(root);\n\t}\n\telse\n\t{\n\t\tthis.clear();\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphModel.prototype = new mxEventSource();\nmxGraphModel.prototype.constructor = mxGraphModel;\n\n/**\n * Variable: root\n * \n * Holds the root cell, which in turn contains the cells that represent the\n * layers of the diagram as child cells. That is, the actual elements of the\n * diagram are supposed to live in the third generation of cells and below.\n */\nmxGraphModel.prototype.root = null;\n\n/**\n * Variable: cells\n * \n * Maps from Ids to cells.\n */\nmxGraphModel.prototype.cells = null;\n\n/**\n * Variable: maintainEdgeParent\n * \n * Specifies if edges should automatically be moved into the nearest common\n * ancestor of their terminals. Default is true.\n */\nmxGraphModel.prototype.maintainEdgeParent = true;\n\n/**\n * Variable: ignoreRelativeEdgeParent\n * \n * Specifies if relative edge parents should be ignored for finding the nearest\n * common ancestors of an edge's terminals. Default is true.\n */\nmxGraphModel.prototype.ignoreRelativeEdgeParent = true;\n\n/**\n * Variable: createIds\n * \n * Specifies if the model should automatically create Ids for new cells.\n * Default is true.\n */\nmxGraphModel.prototype.createIds = true;\n\n/**\n * Variable: prefix\n * \n * Defines the prefix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.prefix = '';\n\n/**\n * Variable: postfix\n * \n * Defines the postfix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.postfix = '';\n\n/**\n * Variable: nextId\n * \n * Specifies the next Id to be created. Initial value is 0.\n */\nmxGraphModel.prototype.nextId = 0;\n\n/**\n * Variable: currentEdit\n * \n * Holds the changes for the current transaction. If the transaction is\n * closed then a new object is created for this variable using\n * <createUndoableEdit>.\n */\nmxGraphModel.prototype.currentEdit = null;\n\n/**\n * Variable: updateLevel\n * \n * Counter for the depth of nested transactions. Each call to <beginUpdate>\n * will increment this number and each call to <endUpdate> will decrement\n * it. When the counter reaches 0, the transaction is closed and the\n * respective events are fired. Initial value is 0.\n */\nmxGraphModel.prototype.updateLevel = 0;\n\n/**\n * Variable: endingUpdate\n * \n * True if the program flow is currently inside endUpdate.\n */\nmxGraphModel.prototype.endingUpdate = false;\n\n/**\n * Function: clear\n *\n * Sets a new root using <createRoot>.\n */\nmxGraphModel.prototype.clear = function()\n{\n\tthis.setRoot(this.createRoot());\n};\n\n/**\n * Function: isCreateIds\n *\n * Returns <createIds>.\n */\nmxGraphModel.prototype.isCreateIds = function()\n{\n\treturn this.createIds;\n};\n\n/**\n * Function: setCreateIds\n *\n * Sets <createIds>.\n */\nmxGraphModel.prototype.setCreateIds = function(value)\n{\n\tthis.createIds = value;\n};\n\n/**\n * Function: createRoot\n *\n * Creates a new root cell with a default layer (child 0).\n */\nmxGraphModel.prototype.createRoot = function()\n{\n\tvar cell = new mxCell();\n\tcell.insert(new mxCell());\n\t\n\treturn cell;\n};\n\n/**\n * Function: getCell\n *\n * Returns the <mxCell> for the specified Id or null if no cell can be\n * found for the given Id.\n *\n * Parameters:\n * \n * id - A string representing the Id of the cell.\n */\nmxGraphModel.prototype.getCell = function(id)\n{\n\treturn (this.cells != null) ? this.cells[id] : null;\n};\n\n/**\n * Function: filterCells\n * \n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nmxGraphModel.prototype.filterCells = function(cells, filter)\n{\n\tvar result = null;\n\t\n\tif (cells != null)\n\t{\n\t\tresult = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (filter(cells[i]))\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getDescendants\n * \n * Returns all descendants of the given cell and the cell itself in an array.\n * \n * Parameters:\n * \n * parent - <mxCell> whose descendants should be returned.\n */\nmxGraphModel.prototype.getDescendants = function(parent)\n{\n\treturn this.filterDescendants(null, parent);\n};\n\n/**\n * Function: filterDescendants\n * \n * Visits all cells recursively and applies the specified filter function\n * to each cell. If the function returns true then the cell is added\n * to the resulting array. The parent and result paramters are optional.\n * If parent is not specified then the recursion starts at <root>.\n * \n * Example:\n * The following example extracts all vertices from a given model:\n * (code)\n * var filter = function(cell)\n * {\n * \treturn model.isVertex(cell);\n * }\n * var vertices = model.filterDescendants(filter);\n * (end)\n * \n * Parameters:\n * \n * filter - JavaScript function that takes an <mxCell> as an argument\n * and returns a boolean.\n * parent - Optional <mxCell> that is used as the root of the recursion.\n */\nmxGraphModel.prototype.filterDescendants = function(filter, parent)\n{\n\t// Creates a new array for storing the result\n\tvar result = [];\n\n\t// Recursion starts at the root of the model\n\tparent = parent || this.getRoot();\n\t\n\t// Checks if the filter returns true for the cell\n\t// and adds it to the result array\n\tif (filter == null || filter(parent))\n\t{\n\t\tresult.push(parent);\n\t}\n\t\n\t// Visits the children of the cell\n\tvar childCount = this.getChildCount(parent);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\t\tresult = result.concat(this.filterDescendants(filter, child));\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getRoot\n * \n * Returns the root of the model or the topmost parent of the given cell.\n *\n * Parameters:\n * \n * cell - Optional <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.getRoot = function(cell)\n{\n\tvar root = cell || this.root;\n\t\n\tif (cell != null)\n\t{\n\t\twhile (cell != null)\n\t\t{\n\t\t\troot = cell;\n\t\t\tcell = this.getParent(cell);\n\t\t}\n\t}\n\t\n\treturn root;\n};\n\n/**\n * Function: setRoot\n * \n * Sets the <root> of the model using <mxRootChange> and adds the change to\n * the current transaction. This resets all datastructures in the model and\n * is the preferred way of clearing an existing model. Returns the new\n * root.\n * \n * Example:\n * \n * (code)\n * var root = new mxCell();\n * root.insert(new mxCell());\n * model.setRoot(root);\n * (end)\n *\n * Parameters:\n * \n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.setRoot = function(root)\n{\n\tthis.execute(new mxRootChange(this, root));\n\t\n\treturn root;\n};\n\n/**\n * Function: rootChanged\n * \n * Inner callback to change the root of the model and update the internal\n * datastructures, such as <cells> and <nextId>. Returns the previous root.\n *\n * Parameters:\n * \n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.rootChanged = function(root)\n{\n\tvar oldRoot = this.root;\n\tthis.root = root;\n\t\n\t// Resets counters and datastructures\n\tthis.nextId = 0;\n\tthis.cells = null;\n\tthis.cellAdded(root);\n\t\n\treturn oldRoot;\n};\n\n/**\n * Function: isRoot\n * \n * Returns true if the given cell is the root of the model and a non-null\n * value.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible root.\n */\nmxGraphModel.prototype.isRoot = function(cell)\n{\n\treturn cell != null && this.root == cell;\n};\n\n/**\n * Function: isLayer\n * \n * Returns true if <isRoot> returns true for the parent of the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible layer.\n */\nmxGraphModel.prototype.isLayer = function(cell)\n{\n\treturn this.isRoot(this.getParent(cell));\n};\n\n/**\n * Function: isAncestor\n * \n * Returns true if the given parent is an ancestor of the given child. Note \n * returns true if child == parent.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.isAncestor = function(parent, child)\n{\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.getParent(child);\n\t}\n\t\n\treturn child == parent;\n};\n\n/**\n * Function: contains\n * \n * Returns true if the model contains the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell.\n */\nmxGraphModel.prototype.contains = function(cell)\n{\n\treturn this.isAncestor(this.root, cell);\n};\n\n/**\n * Function: getParent\n * \n * Returns the parent of the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> whose parent should be returned.\n */\nmxGraphModel.prototype.getParent = function(cell)\n{\n\treturn (cell != null) ? cell.getParent() : null;\n};\n\n/**\n * Function: add\n * \n * Adds the specified child to the parent at the given index using\n * <mxChildChange> and adds the change to the current transaction. If no\n * index is specified then the child is appended to the parent's array of\n * children. Returns the inserted child.\n * \n * Parameters:\n * \n * parent - <mxCell> that specifies the parent to contain the child.\n * child - <mxCell> that specifies the child to be inserted.\n * index - Optional integer that specifies the index of the child.\n */\nmxGraphModel.prototype.add = function(parent, child, index)\n{\n\tif (child != parent && parent != null && child != null)\n\t{\t\n\t\t// Appends the child if no index was specified\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount(parent);\n\t\t}\n\t\t\n\t\tvar parentChanged = parent != this.getParent(child);\n\t\tthis.execute(new mxChildChange(this, parent, child, index));\n\n\t\t// Maintains the edges parents by moving the edges\n\t\t// into the nearest common ancestor of its terminals\n\t\tif (this.maintainEdgeParent && parentChanged)\n\t\t{\n\t\t\tthis.updateEdgeParents(child);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: cellAdded\n * \n * Inner callback to update <cells> when a cell has been added. This\n * implementation resolves collisions by creating new Ids. To change the\n * ID of a cell after it was inserted into the model, use the following\n * code:\n * \n * (code\n * delete model.cells[cell.getId()];\n * cell.setId(newId);\n * model.cells[cell.getId()] = cell;\n * (end)\n *\n * If the change of the ID should be part of the command history, then the\n * cell should be removed from the model and a clone with the new ID should\n * be reinserted into the model instead.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell that has been added.\n */\nmxGraphModel.prototype.cellAdded = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\t// Creates an Id for the cell if not Id exists\n\t\tif (cell.getId() == null && this.createIds)\n\t\t{\n\t\t\tcell.setId(this.createId(cell));\n\t\t}\n\t\t\n\t\tif (cell.getId() != null)\n\t\t{\n\t\t\tvar collision = this.getCell(cell.getId());\n\t\t\t\n\t\t\tif (collision != cell)\n\t\t\t{\t\n\t\t\t\t// Creates new Id for the cell\n\t\t\t\t// as long as there is a collision\n\t\t\t\twhile (collision != null)\n\t\t\t\t{\n\t\t\t\t\tcell.setId(this.createId(cell));\n\t\t\t\t\tcollision = this.getCell(cell.getId());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Lazily creates the cells dictionary\n\t\t\t\tif (this.cells == null)\n\t\t\t\t{\n\t\t\t\t\tthis.cells = new Object();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.cells[cell.getId()] = cell;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Makes sure IDs of deleted cells are not reused\n\t\tif (mxUtils.isNumeric(cell.getId()))\n\t\t{\n\t\t\tthis.nextId = Math.max(this.nextId, cell.getId());\n\t\t}\n\t\t\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\t\t\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tthis.cellAdded(this.getChildAt(cell, i));\n\t\t}\n\t}\n};\n\n/**\n * Function: createId\n * \n * Hook method to create an Id for the specified cell. This implementation\n * concatenates <prefix>, id and <postfix> to create the Id and increments\n * <nextId>. The cell is ignored by this implementation, but can be used in\n * overridden methods to prefix the Ids with eg. the cell type.\n *\n * Parameters:\n *\n * cell - <mxCell> to create the Id for.\n */\nmxGraphModel.prototype.createId = function(cell)\n{\n\tvar id = this.nextId;\n\tthis.nextId++;\n\t\n\treturn this.prefix + id + this.postfix;\n};\n\n/**\n * Function: updateEdgeParents\n * \n * Updates the parent for all edges that are connected to cell or one of\n * its descendants using <updateEdgeParent>.\n */\nmxGraphModel.prototype.updateEdgeParents = function(cell, root)\n{\n\t// Gets the topmost node of the hierarchy\n\troot = root || this.getRoot(cell);\n\t\n\t// Updates edges on children first\n\tvar childCount = this.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(cell, i);\n\t\tthis.updateEdgeParents(child, root);\n\t}\n\t\n\t// Updates the parents of all connected edges\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar edges = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tedges.push(this.getEdgeAt(cell, i));\n\t}\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar edge = edges[i];\n\t\t\n\t\t// Updates edge parent if edge and child have\n\t\t// a common root node (does not need to be the\n\t\t// model root node)\n\t\tif (this.isAncestor(root, edge))\n\t\t{\n\t\t\tthis.updateEdgeParent(edge, root);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateEdgeParent\n *\n * Inner callback to update the parent of the specified <mxCell> to the\n * nearest-common-ancestor of its two terminals.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * root - <mxCell> that represents the current root of the model.\n */\nmxGraphModel.prototype.updateEdgeParent = function(edge, root)\n{\n\tvar source = this.getTerminal(edge, true);\n\tvar target = this.getTerminal(edge, false);\n\tvar cell = null;\n\t\n\t// Uses the first non-relative descendants of the source terminal\n\twhile (source != null && !this.isEdge(source) &&\n\t\tsource.geometry != null && source.geometry.relative)\n\t{\n\t\tsource = this.getParent(source);\n\t}\n\t\n\t// Uses the first non-relative descendants of the target terminal\n\twhile (target != null && this.ignoreRelativeEdgeParent &&\n\t\t!this.isEdge(target) && target.geometry != null && \n\t\ttarget.geometry.relative)\n\t{\n\t\ttarget = this.getParent(target);\n\t}\n\t\n\tif (this.isAncestor(root, source) && this.isAncestor(root, target))\n\t{\n\t\tif (source == target)\n\t\t{\n\t\t\tcell = this.getParent(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell = this.getNearestCommonAncestor(source, target);\n\t\t}\n\n\t\tif (cell != null && (this.getParent(cell) != this.root ||\n\t\t\tthis.isAncestor(cell, edge)) && this.getParent(edge) != cell)\n\t\t{\n\t\t\tvar geo = this.getGeometry(edge);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar origin1 = this.getOrigin(this.getParent(edge));\n\t\t\t\tvar origin2 = this.getOrigin(cell);\n\t\t\t\t\n\t\t\t\tvar dx = origin2.x - origin1.x;\n\t\t\t\tvar dy = origin2.y - origin1.y;\n\t\t\t\t\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.translate(-dx, -dy);\n\t\t\t\tthis.setGeometry(edge, geo);\n\t\t\t}\n\n\t\t\tthis.add(cell, edge, this.getChildCount(cell));\n\t\t}\n\t}\n};\n\n/**\n * Function: getOrigin\n * \n * Returns the absolute, accumulated origin for the children inside the\n * given parent as an <mxPoint>.\n */\nmxGraphModel.prototype.getOrigin = function(cell)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tresult = this.getOrigin(this.getParent(cell));\n\t\t\n\t\tif (!this.isEdge(cell))\n\t\t{\n\t\t\tvar geo = this.getGeometry(cell);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint();\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getNearestCommonAncestor\n * \n * Returns the nearest common ancestor for the specified cells.\n *\n * Parameters:\n * \n * cell1 - <mxCell> that specifies the first cell in the tree.\n * cell2 - <mxCell> that specifies the second cell in the tree.\n */\nmxGraphModel.prototype.getNearestCommonAncestor = function(cell1, cell2)\n{\n\tif (cell1 != null && cell2 != null)\n\t{\t\t\n\t\t// Creates the cell path for the second cell\n\t\tvar path = mxCellPath.create(cell2);\n\n\t\tif (path != null && path.length > 0)\n\t\t{\n\t\t\t// Bubbles through the ancestors of the first\n\t\t\t// cell to find the nearest common ancestor.\n\t\t\tvar cell = cell1;\n\t\t\tvar current = mxCellPath.create(cell);\n\t\t\t\n\t\t\t// Inverts arguments\n\t\t\tif (path.length < current.length)\n\t\t\t{\n\t\t\t\tcell = cell2;\n\t\t\t\tvar tmp = current;\n\t\t\t\tcurrent = path;\n\t\t\t\tpath = tmp;\n\t\t\t}\n\t\t\t\n\t\t\twhile (cell != null)\n\t\t\t{\n\t\t\t\tvar parent = this.getParent(cell);\n\t\t\t\t\n\t\t\t\t// Checks if the cell path is equal to the beginning of the given cell path\n\t\t\t\tif (path.indexOf(current + mxCellPath.PATH_SEPARATOR) == 0 && parent != null)\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurrent = mxCellPath.getParentPath(current);\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: remove\n * \n * Removes the specified cell from the model using <mxChildChange> and adds\n * the change to the current transaction. This operation will remove the\n * cell and all of its children from the model. Returns the removed cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that should be removed.\n */\nmxGraphModel.prototype.remove = function(cell)\n{\n\tif (cell == this.root)\n\t{\n\t\tthis.setRoot(null);\n\t}\n\telse if (this.getParent(cell) != null)\n\t{\n\t\tthis.execute(new mxChildChange(this, null, cell));\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellRemoved\n * \n * Inner callback to update <cells> when a cell has been removed.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell that has been removed.\n */\nmxGraphModel.prototype.cellRemoved = function(cell)\n{\n\tif (cell != null && this.cells != null)\n\t{\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\t\t\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tthis.cellRemoved(this.getChildAt(cell, i));\n\t\t}\n\t\t\n\t\t// Removes the dictionary entry for the cell\n\t\tif (this.cells != null && cell.getId() != null)\n\t\t{\n\t\t\tdelete this.cells[cell.getId()];\n\t\t}\n\t}\n};\n\n/**\n * Function: parentForCellChanged\n * \n * Inner callback to update the parent of a cell using <mxCell.insert>\n * on the parent and return the previous parent.\n *\n * Parameters:\n * \n * cell - <mxCell> to update the parent for.\n * parent - <mxCell> that specifies the new parent of the cell.\n * index - Optional integer that defines the index of the child\n * in the parent's child array.\n */\nmxGraphModel.prototype.parentForCellChanged = function(cell, parent, index)\n{\n\tvar previous = this.getParent(cell);\n\t\n\tif (parent != null)\n\t{\n\t\tif (parent != previous || previous.getIndex(cell) != index)\n\t\t{\n\t\t\tparent.insert(cell, index);\n\t\t}\n\t}\n\telse if (previous != null)\n\t{\n\t\tvar oldIndex = previous.getIndex(cell);\n\t\tprevious.remove(oldIndex);\n\t}\n\t\n\t// Checks if the previous parent was already in the\n\t// model and avoids calling cellAdded if it was.\n\tif (!this.contains(previous) && parent != null)\n\t{\n\t\tthis.cellAdded(cell);\n\t}\n\telse if (parent == null)\n\t{\n\t\tthis.cellRemoved(cell);\n\t}\n\t\n\treturn previous;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of children in the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> whose number of children should be returned.\n */\nmxGraphModel.prototype.getChildCount = function(cell)\n{\n\treturn (cell != null) ? cell.getChildCount() : 0;\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child of the given <mxCell> at the given index.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the parent.\n * index - Integer that specifies the index of the child to be returned.\n */\nmxGraphModel.prototype.getChildAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getChildAt(index) : null;\n};\n\n/**\n * Function: getChildren\n * \n * Returns all children of the given <mxCell> as an array of <mxCells>. The\n * return value should be only be read.\n *\n * Parameters:\n * \n * cell - <mxCell> the represents the parent.\n */\nmxGraphModel.prototype.getChildren = function(cell)\n{\n\treturn (cell != null) ? cell.children : null;\n};\n\t\n/**\n * Function: getChildVertices\n * \n * Returns the child vertices of the given parent.\n *\n * Parameters:\n * \n * cell - <mxCell> whose child vertices should be returned.\n */\nmxGraphModel.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\t\t\n/**\n * Function: getChildEdges\n * \n * Returns the child edges of the given parent.\n *\n * Parameters:\n * \n * cell - <mxCell> whose child edges should be returned.\n */\nmxGraphModel.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n * \n * Returns the children of the given cell that are vertices and/or edges\n * depending on the arguments.\n *\n * Parameters:\n * \n * cell - <mxCell> the represents the parent.\n * vertices - Boolean indicating if child vertices should be returned.\n * Default is false.\n * edges - Boolean indicating if child edges should be returned.\n * Default is false.\n */\nmxGraphModel.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\t\n\tvar childCount = this.getChildCount(parent);\n\tvar result = [];\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\n\t\tif ((!edges && !vertices) || (edges && this.isEdge(child)) ||\n\t\t\t(vertices && this.isVertex(child)))\n\t\t{\n\t\t\tresult.push(child);\n\t\t}\n\t}\n\n\treturn result;\n};\n\t\t\n/**\n * Function: getTerminal\n * \n * Returns the source or target <mxCell> of the given edge depending on the\n * value of the boolean parameter.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * isSource - Boolean indicating which end of the edge should be returned.\n */\nmxGraphModel.prototype.getTerminal = function(edge, isSource)\n{\n\treturn (edge != null) ? edge.getTerminal(isSource) : null;\n};\n\n/**\n * Function: setTerminal\n * \n * Sets the source or target terminal of the given <mxCell> using\n * <mxTerminalChange> and adds the change to the current transaction.\n * This implementation updates the parent of the edge using <updateEdgeParent>\n * if required.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.setTerminal = function(edge, terminal, isSource)\n{\n\tvar terminalChanged = terminal != this.getTerminal(edge, isSource);\n\tthis.execute(new mxTerminalChange(this, edge, terminal, isSource));\n\t\n\tif (this.maintainEdgeParent && terminalChanged)\n\t{\n\t\tthis.updateEdgeParent(edge, this.getRoot());\n\t}\n\t\n\treturn terminal;\n};\n\t\n/**\n * Function: setTerminals\n * \n * Sets the source and target <mxCell> of the given <mxCell> in a single\n * transaction using <setTerminal> for each end of the edge.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * source - <mxCell> that specifies the new source terminal.\n * target - <mxCell> that specifies the new target terminal.\n */\nmxGraphModel.prototype.setTerminals = function(edge, source, target)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tthis.setTerminal(edge, source, true);\n\t\tthis.setTerminal(edge, target, false);\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: terminalForCellChanged\n * \n * Inner helper function to update the terminal of the edge using\n * <mxCell.insertEdge> and return the previous terminal.\n * \n * Parameters:\n * \n * edge - <mxCell> that specifies the edge to be updated.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.terminalForCellChanged = function(edge, terminal, isSource)\n{\n\tvar previous = this.getTerminal(edge, isSource);\n\t\n\tif (terminal != null)\n\t{\n\t\tterminal.insertEdge(edge, isSource);\n\t}\n\telse if (previous != null)\n\t{\n\t\tprevious.removeEdge(edge, isSource);\n\t}\n\t\n\treturn previous;\n};\n\n/**\n * Function: getEdgeCount\n * \n * Returns the number of distinct edges connected to the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the vertex.\n */\nmxGraphModel.prototype.getEdgeCount = function(cell)\n{\n\treturn (cell != null) ? cell.getEdgeCount() : 0;\n};\n\n/**\n * Function: getEdgeAt\n * \n * Returns the edge of cell at the given index.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the vertex.\n * index - Integer that specifies the index of the edge\n * to return.\n */\nmxGraphModel.prototype.getEdgeAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getEdgeAt(index) : null;\n};\n\t\n/**\n * Function: getDirectedEdgeCount\n * \n * Returns the number of incoming or outgoing edges, ignoring the given\n * edge.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edge count should be returned.\n * outgoing - Boolean that specifies if the number of outgoing or\n * incoming edges should be returned.\n * ignoredEdge - <mxCell> that represents an edge to be ignored.\n */\nmxGraphModel.prototype.getDirectedEdgeCount = function(cell, outgoing, ignoredEdge)\n{\n\tvar count = 0;\n\tvar edgeCount = this.getEdgeCount(cell);\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\n\t\tif (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n};\n\n/**\n * Function: getConnections\n * \n * Returns all edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n * \n */\nmxGraphModel.prototype.getConnections = function(cell)\n{\n\treturn this.getEdges(cell, true, true, false);\n};\n\n/**\n * Function: getIncomingEdges\n * \n * Returns the incoming edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose incoming edges should be returned.\n * \n */\nmxGraphModel.prototype.getIncomingEdges = function(cell)\n{\n\treturn this.getEdges(cell, true, false, false);\n};\n\n/**\n * Function: getOutgoingEdges\n * \n * Returns the outgoing edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose outgoing edges should be returned.\n * \n */\nmxGraphModel.prototype.getOutgoingEdges = function(cell)\n{\n\treturn this.getEdges(cell, false, true, false);\n};\n\n/**\n * Function: getEdges\n * \n * Returns all distinct edges connected to this cell as a new array of\n * <mxCells>. If at least one of incoming or outgoing is true, then loops\n * are ignored, otherwise if both are false, then all edges connected to\n * the given cell are returned including loops.\n * \n * Parameters:\n * \n * cell - <mxCell> that specifies the cell.\n * incoming - Optional boolean that specifies if incoming edges should be\n * returned. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should be\n * returned. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be returned.\n * Default is true. \n */\nmxGraphModel.prototype.getEdges = function(cell, incoming, outgoing, includeLoops)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\t\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar result = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\t\tvar source = this.getTerminal(edge, true);\n\t\tvar target = this.getTerminal(edge, false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming && target == cell) ||\n\t\t\t(outgoing && source == cell))))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns all edges between the given source and target pair. If directed\n * is true, then only edges from the source to the target are returned,\n * otherwise, all edges between the two cells are returned.\n * \n * Parameters:\n * \n * source - <mxCell> that defines the source terminal of the edge to be\n * returned.\n * target - <mxCell> that defines the target terminal of the edge to be\n * returned.\n * directed - Optional boolean that specifies if the direction of the\n * edge should be taken into account. Default is false.\n */\nmxGraphModel.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\t\n\tvar tmp1 = this.getEdgeCount(source);\n\tvar tmp2 = this.getEdgeCount(target);\n\t\n\t// Assumes the source has less connected edges\n\tvar terminal = source;\n\tvar edgeCount = tmp1;\n\t\n\t// Uses the smaller array of connected edges\n\t// for searching the edge\n\tif (tmp2 < tmp1)\n\t{\n\t\tedgeCount = tmp2;\n\t\tterminal = target;\n\t}\n\t\n\tvar result = [];\n\t\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(terminal, i);\n\t\tvar src = this.getTerminal(edge, true);\n\t\tvar trg = this.getTerminal(edge, false);\n\t\tvar directedMatch = (src == source) && (trg == target);\n\t\tvar oppositeMatch = (trg == source) && (src == target);\n\n\t\tif (directedMatch || (!directed && oppositeMatch))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getOpposites\n * \n * Returns all opposite vertices wrt terminal for the given edges, only\n * returning sources and/or targets as specified. The result is returned\n * as an array of <mxCells>.\n * \n * Parameters:\n * \n * edges - Array of <mxCells> that contain the edges to be examined.\n * terminal - <mxCell> that specifies the known end of the edges.\n * sources - Boolean that specifies if source terminals should be contained\n * in the result. Default is true.\n * targets - Boolean that specifies if target terminals should be contained\n * in the result. Default is true.\n */\nmxGraphModel.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\t\n\tvar terminals = [];\n\t\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar source = this.getTerminal(edges[i], true);\n\t\t\tvar target = this.getTerminal(edges[i], false);\n\t\t\t\n\t\t\t// Checks if the terminal is the source of\n\t\t\t// the edge and if the target should be\n\t\t\t// stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tterminals.push(target);\n\t\t\t}\n\t\t\t\n\t\t\t// Checks if the terminal is the taget of\n\t\t\t// the edge and if the source should be\n\t\t\t// stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tterminals.push(source);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn terminals;\n};\n\n/**\n * Function: getTopmostCells\n * \n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each <mxCell> that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose topmost ancestors should be returned.\n */\nmxGraphModel.prototype.getTopmostCells = function(cells)\n{\n\tvar dict = new mxDictionary();\n\tvar tmp = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tdict.put(cells[i], true);\n\t}\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tvar cell = cells[i];\n\t\tvar topmost = true;\n\t\tvar parent = this.getParent(cell);\n\t\t\n\t\twhile (parent != null)\n\t\t{\n\t\t\tif (dict.get(parent))\n\t\t\t{\n\t\t\t\ttopmost = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tparent = this.getParent(parent);\n\t\t}\n\t\t\n\t\tif (topmost)\n\t\t{\n\t\t\ttmp.push(cell);\n\t\t}\n\t}\n\t\n\treturn tmp;\n};\n\n/**\n * Function: isVertex\n * \n * Returns true if the given cell is a vertex.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible vertex.\n */\nmxGraphModel.prototype.isVertex = function(cell)\n{\n\treturn (cell != null) ? cell.isVertex() : false;\n};\n\n/**\n * Function: isEdge\n * \n * Returns true if the given cell is an edge.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible edge.\n */\nmxGraphModel.prototype.isEdge = function(cell)\n{\n\treturn (cell != null) ? cell.isEdge() : false;\n};\n\n/**\n * Function: isConnectable\n * \n * Returns true if the given <mxCell> is connectable. If <edgesConnectable>\n * is false, then this function returns false for all edges else it returns\n * the return value of <mxCell.isConnectable>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraphModel.prototype.isConnectable = function(cell)\n{\n\treturn (cell != null) ? cell.isConnectable() : false;\n};\n\n/**\n * Function: getValue\n * \n * Returns the user object of the given <mxCell> using <mxCell.getValue>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose user object should be returned.\n */\nmxGraphModel.prototype.getValue = function(cell)\n{\n\treturn (cell != null) ? cell.getValue() : null;\n};\n\n/**\n * Function: setValue\n * \n * Sets the user object of then given <mxCell> using <mxValueChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose user object should be changed.\n * value - Object that defines the new user object.\n */\nmxGraphModel.prototype.setValue = function(cell, value)\n{\n\tthis.execute(new mxValueChange(this, cell, value));\n\t\n\treturn value;\n};\n\n/**\n * Function: valueForCellChanged\n * \n * Inner callback to update the user object of the given <mxCell>\n * using <mxCell.valueChanged> and return the previous value,\n * that is, the return value of <mxCell.valueChanged>.\n * \n * To change a specific attribute in an XML node, the following code can be\n * used.\n * \n * (code)\n * graph.getModel().valueForCellChanged = function(cell, value)\n * {\n *   var previous = cell.value.getAttribute('label');\n *   cell.value.setAttribute('label', value);\n *   \n *   return previous;\n * };\n * (end) \n */\nmxGraphModel.prototype.valueForCellChanged = function(cell, value)\n{\n\treturn cell.valueChanged(value);\n};\n\n/**\n * Function: getGeometry\n * \n * Returns the <mxGeometry> of the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraphModel.prototype.getGeometry = function(cell)\n{\n\treturn (cell != null) ? cell.getGeometry() : null;\n};\n\n/**\n * Function: setGeometry\n * \n * Sets the <mxGeometry> of the given <mxCell>. The actual update\n * of the cell is carried out in <geometryForCellChanged>. The\n * <mxGeometryChange> action is used to encapsulate the change.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be changed.\n * geometry - <mxGeometry> that defines the new geometry.\n */\nmxGraphModel.prototype.setGeometry = function(cell, geometry)\n{\n\tif (geometry != this.getGeometry(cell))\n\t{\n\t\tthis.execute(new mxGeometryChange(this, cell, geometry));\n\t}\n\t\n\treturn geometry;\n};\n\n/**\n * Function: geometryForCellChanged\n * \n * Inner callback to update the <mxGeometry> of the given <mxCell> using\n * <mxCell.setGeometry> and return the previous <mxGeometry>.\n */\nmxGraphModel.prototype.geometryForCellChanged = function(cell, geometry)\n{\n\tvar previous = this.getGeometry(cell);\n\tcell.setGeometry(geometry);\n\t\n\treturn previous;\n};\n\n/**\n * Function: getStyle\n * \n * Returns the style of the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose style should be returned.\n */\nmxGraphModel.prototype.getStyle = function(cell)\n{\n\treturn (cell != null) ? cell.getStyle() : null;\n};\n\n/**\n * Function: setStyle\n * \n * Sets the style of the given <mxCell> using <mxStyleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose style should be changed.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.setStyle = function(cell, style)\n{\n\tif (style != this.getStyle(cell))\n\t{\n\t\tthis.execute(new mxStyleChange(this, cell, style));\n\t}\n\t\n\treturn style;\n};\n\n/**\n * Function: styleForCellChanged\n * \n * Inner callback to update the style of the given <mxCell>\n * using <mxCell.setStyle> and return the previous style.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.styleForCellChanged = function(cell, style)\n{\n\tvar previous = this.getStyle(cell);\n\tcell.setStyle(style);\n\t\n\treturn previous;\n};\n\n/**\n * Function: isCollapsed\n * \n * Returns true if the given <mxCell> is collapsed.\n *\n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraphModel.prototype.isCollapsed = function(cell)\n{\n\treturn (cell != null) ? cell.isCollapsed() : false;\n};\n\n/**\n * Function: setCollapsed\n * \n * Sets the collapsed state of the given <mxCell> using <mxCollapseChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be changed.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.setCollapsed = function(cell, collapsed)\n{\n\tif (collapsed != this.isCollapsed(cell))\n\t{\n\t\tthis.execute(new mxCollapseChange(this, cell, collapsed));\n\t}\n\t\n\treturn collapsed;\n};\n\t\n/**\n * Function: collapsedStateForCellChanged\n *\n * Inner callback to update the collapsed state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous collapsed state.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.collapsedStateForCellChanged = function(cell, collapsed)\n{\n\tvar previous = this.isCollapsed(cell);\n\tcell.setCollapsed(collapsed);\n\t\n\treturn previous;\n};\n\n/**\n * Function: isVisible\n * \n * Returns true if the given <mxCell> is visible.\n * \n * Parameters:\n * \n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraphModel.prototype.isVisible = function(cell)\n{\n\treturn (cell != null) ? cell.isVisible() : false;\n};\n\n/**\n * Function: setVisible\n * \n * Sets the visible state of the given <mxCell> using <mxVisibleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose visible state should be changed.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.setVisible = function(cell, visible)\n{\n\tif (visible != this.isVisible(cell))\n\t{\n\t\tthis.execute(new mxVisibleChange(this, cell, visible));\n\t}\n\t\n\treturn visible;\n};\n\t\n/**\n * Function: visibleStateForCellChanged\n *\n * Inner callback to update the visible state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous visible state.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.visibleStateForCellChanged = function(cell, visible)\n{\n\tvar previous = this.isVisible(cell);\n\tcell.setVisible(visible);\n\t\n\treturn previous;\n};\n\n/**\n * Function: execute\n * \n * Executes the given edit and fires events if required. The edit object\n * requires an execute function which is invoked. The edit is added to the\n * <currentEdit> between <beginUpdate> and <endUpdate> calls, so that\n * events will be fired if this execute is an individual transaction, that\n * is, if no previous <beginUpdate> calls have been made without calling\n * <endUpdate>. This implementation fires an <execute> event before\n * executing the given change.\n * \n * Parameters:\n * \n * change - Object that described the change.\n */\nmxGraphModel.prototype.execute = function(change)\n{\n\tchange.execute();\n\tthis.beginUpdate();\n\tthis.currentEdit.add(change);\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTE, 'change', change));\n\t// New global executed event\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\tthis.endUpdate();\n};\n\n/**\n * Function: beginUpdate\n * \n * Increments the <updateLevel> by one. The event notification\n * is queued until <updateLevel> reaches 0 by use of\n * <endUpdate>.\n *\n * All changes on <mxGraphModel> are transactional,\n * that is, they are executed in a single undoable change\n * on the model (without transaction isolation).\n * Therefore, if you want to combine any\n * number of changes into a single undoable change,\n * you should group any two or more API calls that\n * modify the graph model between <beginUpdate>\n * and <endUpdate> calls as shown here:\n * \n * (code)\n * var model = graph.getModel();\n * var parent = graph.getDefaultParent();\n * var index = model.getChildCount(parent);\n * model.beginUpdate();\n * try\n * {\n *   model.add(parent, v1, index);\n *   model.add(parent, v2, index+1);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n * \n * Of course there is a shortcut for appending a\n * sequence of cells into the default parent:\n * \n * (code)\n * graph.addCells([v1, v2]).\n * (end)\n */\nmxGraphModel.prototype.beginUpdate = function()\n{\n\tthis.updateLevel++;\n\tthis.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));\n\t\n\tif (this.updateLevel == 1)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t}\n};\n\n/**\n * Function: endUpdate\n * \n * Decrements the <updateLevel> by one and fires an <undo>\n * event if the <updateLevel> reaches 0. This function\n * indirectly fires a <change> event by invoking the notify\n * function on the <currentEdit> und then creates a new\n * <currentEdit> using <createUndoableEdit>.\n *\n * The <undo> event is fired only once per edit, whereas\n * the <change> event is fired whenever the notify\n * function is invoked, that is, on undo and redo of\n * the edit.\n */\nmxGraphModel.prototype.endUpdate = function()\n{\n\tthis.updateLevel--;\n\t\n\tif (this.updateLevel == 0)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\t\n\tif (!this.endingUpdate)\n\t{\n\t\tthis.endingUpdate = this.updateLevel == 0;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_UPDATE, 'edit', this.currentEdit));\n\n\t\ttry\n\t\t{\t\t\n\t\t\tif (this.endingUpdate && !this.currentEdit.isEmpty())\n\t\t\t{\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, 'edit', this.currentEdit));\n\t\t\t\tvar tmp = this.currentEdit;\n\t\t\t\tthis.currentEdit = this.createUndoableEdit();\n\t\t\t\ttmp.notify();\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', tmp));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.endingUpdate = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: createUndoableEdit\n * \n * Creates a new <mxUndoableEdit> that implements the\n * notify function to fire a <change> and <notify> event\n * through the <mxUndoableEdit>'s source.\n * \n * Parameters:\n * \n * significant - Optional boolean that specifies if the edit to be created is\n * significant. Default is true.\n */\nmxGraphModel.prototype.createUndoableEdit = function(significant)\n{\n\tvar edit = new mxUndoableEdit(this, (significant != null) ? significant : true);\n\t\n\tedit.notify = function()\n\t{\n\t\t// LATER: Remove changes property (deprecated)\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t};\n\t\n\treturn edit;\n};\n\n/**\n * Function: mergeChildren\n * \n * Merges the children of the given cell into the given target cell inside\n * this model. All cells are cloned unless there is a corresponding cell in\n * the model with the same id, in which case the source cell is ignored and\n * all edges are connected to the corresponding cell in this model. Edges\n * are considered to have no identity and are always cloned unless the\n * cloneAllEdges flag is set to false, in which case edges with the same\n * id in the target model are reconnected to reflect the terminals of the\n * source edges.\n */\nmxGraphModel.prototype.mergeChildren = function(from, to, cloneAllEdges)\n{\n\tcloneAllEdges = (cloneAllEdges != null) ? cloneAllEdges : true;\n\t\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar mapping = new Object();\n\t\tthis.mergeChildrenImpl(from, to, cloneAllEdges, mapping);\n\t\t\n\t\t// Post-processes all edges in the mapping and\n\t\t// reconnects the terminals to the corresponding\n\t\t// cells in the target model\n\t\tfor (var key in mapping)\n\t\t{\n\t\t\tvar cell = mapping[key];\n\t\t\tvar terminal = this.getTerminal(cell, true);\n\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, true);\n\t\t\t}\n\t\t\t\n\t\t\tterminal = this.getTerminal(cell, false);\n\t\t\t\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, false);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: mergeChildren\n * \n * Clones the children of the source cell into the given target cell in\n * this model and adds an entry to the mapping that maps from the source\n * cell to the target cell with the same id or the clone of the source cell\n * that was inserted into this model.\n */\nmxGraphModel.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar childCount = from.getChildCount();\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar cell = from.getChildAt(i);\n\t\t\t\n\t\t\tif (typeof(cell.getId) == 'function')\n\t\t\t{\n\t\t\t\tvar id = cell.getId();\n\t\t\t\tvar target = (id != null && (!this.isEdge(cell) || !cloneAllEdges)) ?\n\t\t\t\t\t\tthis.getCell(id) : null;\n\t\t\t\t\n\t\t\t\t// Clones and adds the child if no cell exists for the id\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar clone = cell.clone();\n\t\t\t\t\tclone.setId(id);\n\t\t\t\t\t\n\t\t\t\t\t// Sets the terminals from the original cell to the clone\n\t\t\t\t\t// because the lookup uses strings not cells in JS\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(true), true);\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(false), false);\n\t\t\t\t\t\n\t\t\t\t\t// Do *NOT* use model.add as this will move the edge away\n\t\t\t\t\t// from the parent in updateEdgeParent if maintainEdgeParent\n\t\t\t\t\t// is enabled in the target model\n\t\t\t\t\ttarget = to.insert(clone);\n\t\t\t\t\tthis.cellAdded(target);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Stores the mapping for later reconnecting edges\n\t\t\t\tmapping[mxCellPath.create(cell)] = target;\n\t\t\t\t\n\t\t\t\t// Recurses\n\t\t\t\tthis.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: getParents\n * \n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n * \n * Parameters:\n * \n * cells - Array of cells whose parents should be returned.\n */\nmxGraphModel.prototype.getParents = function(cells)\n{\n\tvar parents = [];\n\t\n\tif (cells != null)\n\t{\n\t\tvar dict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar parent = this.getParent(cells[i]);\n\t\t\t\n\t\t\tif (parent != null && !dict.get(parent))\n\t\t\t{\n\t\t\t\tdict.put(parent, true);\n\t\t\t\tparents.push(parent);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn parents;\n};\n\n//\n// Cell Cloning\n//\n\n/**\n * Function: cloneCell\n * \n * Returns a deep clone of the given <mxCell> (including\n * the children) which is created using <cloneCells>.\n *\n * Parameters:\n * \n * cell - <mxCell> to be cloned.\n */\nmxGraphModel.prototype.cloneCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\treturn this.cloneCells([cell], true)[0];\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: cloneCells\n * \n * Returns an array of clones for the given array of <mxCells>.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the passed in array.\n *\n * Parameters:\n * \n * cells - Array of <mxCell> to be cloned.\n * includeChildren - Boolean indicating if the cells should be cloned\n * with all descendants.\n * mapping - Optional mapping for existing clones.\n */\nmxGraphModel.prototype.cloneCells = function(cells, includeChildren, mapping)\n{\n\tmapping = (mapping != null) ? mapping : new Object();\n\tvar clones = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (cells[i] != null)\n\t\t{\n\t\t\tclones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones.push(null);\n\t\t}\n\t}\n\t\n\tfor (var i = 0; i < clones.length; i++)\n\t{\n\t\tif (clones[i] != null)\n\t\t{\n\t\t\tthis.restoreClone(clones[i], cells[i], mapping);\n\t\t}\n\t}\n\t\n\treturn clones;\n};\n\t\t\t\n/**\n * Function: cloneCellImpl\n * \n * Inner helper method for cloning cells recursively.\n */\nmxGraphModel.prototype.cloneCellImpl = function(cell, mapping, includeChildren)\n{\n\tvar ident = mxObjectIdentity.get(cell);\n\tvar clone = mapping[ident];\n\t\n\tif (clone == null)\n\t{\n\t\tclone = this.cellCloned(cell);\n\t\tmapping[ident] = clone;\n\n\t\tif (includeChildren)\n\t\t{\n\t\t\tvar childCount = this.getChildCount(cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cloneChild = this.cloneCellImpl(\n\t\t\t\t\tthis.getChildAt(cell, i), mapping, true);\n\t\t\t\tclone.insert(cloneChild);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn clone;\n};\n\n/**\n * Function: cellCloned\n * \n * Hook for cloning the cell. This returns cell.clone() or\n * any possible exceptions.\n */\nmxGraphModel.prototype.cellCloned = function(cell)\n{\n\treturn cell.clone();\n};\n\n/**\n * Function: restoreClone\n * \n * Inner helper method for restoring the connections in\n * a network of cloned cells.\n */\nmxGraphModel.prototype.restoreClone = function(clone, cell, mapping)\n{\n\tvar source = this.getTerminal(cell, true);\n\t\n\tif (source != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(source)];\n\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\ttmp.insertEdge(clone, true);\n\t\t}\n\t}\n\t\n\tvar target = this.getTerminal(cell, false);\n\t\n\tif (target != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(target)];\n\t\t\n\t\tif (tmp != null)\n\t\t{\t\n\t\t\ttmp.insertEdge(clone, false);\n\t\t}\n\t}\n\t\n\tvar childCount = this.getChildCount(clone);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.restoreClone(this.getChildAt(clone, i),\n\t\t\tthis.getChildAt(cell, i), mapping);\n\t}\n};\n\n//\n// Atomic changes\n//\n\n/**\n * Class: mxRootChange\n * \n * Action to change the root in a model.\n *\n * Constructor: mxRootChange\n * \n * Constructs a change of the root in the\n * specified model.\n */\nfunction mxRootChange(model, root)\n{\n\tthis.model = model;\n\tthis.root = root;\n\tthis.previous = root;\n};\n\n/**\n * Function: execute\n * \n * Carries out a change of the root using\n * <mxGraphModel.rootChanged>.\n */\nmxRootChange.prototype.execute = function()\n{\n\tthis.root = this.previous;\n\tthis.previous = this.model.rootChanged(this.previous);\n};\n\n/**\n * Class: mxChildChange\n * \n * Action to add or remove a child in a model.\n *\n * Constructor: mxChildChange\n * \n * Constructs a change of a child in the\n * specified model.\n */\nfunction mxChildChange(model, parent, child, index)\n{\n\tthis.model = model;\n\tthis.parent = parent;\n\tthis.previous = parent;\n\tthis.child = child;\n\tthis.index = index;\n\tthis.previousIndex = index;\n};\n\n/**\n * Function: execute\n * \n * Changes the parent of <child> using\n * <mxGraphModel.parentForCellChanged> and\n * removes or restores the cell's\n * connections.\n */\nmxChildChange.prototype.execute = function()\n{\n\tif (this.child != null)\n\t{\n\t\tvar tmp = this.model.getParent(this.child);\n\t\tvar tmp2 = (tmp != null) ? tmp.getIndex(this.child) : 0;\n\t\t\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.connect(this.child, false);\n\t\t}\n\t\t\n\t\ttmp = this.model.parentForCellChanged(\n\t\t\tthis.child, this.previous, this.previousIndex);\n\t\t\t\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.connect(this.child, true);\n\t\t}\n\t\t\n\t\tthis.parent = this.previous;\n\t\tthis.previous = tmp;\n\t\tthis.index = this.previousIndex;\n\t\tthis.previousIndex = tmp2;\n\t}\n};\n\n/**\n * Function: disconnect\n * \n * Disconnects the given cell recursively from its\n * terminals and stores the previous terminal in the\n * cell's terminals.\n */\nmxChildChange.prototype.connect = function(cell, isConnect)\n{\n\tisConnect = (isConnect != null) ? isConnect : true;\n\t\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\t\n\tif (source != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, source, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, true);\n\t\t}\n\t}\n\t\n\tif (target != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, target, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, false);\n\t\t}\n\t}\n\t\n\tcell.setTerminal(source, true);\n\tcell.setTerminal(target, false);\n\t\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i=0; i<childCount; i++)\n\t{\n\t\tthis.connect(this.model.getChildAt(cell, i), isConnect);\n\t}\n};\n\n/**\n * Class: mxTerminalChange\n * \n * Action to change a terminal in a model.\n *\n * Constructor: mxTerminalChange\n * \n * Constructs a change of a terminal in the \n * specified model.\n */\nfunction mxTerminalChange(model, cell, terminal, source)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.terminal = terminal;\n\tthis.previous = terminal;\n\tthis.source = source;\n};\n\n/**\n * Function: execute\n * \n * Changes the terminal of <cell> to <previous> using\n * <mxGraphModel.terminalForCellChanged>.\n */\nmxTerminalChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.terminal = this.previous;\n\t\tthis.previous = this.model.terminalForCellChanged(\n\t\t\tthis.cell, this.previous, this.source);\n\t}\n};\n\n/**\n * Class: mxValueChange\n * \n * Action to change a user object in a model.\n *\n * Constructor: mxValueChange\n * \n * Constructs a change of a user object in the \n * specified model.\n */\nfunction mxValueChange(model, cell, value)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n * \n * Changes the value of <cell> to <previous> using\n * <mxGraphModel.valueForCellChanged>.\n */\nmxValueChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.value = this.previous;\n\t\tthis.previous = this.model.valueForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxStyleChange\n * \n * Action to change a cell's style in a model.\n *\n * Constructor: mxStyleChange\n * \n * Constructs a change of a style in the\n * specified model.\n */\nfunction mxStyleChange(model, cell, style)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.style = style;\n\tthis.previous = style;\n};\n\n/**\n * Function: execute\n * \n * Changes the style of <cell> to <previous> using\n * <mxGraphModel.styleForCellChanged>.\n */\nmxStyleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.style = this.previous;\n\t\tthis.previous = this.model.styleForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxGeometryChange\n * \n * Action to change a cell's geometry in a model.\n *\n * Constructor: mxGeometryChange\n * \n * Constructs a change of a geometry in the\n * specified model.\n */\nfunction mxGeometryChange(model, cell, geometry)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.geometry = geometry;\n\tthis.previous = geometry;\n};\n\n/**\n * Function: execute\n * \n * Changes the geometry of <cell> ro <previous> using\n * <mxGraphModel.geometryForCellChanged>.\n */\nmxGeometryChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.geometry = this.previous;\n\t\tthis.previous = this.model.geometryForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCollapseChange\n * \n * Action to change a cell's collapsed state in a model.\n *\n * Constructor: mxCollapseChange\n * \n * Constructs a change of a collapsed state in the\n * specified model.\n */\nfunction mxCollapseChange(model, cell, collapsed)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.collapsed = collapsed;\n\tthis.previous = collapsed;\n};\n\n/**\n * Function: execute\n * \n * Changes the collapsed state of <cell> to <previous> using\n * <mxGraphModel.collapsedStateForCellChanged>.\n */\nmxCollapseChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.collapsed = this.previous;\n\t\tthis.previous = this.model.collapsedStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxVisibleChange\n * \n * Action to change a cell's visible state in a model.\n *\n * Constructor: mxVisibleChange\n * \n * Constructs a change of a visible state in the\n * specified model.\n */\nfunction mxVisibleChange(model, cell, visible)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.visible = visible;\n\tthis.previous = visible;\n};\n\n/**\n * Function: execute\n * \n * Changes the visible state of <cell> to <previous> using\n * <mxGraphModel.visibleStateForCellChanged>.\n */\nmxVisibleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.visible = this.previous;\n\t\tthis.previous = this.model.visibleStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCellAttributeChange\n * \n * Action to change the attribute of a cell's user object.\n * There is no method on the graph model that uses this\n * action. To use the action, you can use the code shown\n * in the example below.\n * \n * Example:\n * \n * To change the attributeName in the cell's user object\n * to attributeValue, use the following code:\n * \n * (code)\n * model.beginUpdate();\n * try\n * {\n *   var edit = new mxCellAttributeChange(\n *     cell, attributeName, attributeValue);\n *   model.execute(edit);\n * }\n * finally\n * {\n *   model.endUpdate();\n * } \n * (end)\n *\n * Constructor: mxCellAttributeChange\n * \n * Constructs a change of a attribute of the DOM node\n * stored as the value of the given <mxCell>.\n */\nfunction mxCellAttributeChange(cell, attribute, value)\n{\n\tthis.cell = cell;\n\tthis.attribute = attribute;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n * \n * Changes the attribute of the cell's user object by\n * using <mxCell.setAttribute>.\n */\nmxCellAttributeChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tvar tmp = this.cell.getAttribute(this.attribute);\n\t\t\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.cell.value.removeAttribute(this.attribute);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.cell.setAttribute(this.attribute, this.previous);\n\t\t}\n\t\t\n\t\tthis.previous = tmp;\n\t}\n};\n\n__mxOutput.mxGraphModel = typeof mxGraphModel !== 'undefined' ? mxGraphModel : undefined;\n"]}