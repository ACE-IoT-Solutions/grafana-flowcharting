{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/view/mxCellOverlay.js"],"names":["mxCellOverlay","image","tooltip","align","verticalAlign","offset","cursor","mxPoint","prototype","mxEventSource","constructor","mxConstants","ALIGN_RIGHT","ALIGN_BOTTOM","defaultOverlap","getBounds","state","isEdge","view","graph","getModel","cell","s","scale","pt","w","width","h","height","pts","absolutePoints","length","Math","floor","idx","p0","p1","x","y","ALIGN_LEFT","ALIGN_CENTER","ALIGN_TOP","ALIGN_MIDDLE","mxRectangle","round","toString","__mxOutput","undefined"],"mappings":"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","file":"mxCellOverlay.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellOverlay\n *\n * Extends <mxEventSource> to implement a graph overlay, represented by an icon\n * and a tooltip. Overlays can handle and fire <click> events and are added to\n * the graph using <mxGraph.addCellOverlay>, and removed using\n * <mxGraph.removeCellOverlay>, or <mxGraph.removeCellOverlays> to remove all overlays.\n * The <mxGraph.getCellOverlays> function returns the array of overlays for a given\n * cell in a graph. If multiple overlays exist for the same cell, then\n * <getBounds> should be overridden in at least one of the overlays.\n * \n * Overlays appear on top of all cells in a special layer. If this is not\n * desirable, then the image must be rendered as part of the shape or label of\n * the cell instead.\n *\n * Example:\n * \n * The following adds a new overlays for a given vertex and selects the cell\n * if the overlay is clicked.\n *\n * (code)\n * var overlay = new mxCellOverlay(img, html);\n * graph.addCellOverlay(vertex, overlay);\n * overlay.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   graph.setSelectionCell(cell);\n * });\n * (end)\n * \n * For cell overlays to be printed use <mxPrintPreview.printOverlays>.\n *\n * Event: mxEvent.CLICK\n *\n * Fires when the user clicks on the overlay. The <code>event</code> property\n * contains the corresponding mouse event and the <code>cell</code> property\n * contains the cell. For touch devices this is fired if the element receives\n * a touchend event.\n * \n * Constructor: mxCellOverlay\n *\n * Constructs a new overlay using the given image and tooltip.\n * \n * Parameters:\n * \n * image - <mxImage> that represents the icon to be displayed.\n * tooltip - Optional string that specifies the tooltip.\n * align - Optional horizontal alignment for the overlay. Possible\n * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\n * (default).\n * verticalAlign - Vertical alignment for the overlay. Possible\n * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\n * (default).\n */\nfunction mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor)\n{\n\tthis.image = image;\n\tthis.tooltip = tooltip;\n\tthis.align = (align != null) ? align : this.align;\n\tthis.verticalAlign = (verticalAlign != null) ? verticalAlign : this.verticalAlign;\n\tthis.offset = (offset != null) ? offset : new mxPoint();\n\tthis.cursor = (cursor != null) ? cursor : 'help';\n};\n\n/**\n * Extends mxEventSource.\n */\nmxCellOverlay.prototype = new mxEventSource();\nmxCellOverlay.prototype.constructor = mxCellOverlay;\n\n/**\n * Variable: image\n *\n * Holds the <mxImage> to be used as the icon.\n */\nmxCellOverlay.prototype.image = null;\n\n/**\n * Variable: tooltip\n * \n * Holds the optional string to be used as the tooltip.\n */\nmxCellOverlay.prototype.tooltip = null;\n\n/**\n * Variable: align\n * \n * Holds the horizontal alignment for the overlay. Default is\n * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;\n\n/**\n * Variable: verticalAlign\n * \n * Holds the vertical alignment for the overlay. Default is\n * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;\n\n/**\n * Variable: offset\n * \n * Holds the offset as an <mxPoint>. The offset will be scaled according to the\n * current scale.\n */\nmxCellOverlay.prototype.offset = null;\n\n/**\n * Variable: cursor\n * \n * Holds the cursor for the overlay. Default is 'help'.\n */\nmxCellOverlay.prototype.cursor = null;\n\n/**\n * Variable: defaultOverlap\n * \n * Defines the overlapping for the overlay, that is, the proportional distance\n * from the origin to the point defined by the alignment. Default is 0.5.\n */\nmxCellOverlay.prototype.defaultOverlap = 0.5;\n\n/**\n * Function: getBounds\n * \n * Returns the bounds of the overlay for the given <mxCellState> as an\n * <mxRectangle>. This should be overridden when using multiple overlays\n * per cell so that the overlays do not overlap.\n * \n * The following example will place the overlay along an edge (where\n * x=[-1..1] from the start to the end of the edge and y is the\n * orthogonal offset in px).\n * \n * (code)\n * overlay.getBounds = function(state)\n * {\n *   var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);\n *   \n *   if (state.view.graph.getModel().isEdge(state.cell))\n *   {\n *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\n *     \n *     bounds.x = pt.x - bounds.width / 2;\n *     bounds.y = pt.y - bounds.height / 2;\n *   }\n *   \n *   return bounds;\n * };\n * (end)\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the current state of the\n * associated cell.\n */\nmxCellOverlay.prototype.getBounds = function(state)\n{\n\tvar isEdge = state.view.graph.getModel().isEdge(state.cell);\n\tvar s = state.view.scale;\n\tvar pt = null;\n\n\tvar w = this.image.width;\n\tvar h = this.image.height;\n\t\n\tif (isEdge)\n\t{\n\t\tvar pts = state.absolutePoints;\n\t\t\n\t\tif (pts.length % 2 == 1)\n\t\t{\n\t\t\tpt = pts[Math.floor(pts.length / 2)];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar idx = pts.length / 2;\n\t\t\tvar p0 = pts[idx-1];\n\t\t\tvar p1 = pts[idx];\n\t\t\tpt = new mxPoint(p0.x + (p1.x - p0.x) / 2,\n\t\t\t\tp0.y + (p1.y - p0.y) / 2);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpt = new mxPoint();\n\t\t\n\t\tif (this.align == mxConstants.ALIGN_LEFT)\n\t\t{\n\t\t\tpt.x = state.x;\n\t\t}\n\t\telse if (this.align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tpt.x = state.x + state.width / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.x = state.x + state.width;\n\t\t}\n\t\t\n\t\tif (this.verticalAlign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tpt.y = state.y;\n\t\t}\n\t\telse if (this.verticalAlign == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tpt.y = state.y + state.height / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.y = state.y + state.height;\n\t\t}\n\t}\n\n\treturn new mxRectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s),\n\t\tMath.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);\n};\n\n/**\n * Function: toString\n * \n * Returns the textual representation of the overlay to be used as the\n * tooltip. This implementation returns <tooltip>.\n */\nmxCellOverlay.prototype.toString = function()\n{\n\treturn this.tooltip;\n};\n\n__mxOutput.mxCellOverlay = typeof mxCellOverlay !== 'undefined' ? mxCellOverlay : undefined;\n"]}