{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/view/mxGraph.js"],"names":["mxGraph","container","model","renderHint","stylesheet","mouseListeners","mxClient","IS_SVG","dialect","mxConstants","DIALECT_SVG","RENDERING_HINT_EXACT","IS_VML","DIALECT_VML","RENDERING_HINT_FASTEST","DIALECT_STRICTHTML","RENDERING_HINT_FASTER","DIALECT_PREFERHTML","DIALECT_MIXEDHTML","mxGraphModel","multiplicities","imageBundles","cellRenderer","createCellRenderer","setSelectionModel","createSelectionModel","setStylesheet","createStylesheet","view","createGraphView","graphModelChangeListener","mxUtils","bind","sender","evt","graphModelChanged","getProperty","changes","addListener","mxEvent","CHANGE","createHandlers","init","revalidate","mxLoadResources","mxResources","add","basePath","defaultBundles","push","prototype","mxEventSource","constructor","EMPTY_ARRAY","isMouseDown","selectionModel","cellEditor","gridSize","gridEnabled","portsEnabled","nativeDblClickEnabled","doubleTapEnabled","doubleTapTimeout","doubleTapTolerance","lastTouchY","lastTouchTime","tapAndHoldEnabled","tapAndHoldDelay","tapAndHoldInProgress","tapAndHoldValid","initialTouchX","initialTouchY","tolerance","defaultOverlap","defaultParent","alternateEdgeStyle","backgroundImage","pageVisible","pageBreaksVisible","pageBreakColor","pageBreakDashed","minPageBreakDist","preferPageSize","pageFormat","PAGE_FORMAT_A4_PORTRAIT","pageScale","enabled","escapeEnabled","invokesStopCellEditing","enterStopsCellEditing","useScrollbarsForPanning","exportEnabled","importEnabled","cellsLocked","cellsCloneable","foldingEnabled","cellsEditable","cellsDeletable","cellsMovable","edgeLabelsMovable","vertexLabelsMovable","dropEnabled","splitEnabled","cellsResizable","cellsBendable","cellsSelectable","cellsDisconnectable","autoSizeCells","autoSizeCellsOnAdd","autoScroll","ignoreScrollbars","translateToScrollPosition","timerAutoScroll","allowAutoPanning","autoExtend","maximumGraphBounds","minimumGraphSize","minimumContainerSize","maximumContainerSize","resizeContainer","border","keepEdgesInForeground","keepEdgesInBackground","allowNegativeCoordinates","constrainChildren","constrainRelativeChildren","extendParents","extendParentsOnAdd","extendParentsOnMove","recursiveResize","collapseToPreferredSize","zoomFactor","keepSelectionVisibleOnZoom","centerZoom","resetViewOnRootChange","resetEdgesOnResize","resetEdgesOnMove","resetEdgesOnConnect","allowLoops","defaultLoopStyle","mxEdgeStyle","Loop","multigraph","connectableEdges","allowDanglingEdges","cloneInvalidEdges","disconnectOnMove","labelsVisible","htmlLabels","swimlaneSelectionEnabled","swimlaneNesting","swimlaneIndicatorColorAttribute","STYLE_FILLCOLOR","minFitScale","maxFitScale","panDx","panDy","collapsedImage","mxImage","imageBasePath","expandedImage","warningImage","IS_MAC","alreadyConnectedResource","language","containsValidationErrorsResource","collapseExpandResource","createCellEditor","sizeDidChange","tooltipHandler","hide","IS_IE","window","destroy","isEditing","isShiftDown","document","documentMode","insertAdjacentHTML","VML_PREFIX","createTooltipHandler","setEnabled","selectionCellsHandler","createSelectionCellsHandler","connectionHandler","createConnectionHandler","graphHandler","createGraphHandler","panningHandler","createPanningHandler","panningEnabled","popupMenuHandler","createPopupMenuHandler","mxTooltipHandler","mxSelectionCellsHandler","mxConnectionHandler","mxGraphHandler","mxPanningHandler","mxPopupMenuHandler","mxGraphSelectionModel","mxStylesheet","mxGraphView","mxCellRenderer","mxCellEditor","getModel","getView","getStylesheet","getSelectionModel","getSelectionCellsForChanges","dict","mxDictionary","cells","addCell","cell","get","contains","isEdge","isVertex","put","childCount","getChildCount","i","getChildAt","length","change","mxRootChange","mxChildChange","child","mxCell","processChange","removeSelectionCells","getRemovedCellsForChanges","validate","result","previous","parent","concat","getDescendants","mxVisibleChange","clearSelection","setDefaultParent","removeStateForCell","scale","translate","x","y","fireEvent","mxEventObject","ROOT","newParent","getParent","invalidate","isCellCollapsed","currentRoot","home","mxTerminalChange","mxGeometryChange","geometry","equals","mxValueChange","mxStyleChange","state","getState","style","removeState","addCellOverlay","overlay","overlays","redraw","ADD_OVERLAY","getCellOverlays","removeCellOverlay","removeCellOverlays","index","indexOf","splice","REMOVE_OVERLAY","clearCellOverlays","getRoot","setCellWarning","warning","img","isSelect","mxCellOverlay","CLICK","isEnabled","setSelectionCell","startEditing","startEditingAtCell","isMultiTouchEvent","getSelectionCell","isCellEditable","START_EDITING","EDITING_STARTED","getEditingValue","convertValueToString","stopEditing","cancel","EDITING_STOPPED","labelChanged","value","beginUpdate","old","cellLabelChanged","isAutoSizeCell","LABEL_CHANGED","endUpdate","autoSize","setValue","cellSizeUpdated","escape","ESCAPE","click","me","getEvent","getCell","mxe","isConsumed","consume","isTransparentClickEvent","active","tmp","getCellAt","graphX","graphY","selected","isCellSelected","selectCellForEvent","swimlane","isSwimlaneSelectionEnabled","getSwimlaneAt","getGraphX","getGraphY","isToggleEvent","dblClick","DOUBLE_CLICK","tapAndHold","TAP_AND_HOLD","panningTrigger","marker","currentColor","validColor","markedState","mark","first","mxPoint","edgeState","createEdgeState","START","scrollPointToVisible","extend","hasScrollbars","c","scrollLeft","scrollTop","clientWidth","clientHeight","dx","root","getDrawPane","ownerSVGElement","width","scrollWidth","Math","max","canvas","getCanvas","dy","height","scrollHeight","isActive","panningManager","createPanningManager","panTo","mxPanningManager","getBorderSizes","css","getCurrentStyle","mxRectangle","parseCssNumber","paddingLeft","borderLeftStyle","borderLeftWidth","paddingTop","borderTopStyle","borderTopWidth","paddingRight","borderRightStyle","borderRightWidth","paddingBottom","borderBottomStyle","borderBottomWidth","getPreferredPageSize","bounds","tr","fmt","ps","page","ceil","hCount","vCount","fit","keepOrigin","margin","ignoreWidth","ignoreHeight","maxHeight","getBorder","cssBorder","w1","offsetWidth","h1","offsetHeight","getGraphBounds","clone","s","w2","h2","b","s2","min","x0","floor","y0","scaleAndTranslate","setScale","b2","doResizeContainer","size","minWidth","minHeight","IS_QUIRKS","updateHtmlCanvasSize","updatePageBreaks","SIZE","visible","gb","fromRectangle","horizontalCount","verticalCount","right","bottom","horizontalPageBreaks","verticalPageBreaks","drawPageBreaks","breaks","count","pts","round","points","pageBreak","mxPolyline","pointerEvents","isDashed","backgroundPane","getCellStyle","stylename","getStyle","getDefaultEdgeStyle","getDefaultVertexStyle","postProcessCellStyle","key","STYLE_IMAGE","image","getImageFromBundles","substring","encodeURIComponent","comma","setCellStyle","getSelectionCells","setStyle","toggleCellStyle","defaultValue","toggleCellStyles","getValue","setCellStyles","toggleCellStyleFlags","flag","setCellStyleFlags","current","parseInt","alignCells","align","param","ALIGN_CENTER","ALIGN_RIGHT","ALIGN_TOP","ALIGN_MIDDLE","ALIGN_BOTTOM","geo","getCellGeometry","resizeCell","ALIGN_CELLS","flipEdge","edge","resetEdge","FLIP_EDGE","addImageBundle","bundle","removeImageBundle","getImage","orderCells","back","sortCells","cellsOrdered","ORDER_CELLS","CELLS_ORDERED","groupCells","group","getCellsForGroup","createGroupCell","getBoundsForGroup","setGeometry","mxGeometry","cellsAdded","cellsMoved","cellsResized","GROUP_CELLS","children","getBoundingBoxFromGeometry","isSwimlane","getStartSize","setVertex","setConnectable","ungroupCells","getChildren","slice","removeCellsAfterUngroup","UNGROUP_CELLS","cellsRemoved","addAllEdges","removeCellsFromParent","getDefaultParent","REMOVE_CELLS_FROM_PARENT","updateGroupBounds","moveGroup","topBorder","rightBorder","bottomBorder","leftBorder","getChildCells","left","top","moveCells","getBoundingBox","bbox","cloneCell","allowInvalidEdges","mapping","keepPosition","cloneCells","clones","trans","getEdgeValidationError","getTerminal","g","getGeometry","pstate","origin","absolutePoints","src","setTerminalPoint","trg","n","j","insertVertex","id","relative","vertex","createVertex","setId","insertEdge","source","target","createEdge","addEdge","setEdge","addCells","ADD_CELLS","absolute","constrain","parentState","o1","zero","oldState","o2","isAllowNegativeCoordinates","autoSizeCell","isExtendParentsOnAdd","isExtendParent","extendParent","constrainChild","cellConnected","CELLS_ADDED","recurse","updateCellSize","removeCells","includeEdges","getDeletableCells","REMOVE_CELLS","edges","getAllEdges","disconnectTerminal","getVisibleTerminal","connected","setTerminal","remove","CELLS_REMOVED","splitEdge","newEdge","t","idx","findNearestSegment","SPLIT_EDGE","toggleCells","show","cellsToggled","TOGGLE_CELLS","setVisible","foldCells","collapse","checkFoldable","getFoldableCells","cellsFolded","FOLD_CELLS","isCellFoldable","setCollapsed","swapBounds","CELLS_FOLDED","willCollapse","updateAlternateBounds","swap","alternateBounds","getPreferredSizeForCell","startSize","STYLE_STARTSIZE","alpha","toRadians","STYLE_ROTATION","getCenterX","getCenterY","cos","sin","dx2","dy2","allCells","removeDuplicates","edgeCount","getEdgeCount","getEdgeAt","ignoreChildren","UPDATE_CELL_SIZE","collapsed","cellStyle","STYLE_HORIZONTAL","getBounds","createState","fontSize","STYLE_FONTSIZE","DEFAULT_FONTSIZE","STYLE_SHAPE","SHAPE_LABEL","STYLE_VERTICAL_ALIGN","parseFloat","STYLE_IMAGE_WIDTH","mxLabel","imageSize","STYLE_ALIGN","STYLE_IMAGE_HEIGHT","STYLE_SPACING","STYLE_SPACING_LEFT","STYLE_SPACING_RIGHT","STYLE_SPACING_TOP","STYLE_SPACING_BOTTOM","getFoldingImage","getLabelValue","isHtmlLabel","htmlEntities","replace","getSizeForString","STYLE_FONTFAMILY","snap","gs2","resizeCells","isRecursiveResize","RESIZE_CELLS","cellResized","resetEdges","CELLS_RESIZED","ignoreRelative","offset","resizeChildCells","constrainChildCells","newGeo","scaleCell","w","h","STYLE_ASPECT","STYLE_RESIZE_WIDTH","STYLE_RESIZE_HEIGHT","isCellMovable","isCellResizable","p","importCells","getTopmostCells","isSelected","checked","isCloneInvalidEdges","setAllowNegativeCoordinates","isDisconnectOnMove","isAllowDanglingEdges","isExtendParentsOnMove","MOVE_CELLS","disconnect","disconnectGraph","translateCell","CELLS_MOVED","angle","rad","pt","getRotatedPoint","getCellContainmentArea","dir","STYLE_DIRECTION","DIRECTION_EAST","flipH","STYLE_FLIPH","flipV","STYLE_FLIPV","DIRECTION_SOUTH","DIRECTION_NORTH","DIRECTION_WEST","getMaximumGraphBounds","sizeFirst","isConstrainRelativeChildren","pgeo","off","isConstrainChild","overlap","getOverlap","intersect","desc","isCellVisible","getEdges","getOutlineConstraint","point","terminalState","shape","getPerimeterBounds","direction","getShapeRotation","ct","sx","sy","stencil","mxConnectionConstraint","getAllConnectionConstraints","terminal","constraints","getConnectionConstraint","STYLE_EXIT_X","STYLE_ENTRY_X","STYLE_EXIT_Y","STYLE_ENTRY_Y","perimeter","STYLE_EXIT_PERIMETER","STYLE_ENTRY_PERIMETER","setConnectionConstraint","constraint","getConnectionPoint","cx","r1","STYLE_ANCHOR_POINT_DIRECTION","rotate90","r2","getPerimeterPoint","connectCell","CONNECT_CELL","isPortsEnabled","isPort","getId","getTerminalForPort","STYLE_SOURCE_PORT","STYLE_TARGET_PORT","CELL_CONNECTED","isCellDisconnectable","getCurrentRoot","getTranslateForRoot","getChildOffsetForCell","enterGroup","isValidRoot","setCurrentRoot","exitGroup","next","getCellBounds","includeDescendants","addPoint","getTerminalPoint","refresh","clear","REFRESH","panGraph","setAttribute","removeAttribute","shiftPreview1","firstChild","nextSibling","appendChild","parentNode","removeChild","shiftPreview2","createElement","position","overflow","insertBefore","PAN","zoomIn","zoom","zoomOut","zoomActual","setTranslate","zoomTo","center","horizontal","vertical","cy","cw","ch","sw","sh","factor","rect","scrollRectToVisible","f","tx","ty","sl","st","zoomToRect","scaleX","scaleY","aspectFactor","rectRight","rectBottom","newHeight","deltaHeightBuffer","upperBuffer","newWidth","deltaWidthBuffer","leftBuffer","newScale","scrollCellToVisible","tr2","isChanged","widthLimit","heightLimit","ddx","ddy","isVisible","isCollapsed","isCellConnectable","isConnectable","isOrthogonal","orthogonal","STYLE_ORTHOGONAL","getEdgeStyle","SegmentConnector","ElbowConnector","SideToSide","TopToBottom","EntityRelation","OrthConnector","isLoop","getVisibleTerminalState","isCloneEvent","isControlDown","isMetaDown","isGridEnabledEvent","isAltDown","isConstrainedEvent","isIgnoreTerminalEvent","validationAlert","message","alert","isEdgeValid","isValidConnection","error","getEdgesBetween","sourceOut","getDirectedEdgeCount","targetIn","err","check","validateEdge","validateGraph","context","Object","isValid","ctx","warn","getCellValidationError","validateCell","outCount","inCount","rule","isNode","type","attr","countError","getBackgroundImage","setBackgroundImage","nodeName","toString","getLabel","STYLE_NOLABEL","isHtmlLabels","setHtmlLabels","isWrapping","STYLE_WHITE_SPACE","isLabelClipped","STYLE_OVERFLOW","getTooltip","node","tip","control","visit","handler","getHandler","getTooltipForNode","getTooltipForCell","getLinkForCell","getCursorForMouseEvent","getCursorForCell","DEFAULT_STARTSIZE","getVerticalAlign","getIndicatorColor","STYLE_INDICATOR_COLOR","getIndicatorGradientColor","STYLE_INDICATOR_GRADIENTCOLOR","getIndicatorShape","STYLE_INDICATOR_SHAPE","getIndicatorImage","STYLE_INDICATOR_IMAGE","setBorder","SHAPE_SWIMLANE","isResizeContainer","setResizeContainer","isEscapeEnabled","setEscapeEnabled","isInvokesStopCellEditing","setInvokesStopCellEditing","isEnterStopsCellEditing","setEnterStopsCellEditing","isCellLocked","isCellsLocked","setCellsLocked","getCloneableCells","filterCells","isCellCloneable","isCellsCloneable","STYLE_CLONEABLE","setCellsCloneable","getExportableCells","canExportCell","getImportableCells","canImportCell","isCellSelectable","isCellsSelectable","setCellsSelectable","isCellDeletable","isCellsDeletable","STYLE_DELETABLE","setCellsDeletable","isLabelMovable","isCellRotatable","STYLE_ROTATABLE","getMovableCells","isCellsMovable","STYLE_MOVABLE","setCellsMovable","isGridEnabled","setGridEnabled","setPortsEnabled","getGridSize","setGridSize","getTolerance","setTolerance","isVertexLabelsMovable","setVertexLabelsMovable","isEdgeLabelsMovable","setEdgeLabelsMovable","isSwimlaneNesting","setSwimlaneNesting","setSwimlaneSelectionEnabled","isMultigraph","setMultigraph","isAllowLoops","setAllowDanglingEdges","setConnectableEdges","isConnectableEdges","setCloneInvalidEdges","setAllowLoops","setDisconnectOnMove","isDropEnabled","setDropEnabled","isSplitEnabled","setSplitEnabled","isCellsResizable","STYLE_RESIZABLE","setCellsResizable","isTerminalPointMovable","isCellBendable","isCellsBendable","STYLE_BENDABLE","setCellsBendable","isCellsEditable","STYLE_EDITABLE","setCellsEditable","isCellsDisconnectable","setCellsDisconnectable","isValidSource","isValidTarget","connectable","setTooltips","setPanning","editingCell","getEditingCell","isAutoSizeCells","STYLE_AUTOSIZE","setAutoSizeCells","isExtendParents","setExtendParents","setExtendParentsOnAdd","setExtendParentsOnMove","setRecursiveResize","isConstrainChildren","setConstrainChildren","setConstrainRelativeChildren","isAllowOverlapParent","STYLE_FOLDABLE","isValidDropTarget","isSplitTarget","isAncestor","getDropTarget","convertPoint","getClientX","getClientY","isLayer","getSwimlane","intersects","vertices","ignoreFn","t2","dist","ptSegDistSq","hitsSwimlaneContent","getScale","getChildVertices","getChildEdges","getConnections","getIncomingEdges","getOutgoingEdges","incoming","outgoing","includeLoops","isValidAncestor","getOpposites","sources","targets","terminals","directed","getPointForEvent","addOffset","getCells","deg","box","getCellsBeyond","rightHalfpane","bottomHalfpane","findTreeRoots","isolate","invert","roots","best","maxDiff","conns","fanOut","fanIn","diff","traverse","func","visited","inverse","e","isSource","isSelectionEmpty","isEmpty","getSelectionCount","setCell","setSelectionCells","setCells","addSelectionCell","addSelectionCells","removeSelectionCell","removeCell","selectRegion","selectCellsForEvent","selectNextCell","selectCell","selectPreviousCell","selectParentCell","selectChildCell","isNext","isParent","isChild","sel","getIndex","selectAll","descendants","filterDescendants","selectVertices","selectCells","selectEdges","filter","createHandler","edgeStyle","createEdgeHandler","createVertexHandler","mxVertexHandler","createElbowEdgeHandler","createEdgeSegmentHandler","mxEdgeHandler","mxEdgeSegmentHandler","mxElbowEdgeHandler","addMouseListener","listener","removeMouseListener","updateMouseEvent","evtName","getX","getY","MOUSE_MOVE","paintBackground","mxRectangleShape","STYLE_POINTER_EVENTS","fill","NONE","getStateForTouchEvent","isEventIgnored","mouseEvent","isMouseEvent","lastEvent","eventSource","removeGestureListeners","mouseMoveRedirect","mouseUpRedirect","IS_GC","getSource","IS_TOUCH","MOUSE_DOWN","isPenEvent","fireMouseEvent","mxMouseEvent","MOUSE_UP","addGestureListeners","isSyntheticEventIgnored","isPopupTrigger","detail","isMouseTrigger","IS_FF","lastMouseX","lastMouseY","ignoreMouseEvents","isEventSourceIgnored","name","toLowerCase","candidate","isLeftMouseButton","getEventState","isTouchEvent","currentTime","Date","getTime","fireDoubleClick","lastTouchEvent","abs","lastTouchX","doubleClickCounter","doubleClickFired","lastTouchCell","valid","IS_SF","FIRE_MOUSE_EVENT","IS_OP","IS_IE11","args","preventDefault","returnValue","l","mouseDown","apply","mouseMove","mouseUp","tapAndHoldThread","clearTimeout","setTimeout","isEventSource","consumeMouseEvent","fireGestureEvent","GESTURE","destroyed","removeListener","__mxOutput","undefined"],"mappings":"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","file":"mxGraph.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraph\n *\n * Extends <mxEventSource> to implement a graph component for\n * the browser. This is the main class of the package. To activate\n * panning and connections use <setPanning> and <setConnectable>.\n * For rubberband selection you must create a new instance of\n * <mxRubberband>. The following listeners are added to\n * <mouseListeners> by default:\n * \n * - <tooltipHandler>: <mxTooltipHandler> that displays tooltips\n * - <panningHandler>: <mxPanningHandler> for panning and popup menus\n * - <connectionHandler>: <mxConnectionHandler> for creating connections\n * - <graphHandler>: <mxGraphHandler> for moving and cloning cells\n * \n * These listeners will be called in the above order if they are enabled.\n *\n * Background Images:\n * \n * To display a background image, set the image, image width and\n * image height using <setBackgroundImage>. If one of the\n * above values has changed then the <view>'s <mxGraphView.validate>\n * should be invoked.\n * \n * Cell Images:\n * \n * To use images in cells, a shape must be specified in the default\n * vertex style (or any named style). Possible shapes are\n * <mxConstants.SHAPE_IMAGE> and <mxConstants.SHAPE_LABEL>.\n * The code to change the shape used in the default vertex style,\n * the following code is used:\n * \n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;\n * (end)\n * \n * For the default vertex style, the image to be displayed can be\n * specified in a cell's style using the <mxConstants.STYLE_IMAGE>\n * key and the image URL as a value, for example:\n * \n * (code)\n * image=http://www.example.com/image.gif\n * (end)\n * \n * For a named style, the the stylename must be the first element\n * of the cell style:\n * \n * (code)\n * stylename;image=http://www.example.com/image.gif\n * (end)\n * \n * A cell style can have any number of key=value pairs added, divided\n * by a semicolon as follows:\n * \n * (code)\n * [stylename;|key=value;]\n * (end)\n *\n * Labels:\n * \n * The cell labels are defined by <getLabel> which uses <convertValueToString>\n * if <labelsVisible> is true. If a label must be rendered as HTML markup, then\n * <isHtmlLabel> should return true for the respective cell. If all labels\n * contain HTML markup, <htmlLabels> can be set to true. NOTE: Enabling HTML\n * labels carries a possible security risk (see the section on security in\n * the manual).\n * \n * If wrapping is needed for a label, then <isHtmlLabel> and <isWrapping> must\n * return true for the cell whose label should be wrapped. See <isWrapping> for\n * an example.\n * \n * If clipping is needed to keep the rendering of a HTML label inside the\n * bounds of its vertex, then <isClipping> should return true for the\n * respective cell.\n * \n * By default, edge labels are movable and vertex labels are fixed. This can be\n * changed by setting <edgeLabelsMovable> and <vertexLabelsMovable>, or by\n * overriding <isLabelMovable>.\n *\n * In-place Editing:\n * \n * In-place editing is started with a doubleclick or by typing F2.\n * Programmatically, <edit> is used to check if the cell is editable\n * (<isCellEditable>) and call <startEditingAtCell>, which invokes\n * <mxCellEditor.startEditing>. The editor uses the value returned\n * by <getEditingValue> as the editing value.\n * \n * After in-place editing, <labelChanged> is called, which invokes\n * <mxGraphModel.setValue>, which in turn calls\n * <mxGraphModel.valueForCellChanged> via <mxValueChange>.\n * \n * The event that triggers in-place editing is passed through to the\n * <cellEditor>, which may take special actions depending on the type of the\n * event or mouse location, and is also passed to <getEditingValue>. The event\n * is then passed back to the event processing functions which can perform\n * specific actions based on the trigger event.\n * \n * Tooltips:\n * \n * Tooltips are implemented by <getTooltip>, which calls <getTooltipForCell>\n * if a cell is under the mousepointer. The default implementation checks if\n * the cell has a getTooltip function and calls it if it exists. Hence, in order\n * to provide custom tooltips, the cell must provide a getTooltip function, or \n * one of the two above functions must be overridden.\n * \n * Typically, for custom cell tooltips, the latter function is overridden as\n * follows:\n * \n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n * \n * When using a config file, the function is overridden in the mxGraph section\n * using the following entry:\n * \n * (code)\n * <add as=\"getTooltipForCell\"><![CDATA[\n *   function(cell)\n *   {\n *     var label = this.convertValueToString(cell);\n *     return 'Tooltip for '+label;\n *   }\n * ]]></add>\n * (end)\n * \n * \"this\" refers to the graph in the implementation, so for example to check if \n * a cell is an edge, you use this.getModel().isEdge(cell)\n *\n * For replacing the default implementation of <getTooltipForCell> (rather than \n * replacing the function on a specific instance), the following code should be \n * used after loading the JavaScript files, but before creating a new mxGraph \n * instance using <mxGraph>:\n * \n * (code)\n * mxGraph.prototype.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n * \n * Shapes & Styles:\n * \n * The implementation of new shapes is demonstrated in the examples. We'll assume\n * that we have implemented a custom shape with the name BoxShape which we want\n * to use for drawing vertices. To use this shape, it must first be registered in\n * the cell renderer as follows:\n * \n * (code)\n * mxCellRenderer.registerShape('box', BoxShape);\n * (end)\n * \n * The code registers the BoxShape constructor under the name box in the cell\n * renderer of the graph. The shape can now be referenced using the shape-key in\n * a style definition. (The cell renderer contains a set of additional shapes,\n * namely one for each constant with a SHAPE-prefix in <mxConstants>.)\n *\n * Styles are a collection of key, value pairs and a stylesheet is a collection\n * of named styles. The names are referenced by the cellstyle, which is stored\n * in <mxCell.style> with the following format: [stylename;|key=value;]. The\n * string is resolved to a collection of key, value pairs, where the keys are\n * overridden with the values in the string.\n *\n * When introducing a new shape, the name under which the shape is registered\n * must be used in the stylesheet. There are three ways of doing this:\n * \n *   - By changing the default style, so that all vertices will use the new\n * \t\tshape\n *   - By defining a new style, so that only vertices with the respective\n * \t\tcellstyle will use the new shape\n *   - By using shape=box in the cellstyle's optional list of key, value pairs\n * \t\tto be overridden\n *\n * In the first case, the code to fetch and modify the default style for\n * vertices is as follows:\n * \n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * (end)\n * \n * The code takes the default vertex style, which is used for all vertices that\n * do not have a specific cellstyle, and modifies the value for the shape-key\n * in-place to use the new BoxShape for drawing vertices. This is done by\n * assigning the box value in the second line, which refers to the name of the\n * BoxShape in the cell renderer.\n * \n * In the second case, a collection of key, value pairs is created and then\n * added to the stylesheet under a new name. In order to distinguish the\n * shapename and the stylename we'll use boxstyle for the stylename:\n * \n * (code)\n * var style = new Object();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * style[mxConstants.STYLE_STROKECOLOR] = '#000000';\n * style[mxConstants.STYLE_FONTCOLOR] = '#000000';\n * graph.getStylesheet().putCellStyle('boxstyle', style);\n * (end)\n * \n * The code adds a new style with the name boxstyle to the stylesheet. To use\n * this style with a cell, it must be referenced from the cellstyle as follows:\n * \n * (code)\n * var vertex = graph.insertVertex(parent, null, 'Hello, World!', 20, 20, 80, 20,\n * \t\t\t\t'boxstyle');\n * (end)\n * \n * To summarize, each new shape must be registered in the <mxCellRenderer> with\n * a unique name. That name is then used as the value of the shape-key in a\n * default or custom style. If there are multiple custom shapes, then there\n * should be a separate style for each shape.\n * \n * Inheriting Styles:\n * \n * For fill-, stroke-, gradient- and indicatorColors special keywords can be\n * used. The inherit keyword for one of these colors will inherit the color\n * for the same key from the parent cell. The swimlane keyword does the same,\n * but inherits from the nearest swimlane in the ancestor hierarchy. Finally,\n * the indicated keyword will use the color of the indicator as the color for\n * the given key.\n * \n * Scrollbars:\n * \n * The <containers> overflow CSS property defines if scrollbars are used to\n * display the graph. For values of 'auto' or 'scroll', the scrollbars will\n * be shown. Note that the <resizeContainer> flag is normally not used\n * together with scrollbars, as it will resize the container to match the\n * size of the graph after each change.\n * \n * Multiplicities and Validation:\n * \n * To control the possible connections in mxGraph, <getEdgeValidationError> is\n * used. The default implementation of the function uses <multiplicities>,\n * which is an array of <mxMultiplicity>. Using this class allows to establish\n * simple multiplicities, which are enforced by the graph.\n * \n * The <mxMultiplicity> uses <mxCell.is> to determine for which terminals it\n * applies. The default implementation of <mxCell.is> works with DOM nodes (XML\n * nodes) and checks if the given type parameter matches the nodeName of the\n * node (case insensitive). Optionally, an attributename and value can be\n * specified which are also checked.\n * \n * <getEdgeValidationError> is called whenever the connectivity of an edge\n * changes. It returns an empty string or an error message if the edge is\n * invalid or null if the edge is valid. If the returned string is not empty\n * then it is displayed as an error message.\n * \n * <mxMultiplicity> allows to specify the multiplicity between a terminal and\n * its possible neighbors. For example, if any rectangle may only be connected\n * to, say, a maximum of two circles you can add the following rule to\n * <multiplicities>:\n * \n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only shape targets allowed'));\n * (end)\n * \n * This will display the first error message whenever a rectangle is connected\n * to more than two circles and the second error message if a rectangle is\n * connected to anything but a circle.\n * \n * For certain multiplicities, such as a minimum of 1 connection, which cannot\n * be enforced at cell creation time (unless the cell is created together with\n * the connection), mxGraph offers <validate> which checks all multiplicities\n * for all cells and displays the respective error messages in an overlay icon\n * on the cells.\n * \n * If a cell is collapsed and contains validation errors, a respective warning\n * icon is attached to the collapsed cell.\n * \n * Auto-Layout:\n * \n * For automatic layout, the <getLayout> hook is provided in <mxLayoutManager>.\n * It can be overridden to return a layout algorithm for the children of a\n * given cell.\n * \n * Unconnected edges:\n * \n * The default values for all switches are designed to meet the requirements of\n * general diagram drawing applications. A very typical set of settings to\n * avoid edges that are not connected is the following:\n * \n * (code)\n * graph.setAllowDanglingEdges(false);\n * graph.setDisconnectOnMove(false);\n * (end)\n * \n * Setting the <cloneInvalidEdges> switch to true is optional. This switch\n * controls if edges are inserted after a copy, paste or clone-drag if they are\n * invalid. For example, edges are invalid if copied or control-dragged without \n * having selected the corresponding terminals and allowDanglingEdges is\n * false, in which case the edges will not be cloned if the switch is false.\n * \n * Output:\n * \n * To produce an XML representation for a diagram, the following code can be\n * used.\n * \n * (code)\n * var enc = new mxCodec(mxUtils.createXmlDocument());\n * var node = enc.encode(graph.getModel());\n * (end)\n * \n * This will produce an XML node than can be handled using the DOM API or\n * turned into a string representation using the following code:\n * \n * (code)\n * var xml = mxUtils.getXml(node);\n * (end)\n * \n * To obtain a formatted string, mxUtils.getPrettyXml can be used instead.\n * \n * This string can now be stored in a local persistent storage (for example\n * using Google Gears) or it can be passed to a backend using mxUtils.post as\n * follows. The url variable is the URL of the Java servlet, PHP page or HTTP\n * handler, depending on the server.\n * \n * (code)\n * var xmlString = encodeURIComponent(mxUtils.getXml(node));\n * mxUtils.post(url, 'xml='+xmlString, function(req)\n * {\n *   // Process server response using req of type mxXmlRequest\n * });\n * (end)\n * \n * Input:\n * \n * To load an XML representation of a diagram into an existing graph object\n * mxUtils.load can be used as follows. The url variable is the URL of the Java\n * servlet, PHP page or HTTP handler that produces the XML string.\n * \n * (code)\n * var xmlDoc = mxUtils.load(url).getXml();\n * var node = xmlDoc.documentElement;\n * var dec = new mxCodec(node.ownerDocument);\n * dec.decode(node, graph.getModel());\n * (end)\n * \n * For creating a page that loads the client and a diagram using a single\n * request please refer to the deployment examples in the backends.\n * \n * Functional dependencies:\n * \n * (see images/callgraph.png)\n * \n * Resources:\n *\n * resources/graph - Language resources for mxGraph\n *\n * Group: Events\n * \n * Event: mxEvent.ROOT\n * \n * Fires if the root in the model has changed. This event has no properties.\n * \n * Event: mxEvent.ALIGN_CELLS\n * \n * Fires between begin- and endUpdate in <alignCells>. The <code>cells</code>\n * and <code>align</code> properties contain the respective arguments that were\n * passed to <alignCells>.\n *\n * Event: mxEvent.FLIP_EDGE\n *\n * Fires between begin- and endUpdate in <flipEdge>. The <code>edge</code>\n * property contains the edge passed to <flipEdge>.\n * \n * Event: mxEvent.ORDER_CELLS\n * \n * Fires between begin- and endUpdate in <orderCells>. The <code>cells</code>\n * and <code>back</code> properties contain the respective arguments that were\n * passed to <orderCells>.\n *\n * Event: mxEvent.CELLS_ORDERED\n *\n * Fires between begin- and endUpdate in <cellsOrdered>. The <code>cells</code>\n * and <code>back</code> arguments contain the respective arguments that were\n * passed to <cellsOrdered>.\n * \n * Event: mxEvent.GROUP_CELLS\n * \n * Fires between begin- and endUpdate in <groupCells>. The <code>group</code>,\n * <code>cells</code> and <code>border</code> arguments contain the respective\n * arguments that were passed to <groupCells>.\n * \n * Event: mxEvent.UNGROUP_CELLS\n * \n * Fires between begin- and endUpdate in <ungroupCells>. The <code>cells</code>\n * property contains the array of cells that was passed to <ungroupCells>.\n * \n * Event: mxEvent.REMOVE_CELLS_FROM_PARENT\n * \n * Fires between begin- and endUpdate in <removeCellsFromParent>. The\n * <code>cells</code> property contains the array of cells that was passed to\n * <removeCellsFromParent>.\n * \n * Event: mxEvent.ADD_CELLS\n * \n * Fires between begin- and endUpdate in <addCells>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code> and\n * <code>target</code> properties contain the respective arguments that were\n * passed to <addCells>.\n * \n * Event: mxEvent.CELLS_ADDED\n * \n * Fires between begin- and endUpdate in <cellsAdded>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code>,\n * <code>target</code> and <code>absolute</code> properties contain the\n * respective arguments that were passed to <cellsAdded>.\n * \n * Event: mxEvent.REMOVE_CELLS\n * \n * Fires between begin- and endUpdate in <removeCells>. The <code>cells</code>\n * and <code>includeEdges</code> arguments contain the respective arguments\n * that were passed to <removeCells>.\n * \n * Event: mxEvent.CELLS_REMOVED\n * \n * Fires between begin- and endUpdate in <cellsRemoved>. The <code>cells</code>\n * argument contains the array of cells that was removed.\n * \n * Event: mxEvent.SPLIT_EDGE\n * \n * Fires between begin- and endUpdate in <splitEdge>. The <code>edge</code>\n * property contains the edge to be splitted, the <code>cells</code>,\n * <code>newEdge</code>, <code>dx</code> and <code>dy</code> properties contain\n * the respective arguments that were passed to <splitEdge>.\n * \n * Event: mxEvent.TOGGLE_CELLS\n * \n * Fires between begin- and endUpdate in <toggleCells>. The <code>show</code>,\n * <code>cells</code> and <code>includeEdges</code> properties contain the\n * respective arguments that were passed to <toggleCells>.\n * \n * Event: mxEvent.FOLD_CELLS\n * \n * Fires between begin- and endUpdate in <foldCells>. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to <foldCells>.\n * \n * Event: mxEvent.CELLS_FOLDED\n * \n * Fires between begin- and endUpdate in cellsFolded. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to\n * <cellsFolded>.\n * \n * Event: mxEvent.UPDATE_CELL_SIZE\n * \n * Fires between begin- and endUpdate in <updateCellSize>. The\n * <code>cell</code> and <code>ignoreChildren</code> properties contain the\n * respective arguments that were passed to <updateCellSize>.\n * \n * Event: mxEvent.RESIZE_CELLS\n * \n * Fires between begin- and endUpdate in <resizeCells>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <resizeCells>.\n * \n * Event: mxEvent.CELLS_RESIZED\n * \n * Fires between begin- and endUpdate in <cellsResized>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <cellsResized>.\n * \n * Event: mxEvent.MOVE_CELLS\n * \n * Fires between begin- and endUpdate in <moveCells>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code>, <code>clone</code>, <code>target</code>\n * and <code>event</code> properties contain the respective arguments that\n * were passed to <moveCells>.\n * \n * Event: mxEvent.CELLS_MOVED\n * \n * Fires between begin- and endUpdate in <cellsMoved>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code> and <code>disconnect</code> properties\n * contain the respective arguments that were passed to <cellsMoved>.\n * \n * Event: mxEvent.CONNECT_CELL\n * \n * Fires between begin- and endUpdate in <connectCell>. The <code>edge</code>,\n * <code>terminal</code> and <code>source</code> properties contain the\n * respective arguments that were passed to <connectCell>.\n * \n * Event: mxEvent.CELL_CONNECTED\n * \n * Fires between begin- and endUpdate in <cellConnected>. The\n * <code>edge</code>, <code>terminal</code> and <code>source</code> properties\n * contain the respective arguments that were passed to <cellConnected>.\n * \n * Event: mxEvent.REFRESH\n * \n * Fires after <refresh> was executed. This event has no properties.\n *\n * Event: mxEvent.CLICK\n * \n * Fires in <click> after a click event. The <code>event</code> property\n * contains the original mouse event and <code>cell</code> property contains\n * the cell under the mouse or null if the background was clicked.\n * \n * Event: mxEvent.DOUBLE_CLICK\n *\n * Fires in <dblClick> after a double click. The <code>event</code> property\n * contains the original mouse event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n * \n * Event: mxEvent.GESTURE\n *\n * Fires in <fireGestureEvent> after a touch gesture. The <code>event</code>\n * property contains the original gesture end event and the <code>cell</code>\n * property contains the optional cell associated with the gesture.\n *\n * Event: mxEvent.TAP_AND_HOLD\n *\n * Fires in <tapAndHold> if a tap and hold event was detected. The <code>event</code>\n * property contains the initial touch event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n *\n * Event: mxEvent.FIRE_MOUSE_EVENT\n *\n * Fires in <fireMouseEvent> before the mouse listeners are invoked. The\n * <code>eventName</code> property contains the event name and the\n * <code>event</code> property contains the <mxMouseEvent>.\n *\n * Event: mxEvent.SIZE\n *\n * Fires after <sizeDidChange> was executed. The <code>bounds</code> property\n * contains the new graph bounds.\n *\n * Event: mxEvent.START_EDITING\n *\n * Fires before the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n * \n * Event: mxEvent.EDITING_STARTED\n *\n * Fires after the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n * \n * Event: mxEvent.EDITING_STOPPED\n *\n * Fires after the in-place editor stops in <stopEditing>.\n *\n * Event: mxEvent.LABEL_CHANGED\n *\n * Fires between begin- and endUpdate in <cellLabelChanged>. The\n * <code>cell</code> property contains the cell, the <code>value</code>\n * property contains the new value for the cell, the <code>old</code> property\n * contains the old value and the optional <code>event</code> property contains\n * the mouse event that started the edit.\n * \n * Event: mxEvent.ADD_OVERLAY\n *\n * Fires after an overlay is added in <addCellOverlay>. The <code>cell</code>\n * property contains the cell and the <code>overlay</code> property contains\n * the <mxCellOverlay> that was added.\n *\n * Event: mxEvent.REMOVE_OVERLAY\n *\n * Fires after an overlay is removed in <removeCellOverlay> and\n * <removeCellOverlays>. The <code>cell</code> property contains the cell and\n * the <code>overlay</code> property contains the <mxCellOverlay> that was\n * removed.\n * \n * Constructor: mxGraph\n * \n * Constructs a new mxGraph in the specified container. Model is an optional\n * mxGraphModel. If no model is provided, a new mxGraphModel instance is \n * used as the model. The container must have a valid owner document prior \n * to calling this function in Internet Explorer. RenderHint is a string to\n * affect the display performance and rendering in IE, but not in SVG-based \n * browsers. The parameter is mapped to <dialect>, which may \n * be one of <mxConstants.DIALECT_SVG> for SVG-based browsers, \n * <mxConstants.DIALECT_STRICTHTML> for fastest display mode,\n * <mxConstants.DIALECT_PREFERHTML> for faster display mode,\n * <mxConstants.DIALECT_MIXEDHTML> for fast and <mxConstants.DIALECT_VML> \n * for exact display mode (slowest). The dialects are defined in mxConstants.\n * The default values are DIALECT_SVG for SVG-based browsers and\n * DIALECT_MIXED for IE.\n *\n * The possible values for the renderingHint parameter are explained below:\n * \n * fast - The parameter is based on the fact that the display performance is \n * highly improved in IE if the VML is not contained within a VML group \n * element. The lack of a group element only slightly affects the display while \n * panning, but improves the performance by almost a factor of 2, while keeping \n * the display sufficiently accurate. This also allows to render certain shapes as HTML \n * if the display accuracy is not affected, which is implemented by \n * <mxShape.isMixedModeHtml>. This is the default setting and is mapped to\n * DIALECT_MIXEDHTML.\n * faster - Same as fast, but more expensive shapes are avoided. This is \n * controlled by <mxShape.preferModeHtml>. The default implementation will \n * avoid gradients and rounded rectangles, but more significant shapes, such \n * as rhombus, ellipse, actor and cylinder will be rendered accurately. This \n * setting is mapped to DIALECT_PREFERHTML.\n * fastest - Almost anything will be rendered in Html. This allows for \n * rectangles, labels and images. This setting is mapped to\n * DIALECT_STRICTHTML.\n * exact - If accurate panning is required and if the diagram is small (up\n * to 100 cells), then this value should be used. In this mode, a group is \n * created that contains the VML. This allows for accurate panning and is \n * mapped to DIALECT_VML.\n *\n * Example:\n * \n * To create a graph inside a DOM node with an id of graph:\n * (code)\n * var container = document.getElementById('graph');\n * var graph = new mxGraph(container);\n * (end)\n * \n * Parameters:\n * \n * container - Optional DOM node that acts as a container for the graph.\n * If this is null then the container can be initialized later using\n * <init>.\n * model - Optional <mxGraphModel> that constitutes the graph data.\n * renderHint - Optional string that specifies the display accuracy and\n * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).\n * stylesheet - Optional <mxStylesheet> to be used in the graph.\n */\nfunction mxGraph(container, model, renderHint, stylesheet)\n{\n\t// Initializes the variable in case the prototype has been\n\t// modified to hold some listeners (which is possible because\n\t// the createHandlers call is executed regardless of the\n\t// arguments passed into the ctor).\n\tthis.mouseListeners = null;\n\t\n\t// Converts the renderHint into a dialect\n\tthis.renderHint = renderHint;\n\n\tif (mxClient.IS_SVG)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_SVG;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_VML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTEST)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_STRICTHTML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTER)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_PREFERHTML;\n\t}\n\telse // default for VML\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_MIXEDHTML;\n\t}\n\t\n\t// Initializes the main members that do not require a container\n\tthis.model = (model != null) ? model : new mxGraphModel();\n\tthis.multiplicities = [];\n\tthis.imageBundles = [];\n\tthis.cellRenderer = this.createCellRenderer();\n\tthis.setSelectionModel(this.createSelectionModel());\n\tthis.setStylesheet((stylesheet != null) ? stylesheet : this.createStylesheet());\n\tthis.view = this.createGraphView();\n\t\n\t// Adds a graph model listener to update the view\n\tthis.graphModelChangeListener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tthis.graphModelChanged(evt.getProperty('edit').changes);\n\t});\n\t\n\tthis.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);\n\n\t// Installs basic event handlers with disabled default settings.\n\tthis.createHandlers();\n\t\n\t// Initializes the display if a container was specified\n\tif (container != null)\n\t{\n\t\tthis.init(container);\n\t}\n\t\n\tthis.view.revalidate();\n};\n\n/**\n * Installs the required language resources at class\n * loading time.\n */\nif (mxLoadResources)\n{\n\tmxResources.add(mxClient.basePath + '/resources/graph');\n}\nelse\n{\n\tmxClient.defaultBundles.push(mxClient.basePath + '/resources/graph');\n}\n\n/**\n * Extends mxEventSource.\n */\nmxGraph.prototype = new mxEventSource();\nmxGraph.prototype.constructor = mxGraph;\n\n/**\n * Variable: EMPTY_ARRAY\n *\n * Immutable empty array instance.\n */\nmxGraph.prototype.EMPTY_ARRAY = [];\n\n/**\n * Group: Variables\n */\n\n/**\n * Variable: mouseListeners\n * \n * Holds the mouse event listeners. See <fireMouseEvent>.\n */\nmxGraph.prototype.mouseListeners = null;\n\n/**\n * Variable: isMouseDown\n * \n * Holds the state of the mouse button.\n */\nmxGraph.prototype.isMouseDown = false;\n\n/**\n * Variable: model\n * \n * Holds the <mxGraphModel> that contains the cells to be displayed.\n */\nmxGraph.prototype.model = null;\n\n/**\n * Variable: view\n * \n * Holds the <mxGraphView> that caches the <mxCellStates> for the cells.\n */\nmxGraph.prototype.view = null;\n\n/**\n * Variable: stylesheet\n * \n * Holds the <mxStylesheet> that defines the appearance of the cells.\n * \n * \n * Example:\n * \n * Use the following code to read a stylesheet into an existing graph.\n * \n * (code)\n * var req = mxUtils.load('stylesheet.xml');\n * var root = req.getDocumentElement();\n * var dec = new mxCodec(root.ownerDocument);\n * dec.decode(root, graph.stylesheet);\n * (end)\n */\nmxGraph.prototype.stylesheet = null;\n\t\n/**\n * Variable: selectionModel\n * \n * Holds the <mxGraphSelectionModel> that models the current selection.\n */\nmxGraph.prototype.selectionModel = null;\n\n/**\n * Variable: cellEditor\n * \n * Holds the <mxCellEditor> that is used as the in-place editing.\n */\nmxGraph.prototype.cellEditor = null;\n\n/**\n * Variable: cellRenderer\n * \n * Holds the <mxCellRenderer> for rendering the cells in the graph.\n */\nmxGraph.prototype.cellRenderer = null;\n\n/**\n * Variable: multiplicities\n * \n * An array of <mxMultiplicities> describing the allowed\n * connections in a graph.\n */\nmxGraph.prototype.multiplicities = null;\n\n/**\n * Variable: renderHint\n * \n * RenderHint as it was passed to the constructor.\n */\nmxGraph.prototype.renderHint = null;\n\n/**\n * Variable: dialect\n * \n * Dialect to be used for drawing the graph. Possible values are all\n * constants in <mxConstants> with a DIALECT-prefix.\n */\nmxGraph.prototype.dialect = null;\n\n/**\n * Variable: gridSize\n * \n * Specifies the grid size. Default is 10.\n */\nmxGraph.prototype.gridSize = 10;\n\t\n/**\n * Variable: gridEnabled\n * \n * Specifies if the grid is enabled. This is used in <snap>. Default is\n * true.\n */\nmxGraph.prototype.gridEnabled = true;\n\n/**\n * Variable: portsEnabled\n * \n * Specifies if ports are enabled. This is used in <cellConnected> to update\n * the respective style. Default is true.\n */\nmxGraph.prototype.portsEnabled = true;\n\n/**\n * Variable: nativeDoubleClickEnabled\n * \n * Specifies if native double click events should be detected. Default is true.\n */\nmxGraph.prototype.nativeDblClickEnabled = true;\n\n/**\n * Variable: doubleTapEnabled\n * \n * Specifies if double taps on touch-based devices should be handled as a\n * double click. Default is true.\n */\nmxGraph.prototype.doubleTapEnabled = true;\n\n/**\n * Variable: doubleTapTimeout\n * \n * Specifies the timeout for double taps and non-native double clicks. Default\n * is 500 ms.\n */\nmxGraph.prototype.doubleTapTimeout = 500;\n\n/**\n * Variable: doubleTapTolerance\n * \n * Specifies the tolerance for double taps and double clicks in quirks mode.\n * Default is 25 pixels.\n */\nmxGraph.prototype.doubleTapTolerance = 25;\n\n/**\n * Variable: lastTouchX\n * \n * Holds the x-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchX\n * \n * Holds the y-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchTime\n * \n * Holds the time of the last touch event for double click detection.\n */\nmxGraph.prototype.lastTouchTime = 0;\n\n/**\n * Variable: tapAndHoldEnabled\n * \n * Specifies if tap and hold should be used for starting connections on touch-based\n * devices. Default is true.\n */\nmxGraph.prototype.tapAndHoldEnabled = true;\n\n/**\n * Variable: tapAndHoldDelay\n * \n * Specifies the time for a tap and hold. Default is 500 ms.\n */\nmxGraph.prototype.tapAndHoldDelay = 500;\n\n/**\n * Variable: tapAndHoldInProgress\n * \n * True if the timer for tap and hold events is running.\n */\nmxGraph.prototype.tapAndHoldInProgress = false;\n\n/**\n * Variable: tapAndHoldValid\n * \n * True as long as the timer is running and the touch events\n * stay within the given <tapAndHoldTolerance>.\n */\nmxGraph.prototype.tapAndHoldValid = false;\n\n/**\n * Variable: initialTouchX\n * \n * Holds the x-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchX = 0;\n\n/**\n * Variable: initialTouchY\n * \n * Holds the y-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchY = 0;\n\n/**\n * Variable: tolerance\n * \n * Tolerance for a move to be handled as a single click.\n * Default is 4 pixels.\n */\nmxGraph.prototype.tolerance = 4;\n\n/**\n * Variable: defaultOverlap\n * \n * Value returned by <getOverlap> if <isAllowOverlapParent> returns\n * true for the given cell. <getOverlap> is used in <constrainChild> if\n * <isConstrainChild> returns true. The value specifies the\n * portion of the child which is allowed to overlap the parent.\n */\nmxGraph.prototype.defaultOverlap = 0.5;\n\n/**\n * Variable: defaultParent\n * \n * Specifies the default parent to be used to insert new cells.\n * This is used in <getDefaultParent>. Default is null.\n */\nmxGraph.prototype.defaultParent = null;\n\n/**\n * Variable: alternateEdgeStyle\n * \n * Specifies the alternate edge style to be used if the main control point\n * on an edge is being doubleclicked. Default is null.\n */\nmxGraph.prototype.alternateEdgeStyle = null;\n\n/**\n * Variable: backgroundImage\n *\n * Specifies the <mxImage> to be returned by <getBackgroundImage>. Default\n * is null.\n * \n * Example:\n *\n * (code)\n * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\n * graph.setBackgroundImage(img);\n * graph.view.validate();\n * (end)\n */\nmxGraph.prototype.backgroundImage = null;\n\n/**\n * Variable: pageVisible\n *\n * Specifies if the background page should be visible. Default is false.\n * Not yet implemented.\n */\nmxGraph.prototype.pageVisible = false;\n\n/**\n * Variable: pageBreaksVisible\n * \n * Specifies if a dashed line should be drawn between multiple pages. Default\n * is false. If you change this value while a graph is being displayed then you\n * should call <sizeDidChange> to force an update of the display.\n */\nmxGraph.prototype.pageBreaksVisible = false;\n\n/**\n * Variable: pageBreakColor\n * \n * Specifies the color for page breaks. Default is 'gray'.\n */\nmxGraph.prototype.pageBreakColor = 'gray';\n\n/**\n * Variable: pageBreakDashed\n * \n * Specifies the page breaks should be dashed. Default is true.\n */\nmxGraph.prototype.pageBreakDashed = true;\n\n/**\n * Variable: minPageBreakDist\n * \n * Specifies the minimum distance for page breaks to be visible. Default is\n * 20 (in pixels).\n */\nmxGraph.prototype.minPageBreakDist = 20;\n\n/**\n * Variable: preferPageSize\n * \n * Specifies if the graph size should be rounded to the next page number in\n * <sizeDidChange>. This is only used if the graph container has scrollbars.\n * Default is false.\n */\nmxGraph.prototype.preferPageSize = false;\n\n/**\n * Variable: pageFormat\n *\n * Specifies the page format for the background page. Default is\n * <mxConstants.PAGE_FORMAT_A4_PORTRAIT>. This is used as the default in\n * <mxPrintPreview> and for painting the background page if <pageVisible> is\n * true and the pagebreaks if <pageBreaksVisible> is true.\n */\nmxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;\n\n/**\n * Variable: pageScale\n *\n * Specifies the scale of the background page. Default is 1.5.\n * Not yet implemented.\n */\nmxGraph.prototype.pageScale = 1.5;\n\n/**\n * Variable: enabled\n * \n * Specifies the return value for <isEnabled>. Default is true.\n */\nmxGraph.prototype.enabled = true;\n\n/**\n * Variable: escapeEnabled\n * \n * Specifies if <mxKeyHandler> should invoke <escape> when the escape key\n * is pressed. Default is true.\n */\nmxGraph.prototype.escapeEnabled = true;\n\n/**\n * Variable: invokesStopCellEditing\n * \n * If true, when editing is to be stopped by way of selection changing,\n * data in diagram changing or other means stopCellEditing is invoked, and\n * changes are saved. This is implemented in a focus handler in\n * <mxCellEditor>. Default is true.\n */\nmxGraph.prototype.invokesStopCellEditing = true;\n\n/**\n * Variable: enterStopsCellEditing\n * \n * If true, pressing the enter key without pressing control or shift will stop\n * editing and accept the new value. This is used in <mxCellEditor> to stop\n * cell editing. Note: You can always use F2 and escape to stop editing.\n * Default is false.\n */\nmxGraph.prototype.enterStopsCellEditing = false;\n\n/**\n * Variable: useScrollbarsForPanning\n * \n * Specifies if scrollbars should be used for panning in <panGraph> if\n * any scrollbars are available. If scrollbars are enabled in CSS, but no\n * scrollbars appear because the graph is smaller than the container size,\n * then no panning occurs if this is true. Default is true.\n */\nmxGraph.prototype.useScrollbarsForPanning = true;\n\n/**\n * Variable: exportEnabled\n * \n * Specifies the return value for <canExportCell>. Default is true.\n */\nmxGraph.prototype.exportEnabled = true;\n\n/**\n * Variable: importEnabled\n * \n * Specifies the return value for <canImportCell>. Default is true.\n */\nmxGraph.prototype.importEnabled = true;\n\n/**\n * Variable: cellsLocked\n * \n * Specifies the return value for <isCellLocked>. Default is false.\n */\nmxGraph.prototype.cellsLocked = false;\n\n/**\n * Variable: cellsCloneable\n * \n * Specifies the return value for <isCellCloneable>. Default is true.\n */\nmxGraph.prototype.cellsCloneable = true;\n\n/**\n * Variable: foldingEnabled\n * \n * Specifies if folding (collapse and expand via an image icon in the graph\n * should be enabled). Default is true.\n */\nmxGraph.prototype.foldingEnabled = true;\n\n/**\n * Variable: cellsEditable\n * \n * Specifies the return value for <isCellEditable>. Default is true.\n */\nmxGraph.prototype.cellsEditable = true;\n\t\t\n/**\n * Variable: cellsDeletable\n * \n * Specifies the return value for <isCellDeletable>. Default is true.\n */\nmxGraph.prototype.cellsDeletable = true;\n\n/**\n * Variable: cellsMovable\n * \n * Specifies the return value for <isCellMovable>. Default is true.\n */\nmxGraph.prototype.cellsMovable = true;\n\t\n/**\n * Variable: edgeLabelsMovable\n * \n * Specifies the return value for edges in <isLabelMovable>. Default is true.\n */\nmxGraph.prototype.edgeLabelsMovable = true;\n\t\n/**\n * Variable: vertexLabelsMovable\n * \n * Specifies the return value for vertices in <isLabelMovable>. Default is false.\n */\nmxGraph.prototype.vertexLabelsMovable = false;\n\n/**\n * Variable: dropEnabled\n * \n * Specifies the return value for <isDropEnabled>. Default is false.\n */\nmxGraph.prototype.dropEnabled = false;\n\n/**\n * Variable: splitEnabled\n * \n * Specifies if dropping onto edges should be enabled. This is ignored if\n * <dropEnabled> is false. If enabled, it will call <splitEdge> to carry\n * out the drop operation. Default is true.\n */\nmxGraph.prototype.splitEnabled = true;\n\n/**\n * Variable: cellsResizable\n * \n * Specifies the return value for <isCellResizable>. Default is true.\n */\nmxGraph.prototype.cellsResizable = true;\n\n/**\n * Variable: cellsBendable\n * \n * Specifies the return value for <isCellsBendable>. Default is true.\n */\nmxGraph.prototype.cellsBendable = true;\n\n/**\n * Variable: cellsSelectable\n * \n * Specifies the return value for <isCellSelectable>. Default is true.\n */\nmxGraph.prototype.cellsSelectable = true;\n\n/**\n * Variable: cellsDisconnectable\n * \n * Specifies the return value for <isCellDisconntable>. Default is true.\n */\nmxGraph.prototype.cellsDisconnectable = true;\n\n/**\n * Variable: autoSizeCells\n * \n * Specifies if the graph should automatically update the cell size after an\n * edit. This is used in <isAutoSizeCell>. Default is false.\n */\nmxGraph.prototype.autoSizeCells = false;\n\n/**\n * Variable: autoSizeCellsOnAdd\n * \n * Specifies if autoSize style should be applied when cells are added. Default is false.\n */\nmxGraph.prototype.autoSizeCellsOnAdd = false;\n\n/**\n * Variable: autoScroll\n * \n * Specifies if the graph should automatically scroll if the mouse goes near\n * the container edge while dragging. This is only taken into account if the\n * container has scrollbars. Default is true.\n * \n * If you need this to work without scrollbars then set <ignoreScrollbars> to\n * true. Please consult the <ignoreScrollbars> for details. In general, with\n * no scrollbars, the use of <allowAutoPanning> is recommended.\n */\nmxGraph.prototype.autoScroll = true;\n\n/**\n * Variable: ignoreScrollbars\n * \n * Specifies if the graph should automatically scroll regardless of the\n * scrollbars. This will scroll the container using positive values for\n * scroll positions (ie usually only rightwards and downwards). To avoid\n * possible conflicts with panning, set <translateToScrollPosition> to true.\n */\nmxGraph.prototype.ignoreScrollbars = false;\n\n/**\n * Variable: translateToScrollPosition\n * \n * Specifies if the graph should automatically convert the current scroll\n * position to a translate in the graph view when a mouseUp event is received.\n * This can be used to avoid conflicts when using <autoScroll> and\n * <ignoreScrollbars> with no scrollbars in the container.\n */\nmxGraph.prototype.translateToScrollPosition = false;\n\n/**\n * Variable: timerAutoScroll\n * \n * Specifies if autoscrolling should be carried out via mxPanningManager even\n * if the container has scrollbars. This disables <scrollPointToVisible> and\n * uses <mxPanningManager> instead. If this is true then <autoExtend> is\n * disabled. It should only be used with a scroll buffer or when scollbars\n * are visible and scrollable in all directions. Default is false.\n */\nmxGraph.prototype.timerAutoScroll = false;\n\n/**\n * Variable: allowAutoPanning\n * \n * Specifies if panning via <panGraph> should be allowed to implement autoscroll\n * if no scrollbars are available in <scrollPointToVisible>. To enable panning\n * inside the container, near the edge, set <mxPanningManager.border> to a\n * positive value. Default is false.\n */\nmxGraph.prototype.allowAutoPanning = false;\n\n/**\n * Variable: autoExtend\n * \n * Specifies if the size of the graph should be automatically extended if the\n * mouse goes near the container edge while dragging. This is only taken into\n * account if the container has scrollbars. Default is true. See <autoScroll>.\n */\nmxGraph.prototype.autoExtend = true;\n\n/**\n * Variable: maximumGraphBounds\n * \n * <mxRectangle> that specifies the area in which all cells in the diagram\n * should be placed. Uses in <getMaximumGraphBounds>. Use a width or height of\n * 0 if you only want to give a upper, left corner.\n */\nmxGraph.prototype.maximumGraphBounds = null;\n\n/**\n * Variable: minimumGraphSize\n * \n * <mxRectangle> that specifies the minimum size of the graph. This is ignored\n * if the graph container has no scrollbars. Default is null.\n */\nmxGraph.prototype.minimumGraphSize = null;\n\n/**\n * Variable: minimumContainerSize\n * \n * <mxRectangle> that specifies the minimum size of the <container> if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.minimumContainerSize = null;\n\t\t\n/**\n * Variable: maximumContainerSize\n * \n * <mxRectangle> that specifies the maximum size of the container if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.maximumContainerSize = null;\n\n/**\n * Variable: resizeContainer\n * \n * Specifies if the container should be resized to the graph size when\n * the graph size has changed. Default is false.\n */\nmxGraph.prototype.resizeContainer = false;\n\n/**\n * Variable: border\n * \n * Border to be added to the bottom and right side when the container is\n * being resized after the graph has been changed. Default is 0.\n */\nmxGraph.prototype.border = 0;\n\t\t\n/**\n * Variable: keepEdgesInForeground\n * \n * Specifies if edges should appear in the foreground regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInForeground = false;\n\n/**\n * Variable: keepEdgesInBackground\n * \n * Specifies if edges should appear in the background regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInBackground = false;\n\n/**\n * Variable: allowNegativeCoordinates\n * \n * Specifies if negative coordinates for vertices are allowed. Default is true.\n */\nmxGraph.prototype.allowNegativeCoordinates = true;\n\n/**\n * Variable: constrainChildren\n * \n * Specifies if a child should be constrained inside the parent bounds after a\n * move or resize of the child. Default is true.\n */\nmxGraph.prototype.constrainChildren = true;\n\n/**\n * Variable: constrainRelativeChildren\n * \n * Specifies if child cells with relative geometries should be constrained\n * inside the parent bounds, if <constrainChildren> is true, and/or the\n * <maximumGraphBounds>. Default is false.\n */\nmxGraph.prototype.constrainRelativeChildren = false;\n\n/**\n * Variable: extendParents\n * \n * Specifies if a parent should contain the child bounds after a resize of\n * the child. Default is true. This has precedence over <constrainChildren>.\n */\nmxGraph.prototype.extendParents = true;\n\n/**\n * Variable: extendParentsOnAdd\n * \n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is true.\n */\nmxGraph.prototype.extendParentsOnAdd = true;\n\n/**\n * Variable: extendParentsOnAdd\n * \n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is false for backwards compatiblity.\n */\nmxGraph.prototype.extendParentsOnMove = false;\n\n/**\n * Variable: recursiveResize\n * \n * Specifies the return value for <isRecursiveResize>. Default is\n * false for backwards compatiblity.\n */\nmxGraph.prototype.recursiveResize = false;\n\n/**\n * Variable: collapseToPreferredSize\n * \n * Specifies if the cell size should be changed to the preferred size when\n * a cell is first collapsed. Default is true.\n */\nmxGraph.prototype.collapseToPreferredSize = true;\n\n/**\n * Variable: zoomFactor\n * \n * Specifies the factor used for <zoomIn> and <zoomOut>. Default is 1.2\n * (120%).\n */\nmxGraph.prototype.zoomFactor = 1.2;\n\n/**\n * Variable: keepSelectionVisibleOnZoom\n * \n * Specifies if the viewport should automatically contain the selection cells\n * after a zoom operation. Default is false.\n */\nmxGraph.prototype.keepSelectionVisibleOnZoom = false;\n\n/**\n * Variable: centerZoom\n * \n * Specifies if the zoom operations should go into the center of the actual\n * diagram rather than going from top, left. Default is true.\n */\nmxGraph.prototype.centerZoom = true;\n\n/**\n * Variable: resetViewOnRootChange\n * \n * Specifies if the scale and translate should be reset if the root changes in\n * the model. Default is true.\n */\nmxGraph.prototype.resetViewOnRootChange = true;\n\n/**\n * Variable: resetEdgesOnResize\n * \n * Specifies if edge control points should be reset after the resize of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnResize = false;\n\n/**\n * Variable: resetEdgesOnMove\n * \n * Specifies if edge control points should be reset after the move of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnMove = false;\n\n/**\n * Variable: resetEdgesOnConnect\n * \n * Specifies if edge control points should be reset after the the edge has been\n * reconnected. Default is true.\n */\nmxGraph.prototype.resetEdgesOnConnect = true;\n\n/**\n * Variable: allowLoops\n * \n * Specifies if loops (aka self-references) are allowed. Default is false.\n */\nmxGraph.prototype.allowLoops = false;\n\t\n/**\n * Variable: defaultLoopStyle\n * \n * <mxEdgeStyle> to be used for loops. This is a fallback for loops if the\n * <mxConstants.STYLE_LOOP> is undefined. Default is <mxEdgeStyle.Loop>.\n */\nmxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;\n\n/**\n * Variable: multigraph\n * \n * Specifies if multiple edges in the same direction between the same pair of\n * vertices are allowed. Default is true.\n */\nmxGraph.prototype.multigraph = true;\n\n/**\n * Variable: connectableEdges\n * \n * Specifies if edges are connectable. Default is false. This overrides the\n * connectable field in edges.\n */\nmxGraph.prototype.connectableEdges = false;\n\n/**\n * Variable: allowDanglingEdges\n * \n * Specifies if edges with disconnected terminals are allowed in the graph.\n * Default is true.\n */\nmxGraph.prototype.allowDanglingEdges = true;\n\n/**\n * Variable: cloneInvalidEdges\n * \n * Specifies if edges that are cloned should be validated and only inserted\n * if they are valid. Default is true.\n */\nmxGraph.prototype.cloneInvalidEdges = false;\n\n/**\n * Variable: disconnectOnMove\n * \n * Specifies if edges should be disconnected from their terminals when they\n * are moved. Default is true.\n */\nmxGraph.prototype.disconnectOnMove = true;\n\n/**\n * Variable: labelsVisible\n * \n * Specifies if labels should be visible. This is used in <getLabel>. Default\n * is true.\n */\nmxGraph.prototype.labelsVisible = true;\n\t\n/**\n * Variable: htmlLabels\n * \n * Specifies the return value for <isHtmlLabel>. Default is false.\n */\nmxGraph.prototype.htmlLabels = false;\n\n/**\n * Variable: swimlaneSelectionEnabled\n * \n * Specifies if swimlanes should be selectable via the content if the\n * mouse is released. Default is true.\n */\nmxGraph.prototype.swimlaneSelectionEnabled = true;\n\n/**\n * Variable: swimlaneNesting\n * \n * Specifies if nesting of swimlanes is allowed. Default is true.\n */\nmxGraph.prototype.swimlaneNesting = true;\n\t\n/**\n * Variable: swimlaneIndicatorColorAttribute\n * \n * The attribute used to find the color for the indicator if the indicator\n * color is set to 'swimlane'. Default is <mxConstants.STYLE_FILLCOLOR>.\n */\nmxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;\n\n/**\n * Variable: imageBundles\n * \n * Holds the list of image bundles.\n */\nmxGraph.prototype.imageBundles = null;\n\n/**\n * Variable: minFitScale\n * \n * Specifies the minimum scale to be applied in <fit>. Default is 0.1. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.minFitScale = 0.1;\n\n/**\n * Variable: maxFitScale\n * \n * Specifies the maximum scale to be applied in <fit>. Default is 8. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.maxFitScale = 8;\n\n/**\n * Variable: panDx\n * \n * Current horizontal panning value. Default is 0.\n */\nmxGraph.prototype.panDx = 0;\n\n/**\n * Variable: panDy\n * \n * Current vertical panning value. Default is 0.\n */\nmxGraph.prototype.panDy = 0;\n\n/**\n * Variable: collapsedImage\n * \n * Specifies the <mxImage> to indicate a collapsed state.\n * Default value is mxClient.imageBasePath + '/collapsed.gif'\n */\nmxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + '/collapsed.gif', 9, 9);\n\n/**\n * Variable: expandedImage\n * \n * Specifies the <mxImage> to indicate a expanded state.\n * Default value is mxClient.imageBasePath + '/expanded.gif'\n */\nmxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + '/expanded.gif', 9, 9);\n\n/**\n * Variable: warningImage\n * \n * Specifies the <mxImage> for the image to be used to display a warning\n * overlay. See <setCellWarning>. Default value is mxClient.imageBasePath +\n * '/warning'.  The extension for the image depends on the platform. It is\n * '.png' on the Mac and '.gif' on all other platforms.\n */\nmxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + '/warning'+\n\t((mxClient.IS_MAC) ? '.png' : '.gif'), 16, 16);\n\n/**\n * Variable: alreadyConnectedResource\n * \n * Specifies the resource key for the error message to be displayed in\n * non-multigraphs when two vertices are already connected. If the resource\n * for this key does not exist then the value is used as the error message.\n * Default is 'alreadyConnected'.\n */\nmxGraph.prototype.alreadyConnectedResource = (mxClient.language != 'none') ? 'alreadyConnected' : '';\n\n/**\n * Variable: containsValidationErrorsResource\n * \n * Specifies the resource key for the warning message to be displayed when\n * a collapsed cell contains validation errors. If the resource for this\n * key does not exist then the value is used as the warning message.\n * Default is 'containsValidationErrors'.\n */\nmxGraph.prototype.containsValidationErrorsResource = (mxClient.language != 'none') ? 'containsValidationErrors' : '';\n\n/**\n * Variable: collapseExpandResource\n * \n * Specifies the resource key for the tooltip on the collapse/expand icon.\n * If the resource for this key does not exist then the value is used as\n * the tooltip. Default is 'collapse-expand'.\n */\nmxGraph.prototype.collapseExpandResource = (mxClient.language != 'none') ? 'collapse-expand' : '';\n\n/**\n * Function: init\n * \n * Initializes the <container> and creates the respective datastructures.\n * \n * Parameters:\n * \n * container - DOM node that will contain the graph display.\n */\nmxGraph.prototype.init = function(container)\n{\n\tthis.container = container;\n\t\n\t// Initializes the in-place editor\n\tthis.cellEditor = this.createCellEditor();\t\n\n\t// Initializes the container using the view\n\tthis.view.init();\n\t\n\t// Updates the size of the container for the current graph\n\tthis.sizeDidChange();\n\t\n\t// Hides tooltips and resets tooltip timer if mouse leaves container\n\tmxEvent.addListener(container, 'mouseleave', mxUtils.bind(this, function()\n\t{\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\t}));\n\n\t// Automatic deallocation of memory\n\tif (mxClient.IS_IE)\n\t{\n\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.destroy();\n\t\t}));\n\t\t\n\t\t// Disable shift-click for text\n\t\tmxEvent.addListener(container, 'selectstart',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\treturn this.isEditing() || (!this.isMouseDown && !mxEvent.isShiftDown(evt));\n\t\t\t})\n\t\t);\n\t}\n\t\n\t// Workaround for missing last shape and connect preview in IE8 standards\n\t// mode if no initial graph displayed or no label for shape defined\n\tif (document.documentMode == 8)\n\t{\n\t\tcontainer.insertAdjacentHTML('beforeend', '<' + mxClient.VML_PREFIX + ':group' +\n\t\t\t' style=\"DISPLAY: none;\"></' + mxClient.VML_PREFIX + ':group>');\n\t}\n};\n\n/**\n * Function: createHandlers\n * \n * Creates the tooltip-, panning-, connection- and graph-handler (in this\n * order). This is called in the constructor before <init> is called.\n */\nmxGraph.prototype.createHandlers = function()\n{\n\tthis.tooltipHandler = this.createTooltipHandler();\n\tthis.tooltipHandler.setEnabled(false);\n\tthis.selectionCellsHandler = this.createSelectionCellsHandler();\n\tthis.connectionHandler = this.createConnectionHandler();\n\tthis.connectionHandler.setEnabled(false);\n\tthis.graphHandler = this.createGraphHandler();\n\tthis.panningHandler = this.createPanningHandler();\n\tthis.panningHandler.panningEnabled = false;\n\tthis.popupMenuHandler = this.createPopupMenuHandler();\n};\n\n/**\n * Function: createTooltipHandler\n * \n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createTooltipHandler = function()\n{\n\treturn new mxTooltipHandler(this);\n};\n\n/**\n * Function: createSelectionCellsHandler\n * \n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createSelectionCellsHandler = function()\n{\n\treturn new mxSelectionCellsHandler(this);\n};\n\n/**\n * Function: createConnectionHandler\n * \n * Creates and returns a new <mxConnectionHandler> to be used in this graph.\n */\nmxGraph.prototype.createConnectionHandler = function()\n{\n\treturn new mxConnectionHandler(this);\n};\n\n/**\n * Function: createGraphHandler\n * \n * Creates and returns a new <mxGraphHandler> to be used in this graph.\n */\nmxGraph.prototype.createGraphHandler = function()\n{\n\treturn new mxGraphHandler(this);\n};\n\n/**\n * Function: createPanningHandler\n * \n * Creates and returns a new <mxPanningHandler> to be used in this graph.\n */\nmxGraph.prototype.createPanningHandler = function()\n{\n\treturn new mxPanningHandler(this);\n};\n\n/**\n * Function: createPopupMenuHandler\n * \n * Creates and returns a new <mxPopupMenuHandler> to be used in this graph.\n */\nmxGraph.prototype.createPopupMenuHandler = function()\n{\n\treturn new mxPopupMenuHandler(this);\n};\n\n/**\n * Function: createSelectionModel\n * \n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createSelectionModel = function()\n{\n\treturn new mxGraphSelectionModel(this);\n};\n\n/**\n * Function: createStylesheet\n * \n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createStylesheet = function()\n{\n\treturn new mxStylesheet();\n};\n\n/**\n * Function: createGraphView\n * \n * Creates a new <mxGraphView> to be used in this graph.\n */\nmxGraph.prototype.createGraphView = function()\n{\n\treturn new mxGraphView(this);\n};\n \n/**\n * Function: createCellRenderer\n * \n * Creates a new <mxCellRenderer> to be used in this graph.\n */\nmxGraph.prototype.createCellRenderer = function()\n{\n\treturn new mxCellRenderer();\n};\n\n/**\n * Function: createCellEditor\n * \n * Creates a new <mxCellEditor> to be used in this graph.\n */\nmxGraph.prototype.createCellEditor = function()\n{\n\treturn new mxCellEditor(this);\n};\n\n/**\n * Function: getModel\n * \n * Returns the <mxGraphModel> that contains the cells.\n */\nmxGraph.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: getView\n * \n * Returns the <mxGraphView> that contains the <mxCellStates>.\n */\nmxGraph.prototype.getView = function()\n{\n\treturn this.view;\n};\n\n/**\n * Function: getStylesheet\n * \n * Returns the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.getStylesheet = function()\n{\n\treturn this.stylesheet;\n};\n\n/**\n * Function: setStylesheet\n * \n * Sets the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.setStylesheet = function(stylesheet)\n{\n\tthis.stylesheet = stylesheet;\n};\n\n/**\n * Function: getSelectionModel\n * \n * Returns the <mxGraphSelectionModel> that contains the selection.\n */\nmxGraph.prototype.getSelectionModel = function()\n{\n\treturn this.selectionModel;\n};\n\n/**\n * Function: setSelectionModel\n * \n * Sets the <mxSelectionModel> that contains the selection.\n */\nmxGraph.prototype.setSelectionModel = function(selectionModel)\n{\n\tthis.selectionModel = selectionModel;\n};\n\n/**\n * Function: getSelectionCellsForChanges\n * \n * Returns the cells to be selected for the given array of changes.\n */\nmxGraph.prototype.getSelectionCellsForChanges = function(changes)\n{\n\tvar dict = new mxDictionary();\n\tvar cells = [];\n\t\n\tvar addCell = mxUtils.bind(this, function(cell)\n\t{\n\t\tif (!dict.get(cell) && this.model.contains(cell))\n\t\t{\n\t\t\tif (this.model.isEdge(cell) || this.model.isVertex(cell))\n\t\t\t{\n\t\t\t\tdict.put(cell, true);\n\t\t\t\tcells.push(cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t{\n\t\t\t\t\taddCell(this.model.getChildAt(cell, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\t\t\n\t\tif (change.constructor != mxRootChange)\n\t\t{\n\t\t\tvar cell = null;\n\n\t\t\tif (change instanceof mxChildChange)\n\t\t\t{\n\t\t\t\tcell = change.child;\n\t\t\t}\n\t\t\telse if (change.cell != null && change.cell instanceof mxCell)\n\t\t\t{\n\t\t\t\tcell = change.cell;\n\t\t\t}\n\t\t\t\n\t\t\tif (cell != null)\n\t\t\t{\n\t\t\t\taddCell(cell);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: graphModelChanged\n * \n * Called when the graph model changes. Invokes <processChange> on each\n * item of the given array to update the view accordingly.\n * \n * Parameters:\n * \n * changes - Array that contains the individual changes.\n */\nmxGraph.prototype.graphModelChanged = function(changes)\n{\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tthis.processChange(changes[i]);\n\t}\n\t\n\tthis.removeSelectionCells(this.getRemovedCellsForChanges(changes));\n\tthis.view.validate();\n\tthis.sizeDidChange();\n};\n\n/**\n * Function: getRemovedCellsForChanges\n * \n * Returns the cells that have been removed from the model.\n */\nmxGraph.prototype.getRemovedCellsForChanges = function(changes)\n{\n\tvar result = [];\n\t\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\t\t\n\t\t// Resets the view settings, removes all cells and clears\n\t\t// the selection if the root changes.\n\t\tif (change instanceof mxRootChange)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse if (change instanceof mxChildChange)\n\t\t{\n\t\t\tif (this.model.contains(change.previous) && !this.model.contains(change.parent))\n\t\t\t{\n\t\t\t\tresult = result.concat(this.model.getDescendants(change.child));\n\t\t\t}\n\t\t}\n\t\telse if (change instanceof mxVisibleChange)\n\t\t{\n\t\t\tresult = result.concat(this.model.getDescendants(change.cell));\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: processChange\n * \n * Processes the given change and invalidates the respective cached data\n * in <view>. This fires a <root> event if the root has changed in the\n * model.\n * \n * Parameters:\n * \n * change - Object that represents the change on the model.\n */\nmxGraph.prototype.processChange = function(change)\n{\n\t// Resets the view settings, removes all cells and clears\n\t// the selection if the root changes.\n\tif (change instanceof mxRootChange)\n\t{\n\t\tthis.clearSelection();\n\t\tthis.setDefaultParent(null);\n\t\tthis.removeStateForCell(change.previous);\n\t\t\n\t\tif (this.resetViewOnRootChange)\n\t\t{\n\t\t\tthis.view.scale = 1;\n\t\t\tthis.view.translate.x = 0;\n\t\t\tthis.view.translate.y = 0;\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t}\n\t\n\t// Adds or removes a child to the view by online invaliding\n\t// the minimal required portions of the cache, namely, the\n\t// old and new parent and the child.\n\telse if (change instanceof mxChildChange)\n\t{\n\t\tvar newParent = this.model.getParent(change.child);\n\t\tthis.view.invalidate(change.child, true, true);\n\t\t\n\t\tif (!this.model.contains(newParent) || this.isCellCollapsed(newParent))\n\t\t{\n\t\t\tthis.view.invalidate(change.child, true, true);\n\t\t\tthis.removeStateForCell(change.child);\n\t\t\t\n\t\t\t// Handles special case of current root of view being removed\n\t\t\tif (this.view.currentRoot == change.child)\n\t\t\t{\n\t\t\t\tthis.home();\n\t\t\t}\n\t\t}\n \n\t\tif (newParent != change.previous)\n\t\t{\n\t\t\t// Refreshes the collapse/expand icons on the parents\n\t\t\tif (newParent != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(newParent, false, false);\n\t\t\t}\n\t\t\t\n\t\t\tif (change.previous != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(change.previous, false, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handles two special cases where the shape does not need to be\n\t// recreated from scratch, it only needs to be invalidated.\n\telse if (change instanceof mxTerminalChange || change instanceof mxGeometryChange)\n\t{\n\t\t// Checks if the geometry has changed to avoid unnessecary revalidation\n\t\tif (change instanceof mxTerminalChange || ((change.previous == null && change.geometry != null) ||\n\t\t\t(change.previous != null && !change.previous.equals(change.geometry))))\n\t\t{\n\t\t\tthis.view.invalidate(change.cell);\n\t\t}\n\t}\n\n\t// Handles two special cases where only the shape, but no\n\t// descendants need to be recreated\n\telse if (change instanceof mxValueChange)\n\t{\n\t\tthis.view.invalidate(change.cell, false, false);\n\t}\n\t\n\t// Requires a new mxShape in JavaScript\n\telse if (change instanceof mxStyleChange)\n\t{\n\t\tthis.view.invalidate(change.cell, true, true);\n\t\tvar state = this.view.getState(change.cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tstate.style = null;\n\t\t}\n\t}\n\t\n\t// Removes the state from the cache by default\n\telse if (change.cell != null && change.cell instanceof mxCell)\n\t{\n\t\tthis.removeStateForCell(change.cell);\n\t}\n};\n\n/**\n * Function: removeStateForCell\n * \n * Removes all cached information for the given cell and its descendants.\n * This is called when a cell was removed from the model.\n * \n * Paramters:\n * \n * cell - <mxCell> that was removed from the model.\n */\nmxGraph.prototype.removeStateForCell = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.removeStateForCell(this.model.getChildAt(cell, i));\n\t}\n\n\tthis.view.invalidate(cell, false, true);\n\tthis.view.removeState(cell);\n};\n\n/**\n * Group: Overlays\n */\n\n/**\n * Function: addCellOverlay\n * \n * Adds an <mxCellOverlay> for the specified cell. This method fires an\n * <addoverlay> event and returns the new <mxCellOverlay>.\n * \n * Parameters:\n * \n * cell - <mxCell> to add the overlay for.\n * overlay - <mxCellOverlay> to be added for the cell.\n */\nmxGraph.prototype.addCellOverlay = function(cell, overlay)\n{\n\tif (cell.overlays == null)\n\t{\n\t\tcell.overlays = [];\n\t}\n\t\n\tcell.overlays.push(overlay);\n\n\tvar state = this.view.getState(cell);\n\n\t// Immediately updates the cell display if the state exists\n\tif (state != null)\n\t{\n\t\tthis.cellRenderer.redraw(state);\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY,\n\t\t\t'cell', cell, 'overlay', overlay));\n\t\n\treturn overlay;\n};\n\n/**\n * Function: getCellOverlays\n * \n * Returns the array of <mxCellOverlays> for the given cell or null, if\n * no overlays are defined.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlays should be returned.\n */\nmxGraph.prototype.getCellOverlays = function(cell)\n{\n\treturn cell.overlays;\n};\n\n/**\n * Function: removeCellOverlay\n * \n * Removes and returns the given <mxCellOverlay> from the given cell. This\n * method fires a <removeoverlay> event. If no overlay is given, then all\n * overlays are removed using <removeOverlays>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlay should be removed.\n * overlay - Optional <mxCellOverlay> to be removed.\n */\nmxGraph.prototype.removeCellOverlay = function(cell, overlay)\n{\n\tif (overlay == null)\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\telse\n\t{\n\t\tvar index = mxUtils.indexOf(cell.overlays, overlay);\n\t\t\n\t\tif (index >= 0)\n\t\t{\n\t\t\tcell.overlays.splice(index, 1);\n\t\t\t\n\t\t\tif (cell.overlays.length == 0)\n\t\t\t{\n\t\t\t\tcell.overlays = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Immediately updates the cell display if the state exists\n\t\t\tvar state = this.view.getState(cell);\n\t\t\t\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\tthis.cellRenderer.redraw(state);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlay));\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\toverlay = null;\n\t\t}\n\t}\n\t\n\treturn overlay;\n};\n\n/**\n * Function: removeCellOverlays\n * \n * Removes all <mxCellOverlays> from the given cell. This method\n * fires a <removeoverlay> event for each <mxCellOverlay> and returns\n * the array of <mxCellOverlays> that was removed from the cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlays should be removed\n */\nmxGraph.prototype.removeCellOverlays = function(cell)\n{\n\tvar overlays = cell.overlays;\n\t\n\tif (overlays != null)\n\t{\n\t\tcell.overlays = null;\n\t\t\n\t\t// Immediately updates the cell display if the state exists\n\t\tvar state = this.view.getState(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.cellRenderer.redraw(state);\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < overlays.length; i++)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlays[i]));\n\t\t}\n\t}\n\t\n\treturn overlays;\n};\n\n/**\n * Function: clearCellOverlays\n * \n * Removes all <mxCellOverlays> in the graph for the given cell and all its\n * descendants. If no cell is specified then all overlays are removed from\n * the graph. This implementation uses <removeCellOverlays> to remove the\n * overlays from the individual cells.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> that represents the root of the subtree to\n * remove the overlays from. Default is the root in the model.\n */\nmxGraph.prototype.clearCellOverlays = function(cell)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tthis.removeCellOverlays(cell);\n\t\n\t// Recursively removes all overlays from the children\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\t\tthis.clearCellOverlays(child); // recurse\n\t}\n};\n\n/**\n * Function: setCellWarning\n * \n * Creates an overlay for the given cell using the warning and image or\n * <warningImage> and returns the new <mxCellOverlay>. The warning is\n * displayed as a tooltip in a red font and may contain HTML markup. If\n * the warning is null or a zero length string, then all overlays are\n * removed from the cell.\n * \n * Example:\n * \n * (code)\n * graph.setCellWarning(cell, '<b>Warning:</b>: Hello, World!');\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose warning should be set.\n * warning - String that represents the warning to be displayed.\n * img - Optional <mxImage> to be used for the overlay. Default is\n * <warningImage>.\n * isSelect - Optional boolean indicating if a click on the overlay\n * should select the corresponding cell. Default is false.\n */\nmxGraph.prototype.setCellWarning = function(cell, warning, img, isSelect)\n{\n\tif (warning != null && warning.length > 0)\n\t{\n\t\timg = (img != null) ? img : this.warningImage;\n\t\t\n\t\t// Creates the overlay with the image and warning\n\t\tvar overlay = new mxCellOverlay(img,\n\t\t\t'<font color=red>'+warning+'</font>');\n\t\t\n\t\t// Adds a handler for single mouseclicks to select the cell\n\t\tif (isSelect)\n\t\t{\n\t\t\toverlay.addListener(mxEvent.CLICK,\n\t\t\t\tmxUtils.bind(this, function(sender, evt)\n\t\t\t\t{\n\t\t\t\t\tif (this.isEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setSelectionCell(cell);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Sets and returns the overlay in the graph\n\t\treturn this.addCellOverlay(cell, overlay);\n\t}\n\telse\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Group: In-place editing\n */\n\n/**\n * Function: startEditing\n * \n * Calls <startEditingAtCell> using the given cell or the first selection\n * cell.\n * \n * Parameters:\n * \n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditing = function(evt)\n{\n\tthis.startEditingAtCell(null, evt);\n};\n\n/**\n * Function: startEditingAtCell\n * \n * Fires a <startEditing> event and invokes <mxCellEditor.startEditing>\n * on <editor>. After editing was started, a <editingStarted> event is\n * fired.\n * \n * Parameters:\n * \n * cell - <mxCell> to start the in-place editor for.\n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditingAtCell = function(cell, evt)\n{\n\tif (evt == null || !mxEvent.isMultiTouchEvent(evt))\n\t{\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.getSelectionCell();\n\t\t\t\n\t\t\tif (cell != null && !this.isCellEditable(cell))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDITING,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t\tthis.cellEditor.startEditing(cell, evt);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t}\n\t}\n};\n\n/**\n * Function: getEditingValue\n * \n * Returns the initial value for in-place editing. This implementation\n * returns <convertValueToString> for the given cell. If this function is\n * overridden, then <mxGraphModel.valueForCellChanged> should take care\n * of correctly storing the actual new value inside the user object.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the initial editing value should be returned.\n * evt - Optional mouse event that triggered the editor.\n */\nmxGraph.prototype.getEditingValue = function(cell, evt)\n{\n\treturn this.convertValueToString(cell);\n};\n\n/**\n * Function: stopEditing\n * \n * Stops the current editing  and fires a <editingStopped> event.\n * \n * Parameters:\n * \n * cancel - Boolean that specifies if the current editing value\n * should be stored.\n */\nmxGraph.prototype.stopEditing = function(cancel)\n{\n\tthis.cellEditor.stopEditing(cancel);\n\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, 'cancel', cancel));\n};\n\n/**\n * Function: labelChanged\n * \n * Sets the label of the specified cell to the given value using\n * <cellLabelChanged> and fires <mxEvent.LABEL_CHANGED> while the\n * transaction is in progress. Returns the cell whose label was changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * evt - Optional event that triggered the change.\n */\nmxGraph.prototype.labelChanged = function(cell, value, evt)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar old = cell.value;\n\t\tthis.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n\t\tthis.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED,\n\t\t\t'cell', cell, 'value', value, 'old', old, 'event', evt));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellLabelChanged\n * \n * Sets the new label for a cell. If autoSize is true then\n * <cellSizeUpdated> will be called.\n * \n * In the following example, the function is extended to map changes to\n * attributes in an XML node, as shown in <convertValueToString>.\n * Alternatively, the handling of this can be implemented as shown in\n * <mxGraphModel.valueForCellChanged> without the need to clone the\n * user object.\n * \n * (code)\n * var graphCellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n * \t// Cloned for correct undo/redo\n * \tvar elt = cell.value.cloneNode(true);\n *  elt.setAttribute('label', newValue);\n *  \n *  newValue = elt;\n *  graphCellLabelChanged.apply(this, arguments);\n * };\n * (end) \n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * autoSize - Boolean that specifies if <cellSizeUpdated> should be called.\n */\nmxGraph.prototype.cellLabelChanged = function(cell, value, autoSize)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.model.setValue(cell, value);\n\t\t\n\t\tif (autoSize)\n\t\t{\n\t\t\tthis.cellSizeUpdated(cell, false);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n};\n\n/**\n * Group: Event processing\n */\n\n/**\n * Function: escape\n * \n * Processes an escape keystroke.\n * \n * Parameters:\n * \n * evt - Mouseevent that represents the keystroke.\n */\nmxGraph.prototype.escape = function(evt)\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', evt));\n};\n\n/**\n * Function: click\n * \n * Processes a singleclick on an optional cell and fires a <click> event.\n * The click event is fired initially. If the graph is enabled and the\n * event has not been consumed, then the cell is selected using\n * <selectCellForEvent> or the selection is cleared using\n * <clearSelection>. The events consumed state is set to true if the\n * corresponding <mxMouseEvent> has been consumed.\n *\n * To handle a click event, use the following code.\n * \n * (code)\n * graph.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var e = evt.getProperty('event'); // mouse event\n *   var cell = evt.getProperty('cell'); // cell may be null\n *   \n *   if (cell != null)\n *   {\n *     // Do something useful with cell and consume the event\n *     evt.consume();\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * me - <mxMouseEvent> that represents the single click.\n */\nmxGraph.prototype.click = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar cell = me.getCell();\n\tvar mxe = new mxEventObject(mxEvent.CLICK, 'event', evt, 'cell', cell);\n\t\n\tif (me.isConsumed())\n\t{\n\t\tmxe.consume();\n\t}\n\t\n\tthis.fireEvent(mxe);\n\t\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n\t{\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isTransparentClickEvent(evt))\n\t\t\t{\n\t\t\t\tvar active = false;\n\t\t\t\t\n\t\t\t\tvar tmp = this.getCellAt(me.graphX, me.graphY, null, null, null, mxUtils.bind(this, function(state)\n\t\t\t\t{\n\t\t\t\t\tvar selected = this.isCellSelected(state.cell);\n\t\t\t\t\tactive = active || selected;\n\t\t\t\t\t\n\t\t\t\t\treturn !active || selected;\n\t\t\t\t}));\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tcell = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.selectCellForEvent(cell, evt);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar swimlane = null;\n\t\t\t\n\t\t\tif (this.isSwimlaneSelectionEnabled())\n\t\t\t{\n\t\t\t\t// Gets the swimlane at the location (includes\n\t\t\t\t// content area of swimlanes)\n\t\t\t\tswimlane = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\n\t\t\t// Selects the swimlane and consumes the event\n\t\t\tif (swimlane != null)\n\t\t\t{\n\t\t\t\tthis.selectCellForEvent(swimlane, evt);\n\t\t\t}\n\t\t\t\n\t\t\t// Ignores the event if the control key is pressed\n\t\t\telse if (!this.isToggleEvent(evt))\n\t\t\t{\n\t\t\t\tthis.clearSelection();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: dblClick\n * \n * Processes a doubleclick on an optional cell and fires a <dblclick>\n * event. The event is fired initially. If the graph is enabled and the\n * event has not been consumed, then <edit> is called with the given\n * cell. The event is ignored if no cell was specified.\n *\n * Example for overriding this method.\n *\n * (code)\n * graph.dblClick = function(evt, cell)\n * {\n *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n *   this.fireEvent(mxe);\n *   \n *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n *   {\n * \t   mxUtils.alert('Hello, World!');\n *     mxe.consume();\n *   }\n * }\n * (end)\n * \n * Example listener for this event.\n * \n * (code)\n * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   // do something with the cell and consume the\n *   // event to prevent in-place editing from start\n * });\n * (end) \n * \n * Parameters:\n * \n * evt - Mouseevent that represents the doubleclick.\n * cell - Optional <mxCell> under the mousepointer.\n */\nmxGraph.prototype.dblClick = function(evt, cell)\n{\n\tvar mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n\tthis.fireEvent(mxe);\n\t\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() &&\n\t\tcell != null && this.isCellEditable(cell) && !this.isEditing(cell))\n\t{\n\t\tthis.startEditingAtCell(cell, evt);\n\t\tmxEvent.consume(evt);\n\t}\n};\n\n/**\n * Function: tapAndHold\n * \n * Handles the <mxMouseEvent> by highlighting the <mxCellState>.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> that represents the touch event.\n * state - Optional <mxCellState> that is associated with the event.\n */\nmxGraph.prototype.tapAndHold = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar mxe = new mxEventObject(mxEvent.TAP_AND_HOLD, 'event', evt, 'cell', me.getCell());\n\n\t// LATER: Check if event should be consumed if me is consumed\n\tthis.fireEvent(mxe);\n\n\tif (mxe.isConsumed())\n\t{\n\t\t// Resets the state of the panning handler\n\t\tthis.panningHandler.panningTrigger = false;\n\t}\n\t\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled())\n\t{\n\t\tvar state = this.view.getState(this.connectionHandler.marker.getCell(me));\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;\n\t\t\tthis.connectionHandler.marker.markedState = state;\n\t\t\tthis.connectionHandler.marker.mark();\n\t\t\t\n\t\t\tthis.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\tthis.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);\n\t\t\tthis.connectionHandler.previous = state;\n\t\t\tthis.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, 'state', this.connectionHandler.previous));\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollPointToVisible\n * \n * Scrolls the graph to the given point, extending the graph container if\n * specified.\n */\nmxGraph.prototype.scrollPointToVisible = function(x, y, extend, border)\n{\n\tif (!this.timerAutoScroll && (this.ignoreScrollbars || mxUtils.hasScrollbars(this.container)))\n\t{\n\t\tvar c = this.container;\n\t\tborder = (border != null) ? border : 20;\n\t\t\n\t\tif (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth &&\n\t\t\ty <= c.scrollTop + c.clientHeight)\n\t\t{\n\t\t\tvar dx = c.scrollLeft + c.clientWidth - x;\n\t\t\t\n\t\t\tif (dx < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollLeft;\n\t\t\t\tc.scrollLeft += border - dx;\n\n\t\t\t\t// Automatically extends the canvas size to the bottom, right\n\t\t\t\t// if the event is outside of the canvas and the edge of the\n\t\t\t\t// canvas has been reached. Notes: Needs fix for IE.\n\t\t\t\tif (extend && old == c.scrollLeft)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar width = this.container.scrollWidth + border - dx;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc.scrollLeft += border - dx;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = x - c.scrollLeft;\n\t\t\t\t\n\t\t\t\tif (dx < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft -= border - dx;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar dy = c.scrollTop + c.clientHeight - y;\n\t\t\t\n\t\t\tif (dy < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollTop;\n\t\t\t\tc.scrollTop += border - dy;\n\n\t\t\t\tif (old == c.scrollTop && extend)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar height = this.container.scrollHeight + border - dy;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.height = height + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.height = height + 'px';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc.scrollTop += border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = y - c.scrollTop;\n\t\t\t\t\n\t\t\t\tif (dy < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop -= border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (this.allowAutoPanning && !this.panningHandler.isActive())\n\t{\n\t\tif (this.panningManager == null)\n\t\t{\n\t\t\tthis.panningManager = this.createPanningManager();\n\t\t}\n\n\t\tthis.panningManager.panTo(x + this.panDx, y + this.panDy);\n\t}\n};\n\n\n/**\n * Function: createPanningManager\n * \n * Creates and returns an <mxPanningManager>.\n */\nmxGraph.prototype.createPanningManager = function()\n{\n\treturn new mxPanningManager(this);\n};\n\n/**\n * Function: getBorderSizes\n * \n * Returns the size of the border and padding on all four sides of the\n * container. The left, top, right and bottom borders are stored in the x, y,\n * width and height of the returned <mxRectangle>, respectively.\n */\nmxGraph.prototype.getBorderSizes = function()\n{\n\tvar css = mxUtils.getCurrentStyle(this.container);\n\t\n\treturn new mxRectangle(mxUtils.parseCssNumber(css.paddingLeft) +\n\t\t\t((css.borderLeftStyle != 'none') ? mxUtils.parseCssNumber(css.borderLeftWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingTop) +\n\t\t\t((css.borderTopStyle != 'none') ? mxUtils.parseCssNumber(css.borderTopWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingRight) +\n\t\t\t((css.borderRightStyle != 'none') ? mxUtils.parseCssNumber(css.borderRightWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingBottom) +\n\t\t\t((css.borderBottomStyle != 'none') ? mxUtils.parseCssNumber(css.borderBottomWidth) : 0));\n};\n\n/**\n * Function: getPreferredPageSize\n * \n * Returns the preferred size of the background page if <preferPageSize> is true.\n */\nmxGraph.prototype.getPreferredPageSize = function(bounds, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = this.pageScale;\n\tvar page = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));\n\t\n\tvar hCount = (this.pageBreaksVisible) ? Math.ceil(width / page.width) : 1;\n\tvar vCount = (this.pageBreaksVisible) ? Math.ceil(height / page.height) : 1;\n\t\n\treturn new mxRectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);\n};\n\n/**\n * Function: fit\n *\n * Scales the graph such that the complete diagram fits into <container> and\n * returns the current scale in the view. To fit an initial graph prior to\n * rendering, set <mxGraphView.rendering> to false prior to changing the model\n * and execute the following after changing the model.\n * \n * (code)\n * graph.fit();\n * graph.view.rendering = true;\n * graph.refresh();\n * (end)\n * \n * To fit and center the graph, the following code can be used.\n * \n * (code)\n * var margin = 2;\n * var max = 3;\n * \n * var bounds = graph.getGraphBounds();\n * var cw = graph.container.clientWidth - margin;\n * var ch = graph.container.clientHeight - margin;\n * var w = bounds.width / graph.view.scale;\n * var h = bounds.height / graph.view.scale;\n * var s = Math.min(max, Math.min(cw / w, ch / h));\n * \n * graph.view.scaleAndTranslate(s,\n *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\n *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\n * (end)\n * \n * Parameters:\n * \n * border - Optional number that specifies the border. Default is <border>.\n * keepOrigin - Optional boolean that specifies if the translate should be\n * changed. Default is false.\n * margin - Optional margin in pixels. Default is 0.\n * enabled - Optional boolean that specifies if the scale should be set or\n * just returned. Default is true.\n * ignoreWidth - Optional boolean that specifies if the width should be\n * ignored. Default is false.\n * ignoreHeight - Optional boolean that specifies if the height should be\n * ignored. Default is false.\n * maxHeight - Optional maximum height.\n */\nmxGraph.prototype.fit = function(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight)\n{\n\tif (this.container != null)\n\t{\n\t\tborder = (border != null) ? border : this.getBorder();\n\t\tkeepOrigin = (keepOrigin != null) ? keepOrigin : false;\n\t\tmargin = (margin != null) ? margin : 0;\n\t\tenabled = (enabled != null) ? enabled : true;\n\t\tignoreWidth = (ignoreWidth != null) ? ignoreWidth : false;\n\t\tignoreHeight = (ignoreHeight != null) ? ignoreHeight : false;\n\t\t\n\t\t// Adds spacing and border from css\n\t\tvar cssBorder = this.getBorderSizes();\n\t\tvar w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;\n\t\tvar h1 = (maxHeight != null) ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;\n\t\tvar bounds = this.view.getGraphBounds();\n\t\t\n\t\tif (bounds.width > 0 && bounds.height > 0)\n\t\t{\n\t\t\tif (keepOrigin && bounds.x != null && bounds.y != null)\n\t\t\t{\n\t\t\t\tbounds = bounds.clone();\n\t\t\t\tbounds.width += bounds.x;\n\t\t\t\tbounds.height += bounds.y;\n\t\t\t\tbounds.x = 0;\n\t\t\t\tbounds.y = 0;\n\t\t\t}\n\t\t\t\n\t\t\t// LATER: Use unscaled bounding boxes to fix rounding errors\n\t\t\tvar s = this.view.scale;\n\t\t\tvar w2 = bounds.width / s;\n\t\t\tvar h2 = bounds.height / s;\n\t\t\t\n\t\t\t// Fits to the size of the background image if required\n\t\t\tif (this.backgroundImage != null)\n\t\t\t{\n\t\t\t\tw2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);\n\t\t\t\th2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);\n\t\t\t}\n\t\t\t\n\t\t\tvar b = ((keepOrigin) ? border : 2 * border) + margin + 1;\n\n\t\t\tw1 -= b;\n\t\t\th1 -= b;\n\t\t\t\n\t\t\tvar s2 = (((ignoreWidth) ? h1 / h2 : (ignoreHeight) ? w1 / w2 :\n\t\t\t\tMath.min(w1 / w2, h1 / h2)));\n\t\t\t\n\t\t\tif (this.minFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.max(s2, this.minFitScale);\n\t\t\t}\n\t\t\t\n\t\t\tif (this.maxFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.min(s2, this.maxFitScale);\n\t\t\t}\n\t\n\t\t\tif (enabled)\n\t\t\t{\n\t\t\t\tif (!keepOrigin)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.hasScrollbars(this.container))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar x0 = (bounds.x != null) ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;\n\t\t\t\t\t\tvar y0 = (bounds.y != null) ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;\n\n\t\t\t\t\t\tthis.view.scaleAndTranslate(s2, x0, y0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t\t\tvar b2 = this.getGraphBounds();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (b2.x != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollLeft = b2.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (b2.y != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollTop = b2.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.view.scale != s2)\n\t\t\t\t{\n\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn s2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.view.scale;\n};\n\n/**\n * Function: sizeDidChange\n * \n * Called when the size of the graph has changed. This implementation fires\n * a <size> event after updating the clipping region of the SVG element in\n * SVG-bases browsers.\n */\nmxGraph.prototype.sizeDidChange = function()\n{\n\tvar bounds = this.getGraphBounds();\n\t\n\tif (this.container != null)\n\t{\n\t\tvar border = this.getBorder();\n\t\t\n\t\tvar width = Math.max(0, bounds.x + bounds.width + 2 * border * this.view.scale);\n\t\tvar height = Math.max(0, bounds.y + bounds.height + 2 * border * this.view.scale);\n\t\t\n\t\tif (this.minimumContainerSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumContainerSize.width);\n\t\t\theight = Math.max(height, this.minimumContainerSize.height);\n\t\t}\n\n\t\tif (this.resizeContainer)\n\t\t{\n\t\t\tthis.doResizeContainer(width, height);\n\t\t}\n\n\t\tif (this.preferPageSize || (!mxClient.IS_IE && this.pageVisible))\n\t\t{\n\t\t\tvar size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n\t\t\t\n\t\t\tif (size != null)\n\t\t\t{\n\t\t\t\twidth = size.width * this.view.scale;\n\t\t\t\theight = size.height * this.view.scale;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.minimumGraphSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumGraphSize.width * this.view.scale);\n\t\t\theight = Math.max(height, this.minimumGraphSize.height * this.view.scale);\n\t\t}\n\n\t\twidth = Math.ceil(width);\n\t\theight = Math.ceil(height);\n\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\n\t\t\troot.style.minWidth = Math.max(1, width) + 'px';\n\t\t\troot.style.minHeight = Math.max(1, height) + 'px';\n\t\t\troot.style.width = '100%';\n\t\t\troot.style.height = '100%';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\t// Quirks mode does not support minWidth/-Height\n\t\t\t\tthis.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.view.canvas.style.minWidth = Math.max(1, width) + 'px';\n\t\t\t\tthis.view.canvas.style.minHeight = Math.max(1, height) + 'px';\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.updatePageBreaks(this.pageBreaksVisible, width, height);\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SIZE, 'bounds', bounds));\n};\n\n/**\n * Function: doResizeContainer\n * \n * Resizes the container for the given graph width and height.\n */\nmxGraph.prototype.doResizeContainer = function(width, height)\n{\n\tif (this.maximumContainerSize != null)\n\t{\n\t\twidth = Math.min(this.maximumContainerSize.width, width);\n\t\theight = Math.min(this.maximumContainerSize.height, height);\n\t}\n\n\tthis.container.style.width = Math.ceil(width) + 'px';\n\tthis.container.style.height = Math.ceil(height) + 'px';\n};\n\n/**\n * Function: updatePageBreaks\n * \n * Invokes from <sizeDidChange> to redraw the page breaks.\n * \n * Parameters:\n * \n * visible - Boolean that specifies if page breaks should be shown.\n * width - Specifies the width of the container in pixels.\n * height - Specifies the height of the container in pixels.\n */\nmxGraph.prototype.updatePageBreaks = function(visible, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = scale * this.pageScale;\n\tvar bounds = new mxRectangle(0, 0, fmt.width * ps, fmt.height * ps);\n\n\tvar gb = mxRectangle.fromRectangle(this.getGraphBounds());\n\tgb.width = Math.max(1, gb.width);\n\tgb.height = Math.max(1, gb.height);\n\t\n\tbounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n\tbounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n\t\n\tgb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n\tgb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n\t\n\t// Does not show page breaks if the scale is too small\n\tvisible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;\n\n\tvar horizontalCount = (visible) ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n\tvar verticalCount = (visible) ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n\tvar right = (verticalCount - 1) * bounds.width;\n\tvar bottom = (horizontalCount - 1) * bounds.height;\n\t\n\tif (this.horizontalPageBreaks == null && horizontalCount > 0)\n\t{\n\t\tthis.horizontalPageBreaks = [];\n\t}\n\n\tif (this.verticalPageBreaks == null && verticalCount > 0)\n\t{\n\t\tthis.verticalPageBreaks = [];\n\t}\n\t\n\tvar drawPageBreaks = mxUtils.bind(this, function(breaks)\n\t{\n\t\tif (breaks != null)\n\t\t{\n\t\t\tvar count = (breaks == this.horizontalPageBreaks) ? horizontalCount : verticalCount; \n\t\t\t\n\t\t\tfor (var i = 0; i <= count; i++)\n\t\t\t{\n\t\t\t\tvar pts = (breaks == this.horizontalPageBreaks) ?\n\t\t\t\t\t[new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),\n\t\t\t         new mxPoint(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))] :\n\t\t\t        [new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),\n\t\t\t         new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))];\n\n\t\t\t\tif (breaks[i] != null)\n\t\t\t\t{\n\t\t\t\t\tbreaks[i].points = pts;\n\t\t\t\t\tbreaks[i].redraw();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pageBreak = new mxPolyline(pts, this.pageBreakColor);\n\t\t\t\t\tpageBreak.dialect = this.dialect;\n\t\t\t\t\tpageBreak.pointerEvents = false;\n\t\t\t\t\tpageBreak.isDashed = this.pageBreakDashed;\n\t\t\t\t\tpageBreak.init(this.view.backgroundPane);\n\t\t\t\t\tpageBreak.redraw();\n\t\t\t\t\t\n\t\t\t\t\tbreaks[i] = pageBreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = count; i < breaks.length; i++)\n\t\t\t{\n\t\t\t\tbreaks[i].destroy();\n\t\t\t}\n\t\t\t\n\t\t\tbreaks.splice(count, breaks.length - count);\n\t\t}\n\t});\n\t\n\tdrawPageBreaks(this.horizontalPageBreaks);\n\tdrawPageBreaks(this.verticalPageBreaks);\n};\n\n/**\n * Group: Cell styles\n */\n\n/**\n * Function: getCellStyle\n * \n * Returns an array of key, value pairs representing the cell style for the\n * given cell. If no string is defined in the model that specifies the\n * style, then the default style for the cell is returned or <EMPTY_ARRAY>,\n * if not style can be found. Note: You should try and get the cell state\n * for the given cell and use the cached style in the state before using\n * this method.\n * \n * Parameters:\n * \n * cell - <mxCell> whose style should be returned as an array.\n */\nmxGraph.prototype.getCellStyle = function(cell)\n{\n\tvar stylename = this.model.getStyle(cell);\n\tvar style = null;\n\t\n\t// Gets the default style for the cell\n\tif (this.model.isEdge(cell))\n\t{\n\t\tstyle = this.stylesheet.getDefaultEdgeStyle();\n\t}\n\telse\n\t{\n\t\tstyle = this.stylesheet.getDefaultVertexStyle();\n\t}\n\t\n\t// Resolves the stylename using the above as the default\n\tif (stylename != null)\n\t{\n\t\tstyle = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));\n\t}\n\t\n\t// Returns a non-null value if no style can be found\n\tif (style == null)\n\t{\n\t\tstyle = mxGraph.prototype.EMPTY_ARRAY;\n\t}\n\t\n\treturn style;\n};\n\n/**\n * Function: postProcessCellStyle\n * \n * Tries to resolve the value for the image style in the image bundles and\n * turns short data URIs as defined in mxImageBundle to data URIs as\n * defined in RFC 2397 of the IETF.\n */\nmxGraph.prototype.postProcessCellStyle = function(style)\n{\n\tif (style != null)\n\t{\n\t\tvar key = style[mxConstants.STYLE_IMAGE];\n\t\tvar image = this.getImageFromBundles(key);\n\n\t\tif (image != null)\n\t\t{\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t\telse\n\t\t{\n\t\t\timage = key;\n\t\t}\n\t\t\n\t\t// Converts short data uris to normal data uris\n\t\tif (image != null && image.substring(0, 11) == 'data:image/')\n\t\t{\n\t\t\tif (image.substring(0, 20) == 'data:image/svg+xml,<')\n\t\t\t{\n\t\t\t\t// Required for FF and IE11\n\t\t\t\timage = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n\t\t\t}\n\t\t\telse if (image.substring(0, 22) != 'data:image/svg+xml,%3C')\n\t\t\t{\n\t\t\t\tvar comma = image.indexOf(',');\n\t\t\t\t\n\t\t\t\t// Adds base64 encoding prefix if needed\n\t\t\t\tif (comma > 0 && image.substring(comma - 7, comma + 1) != ';base64,')\n\t\t\t\t{\n\t\t\t\t\timage = image.substring(0, comma) + ';base64,'\n\t\t\t\t\t\t+ image.substring(comma + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t}\n\n\treturn style;\n};\n\n/**\n * Function: setCellStyle\n * \n * Sets the style of the specified cells. If no cells are given, then the\n * selection cells are changed.\n * \n * Parameters:\n * \n * style - String representing the new style of the cells.\n * cells - Optional array of <mxCells> to set the style for. Default is the\n * selection cells.\n */\nmxGraph.prototype.setCellStyle = function(style, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\t\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(cells[i], style);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: toggleCellStyle\n * \n * Toggles the boolean value for the given key in the style of the given cell\n * and returns the new value as 0 or 1. If no cell is specified then the\n * selection cell is used.\n * \n * Parameter:\n * \n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cell - Optional <mxCell> whose style should be modified. Default is\n * the selection cell.\n */\nmxGraph.prototype.toggleCellStyle = function(key, defaultValue, cell)\n{\n\tcell = cell || this.getSelectionCell();\n\t\n\treturn this.toggleCellStyles(key, defaultValue, [cell]);\n};\n\n/**\n * Function: toggleCellStyles\n * \n * Toggles the boolean value for the given key in the style of the given cells\n * and returns the new value as 0 or 1. If no cells are specified, then the\n * selection cells are used. For example, this can be used to toggle\n * <mxConstants.STYLE_ROUNDED> or any other style with a boolean value.\n * \n * Parameter:\n * \n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cells - Optional array of <mxCells> whose styles should be modified.\n * Default is the selection cells.\n */\nmxGraph.prototype.toggleCellStyles = function(key, defaultValue, cells)\n{\n\tdefaultValue = (defaultValue != null) ? defaultValue : false;\n\tcells = cells || this.getSelectionCells();\n\tvar value = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar state = this.view.getState(cells[0]);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cells[0]);\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tvalue = (mxUtils.getValue(style, key, defaultValue)) ? 0 : 1;\n\t\t\tthis.setCellStyles(key, value, cells);\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: setCellStyles\n * \n * Sets the key to value in the styles of the given cells. This will modify\n * the existing cell styles in-place and override any existing assignment\n * for the given key. If no cells are specified, then the selection cells\n * are changed. If no value is specified, then the respective key is\n * removed from the styles.\n * \n * Parameters:\n * \n * key - String representing the key to be assigned.\n * value - String representing the new value for the key.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyles = function(key, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\tmxUtils.setCellStyles(this.model, cells, key, value);\n};\n\n/**\n * Function: toggleCellStyleFlags\n * \n * Toggles the given bit for the given key in the styles of the specified\n * cells.\n * \n * Parameters:\n * \n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.toggleCellStyleFlags = function(key, flag, cells)\n{\n\tthis.setCellStyleFlags(key, flag, null, cells);\n};\n\n/**\n * Function: setCellStyleFlags\n * \n * Sets or toggles the given bit for the given key in the styles of the\n * specified cells.\n * \n * Parameters:\n * \n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * value - Boolean value to be used or null if the value should be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyleFlags = function(key, flag, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tif (value == null)\n\t\t{\n\t\t\tvar state = this.view.getState(cells[0]);\n\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cells[0]);\n\t\t\t\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tvar current = parseInt(style[key] || 0);\n\t\t\t\tvalue = !((current & flag) == flag);\n\t\t\t}\n\t\t}\n\n\t\tmxUtils.setCellStyleFlags(this.model, cells, key, flag, value);\n\t}\n};\n\n/**\n * Group: Cell alignment and orientation\n */\n\n/**\n * Function: alignCells\n * \n * Aligns the given cells vertically or horizontally according to the given\n * alignment using the optional parameter as the coordinate.\n * \n * Parameters:\n * \n * align - Specifies the alignment. Possible values are all constants in\n * mxConstants with an ALIGN prefix.\n * cells - Array of <mxCells> to be aligned.\n * param - Optional coordinate for the alignment.\n */\nmxGraph.prototype.alignCells = function(align, cells, param)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tif (cells != null && cells.length > 1)\n\t{\n\t\t// Finds the required coordinate for the alignment\n\t\tif (param == null)\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\n\t\t\t\tif (state != null && !this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tif (param == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.x + state.width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.y + state.height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Aligns the cells to the coordinate\n\t\tif (param != null)\n\t\t{\n\t\t\tvar s = this.view.scale;\n\n\t\t\tthis.model.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (geo != null && !this.model.isEdge(cells[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.resizeCell(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS,\n\t\t\t\t\t\t'align', align, 'cells', cells));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.model.endUpdate();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: flipEdge\n * \n * Toggles the style of the given edge between null (or empty) and\n * <alternateEdgeStyle>. This method fires <mxEvent.FLIP_EDGE> while the\n * transaction is in progress. Returns the edge that was flipped.\n * \n * Here is an example that overrides this implementation to invert the\n * value of <mxConstants.STYLE_ELBOW> without removing any existing styles.\n * \n * (code)\n * graph.flipEdge = function(edge)\n * {\n *   if (edge != null)\n *   {\n *     var state = this.view.getState(edge);\n *     var style = (state != null) ? state.style : this.getCellStyle(edge);\n *     \n *     if (style != null)\n *     {\n *       var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW,\n *           mxConstants.ELBOW_HORIZONTAL);\n *       var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?\n *           mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;\n *       this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);\n *     }\n *   }\n * };\n * (end)\n * \n * Parameters:\n * \n * edge - <mxCell> whose style should be changed.\n */\nmxGraph.prototype.flipEdge = function(edge)\n{\n\tif (edge != null &&\n\t\tthis.alternateEdgeStyle != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar style = this.model.getStyle(edge);\n\n\t\t\tif (style == null || style.length == 0)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, this.alternateEdgeStyle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, null);\n\t\t\t}\n\n\t\t\t// Removes all existing control points\n\t\t\tthis.resetEdge(edge);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, 'edge', edge));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: addImageBundle\n *\n * Adds the specified <mxImageBundle>.\n */\nmxGraph.prototype.addImageBundle = function(bundle)\n{\n\tthis.imageBundles.push(bundle);\n};\n\n/**\n * Function: removeImageBundle\n * \n * Removes the specified <mxImageBundle>.\n */\nmxGraph.prototype.removeImageBundle = function(bundle)\n{\n\tvar tmp = [];\n\t\n\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t{\n\t\tif (this.imageBundles[i] != bundle)\n\t\t{\n\t\t\ttmp.push(this.imageBundles[i]);\n\t\t}\n\t}\n\t\n\tthis.imageBundles = tmp;\n};\n\n/**\n * Function: getImageFromBundles\n *\n * Searches all <imageBundles> for the specified key and returns the value\n * for the first match or null if the key is not found.\n */\nmxGraph.prototype.getImageFromBundles = function(key)\n{\n\tif (key != null)\n\t{\n\t\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t\t{\n\t\t\tvar image = this.imageBundles[i].getImage(key);\n\t\t\t\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\treturn image;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Group: Order\n */\n\n/**\n * Function: orderCells\n * \n * Moves the given cells to the front or back. The change is carried out\n * using <cellsOrdered>. This method fires <mxEvent.ORDER_CELLS> while the\n * transaction is in progress.\n * \n * Parameters:\n * \n * back - Boolean that specifies if the cells should be moved to back.\n * cells - Array of <mxCells> to move to the background. If null is\n * specified then the selection cells are used.\n */\nmxGraph.prototype.orderCells = function(back, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsOrdered(cells, back);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS,\n\t\t\t\t'back', back, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsOrdered\n * \n * Moves the given cells to the front or back. This method fires\n * <mxEvent.CELLS_ORDERED> while the transaction is in progress.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose order should be changed.\n * back - Boolean that specifies if the cells should be moved to back.\n */\nmxGraph.prototype.cellsOrdered = function(cells, back)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\n\t\t\t\tif (back)\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i], i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i],\n\t\t\t\t\t\t\tthis.model.getChildCount(parent) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED,\n\t\t\t\t\t'back', back, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Grouping\n */\n\n/**\n * Function: groupCells\n * \n * Adds the cells into the given group. The change is carried out using\n * <cellsAdded>, <cellsMoved> and <cellsResized>. This method fires\n * <mxEvent.GROUP_CELLS> while the transaction is in progress. Returns the\n * new group. A group is only created if there is at least one entry in the\n * given array of cells.\n * \n * Parameters:\n * \n * group - <mxCell> that represents the target group. If null is specified\n * then a new group is created using <createGroupCell>.\n * border - Optional integer that specifies the border between the child\n * area and the group bounds. Default is 0.\n * cells - Optional array of <mxCells> to be grouped. If null is specified\n * then the selection cells are used.\n */\nmxGraph.prototype.groupCells = function(group, border, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tcells = this.getCellsForGroup(cells);\n\n\tif (group == null)\n\t{\n\t\tgroup = this.createGroupCell(cells);\n\t}\n\n\tvar bounds = this.getBoundsForGroup(group, cells, border);\n\n\tif (cells.length > 0 && bounds != null)\n\t{\n\t\t// Uses parent of group or previous parent of first child\n\t\tvar parent = this.model.getParent(group);\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.model.getParent(cells[0]);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Checks if the group has a geometry and\n\t\t\t// creates one if one does not exist\n\t\t\tif (this.getCellGeometry(group) == null)\n\t\t\t{\n\t\t\t\tthis.model.setGeometry(group, new mxGeometry());\n\t\t\t}\n\n\t\t\t// Adds the group into the parent\n\t\t\tvar index = this.model.getChildCount(parent);\n\t\t\tthis.cellsAdded([group], parent, index, null, null, false, false, false);\n\n\t\t\t// Adds the children into the group and moves\n\t\t\tindex = this.model.getChildCount(group);\n\t\t\tthis.cellsAdded(cells, group, index, null, null, false, false, false);\n\t\t\tthis.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n\n\t\t\t// Resizes the group\n\t\t\tthis.cellsResized([group], [bounds], false);\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS,\n\t\t\t\t\t'group', group, 'border', border, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn group;\n};\n\n/**\n * Function: getCellsForGroup\n * \n * Returns the cells with the same parent as the first cell\n * in the given array.\n */\nmxGraph.prototype.getCellsForGroup = function(cells)\n{\n\tvar result = [];\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar parent = this.model.getParent(cells[0]);\n\t\tresult.push(cells[0]);\n\n\t\t// Filters selection cells with the same parent\n\t\tfor (var i = 1; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.getParent(cells[i]) == parent)\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getBoundsForGroup\n * \n * Returns the bounds to be used for the given group and children.\n */\nmxGraph.prototype.getBoundsForGroup = function(group, children, border)\n{\n\tvar result = this.getBoundingBoxFromGeometry(children, true);\n\t\n\tif (result != null)\n\t{\n\t\tif (this.isSwimlane(group))\n\t\t{\n\t\t\tvar size = this.getStartSize(group);\n\t\t\t\n\t\t\tresult.x -= size.width;\n\t\t\tresult.y -= size.height;\n\t\t\tresult.width += size.width;\n\t\t\tresult.height += size.height;\n\t\t}\n\t\t\n\t\t// Adds the border\n\t\tif (border != null)\n\t\t{\n\t\t\tresult.x -= border;\n\t\t\tresult.y -= border;\n\t\t\tresult.width += 2 * border;\n\t\t\tresult.height += 2 * border;\n\t\t}\n\t}\t\t\t\n\t\n\treturn result;\n};\n\n/**\n * Function: createGroupCell\n * \n * Hook for creating the group cell to hold the given array of <mxCells> if\n * no group cell was given to the <group> function.\n * \n * The following code can be used to set the style of new group cells.\n * \n * (code)\n * var graphCreateGroupCell = graph.createGroupCell;\n * graph.createGroupCell = function(cells)\n * {\n *   var group = graphCreateGroupCell.apply(this, arguments);\n *   group.setStyle('group');\n *   \n *   return group;\n * };\n */\nmxGraph.prototype.createGroupCell = function(cells)\n{\n\tvar group = new mxCell('');\n\tgroup.setVertex(true);\n\tgroup.setConnectable(false);\n\t\n\treturn group;\n};\n\n/**\n * Function: ungroupCells\n * \n * Ungroups the given cells by moving the children the children to their\n * parents parent and removing the empty groups. Returns the children that\n * have been removed from the groups.\n * \n * Parameters:\n * \n * cells - Array of cells to be ungrouped. If null is specified then the\n * selection cells are used.\n */\nmxGraph.prototype.ungroupCells = function(cells)\n{\n\tvar result = [];\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\n\t\t// Finds the cells with children\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.getChildCount(cells[i]) > 0)\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\n\t\tcells = tmp;\n\t}\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\t\t\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tchildren = children.slice();\n\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\t\t\tvar index = this.model.getChildCount(parent);\n\n\t\t\t\t\tthis.cellsAdded(children, parent, index, null, null, true);\n\t\t\t\t\tresult = result.concat(children);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.removeCellsAfterUngroup(cells);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: removeCellsAfterUngroup\n * \n * Hook to remove the groups after <ungroupCells>.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> that were ungrouped.\n */\nmxGraph.prototype.removeCellsAfterUngroup = function(cells)\n{\n\tthis.cellsRemoved(this.addAllEdges(cells));\n};\n\n/**\n * Function: removeCellsFromParent\n * \n * Removes the specified cells from their parents and adds them to the\n * default parent. Returns the cells that were removed from their parents.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be removed from their parents.\n */\nmxGraph.prototype.removeCellsFromParent = function(cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar parent = this.getDefaultParent();\n\t\tvar index = this.model.getChildCount(parent);\n\n\t\tthis.cellsAdded(cells, parent, index, null, null, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: updateGroupBounds\n * \n * Updates the bounds of the given groups to include all children and returns\n * the passed-in cells. Call this with the groups in parent to child order,\n * top-most group first, the cells are processed in reverse order and cells\n * with no children are ignored.\n * \n * Parameters:\n * \n * cells - The groups whose bounds should be updated. If this is null, then\n * the selection cells are used.\n * border - Optional border to be added in the group. Default is 0.\n * moveGroup - Optional boolean that allows the group to be moved. Default\n * is false.\n * topBorder - Optional top border to be added in the group. Default is 0.\n * rightBorder - Optional top border to be added in the group. Default is 0.\n * bottomBorder - Optional top border to be added in the group. Default is 0.\n * leftBorder - Optional top border to be added in the group. Default is 0.\n */\nmxGraph.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tborder = (border != null) ? border : 0;\n\tmoveGroup = (moveGroup != null) ? moveGroup : false;\n\ttopBorder = (topBorder != null) ? topBorder : 0;\n\trightBorder = (rightBorder != null) ? rightBorder : 0;\n\tbottomBorder = (bottomBorder != null) ? bottomBorder : 0;\n\tleftBorder = (leftBorder != null) ? leftBorder : 0;\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = cells.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar children = this.getChildCells(cells[i]);\n\t\t\t\t\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.getBoundingBoxFromGeometry(children, true);\n\t\t\t\t\t\n\t\t\t\t\tif (bounds != null && bounds.width > 0 && bounds.height > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar left = 0;\n\t\t\t\t\t\tvar top = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Adds the size of the title area for swimlanes\n\t\t\t\t\t\tif (this.isSwimlane(cells[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar size = this.getStartSize(cells[i]);\n\t\t\t\t\t\t\tleft = size.width;\n\t\t\t\t\t\t\ttop = size.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (moveGroup)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = Math.round(geo.x + bounds.x - border - left - leftBorder);\n\t\t\t\t\t\t\tgeo.y = Math.round(geo.y + bounds.y - border - top - topBorder);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tgeo.width = Math.round(bounds.width + 2 * border + left + leftBorder + rightBorder);\n\t\t\t\t\t\tgeo.height = Math.round(bounds.height + 2 * border + top + topBorder + bottomBorder);\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\tthis.moveCells(children, border + left - bounds.x + leftBorder,\n\t\t\t\t\t\t\t\tborder + top - bounds.y + topBorder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: getBoundingBox\n * \n * Returns the bounding box for the given array of <mxCells>. The bounding box for\n * each cell and its descendants is computed using <mxGraphView.getBoundingBox>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounding box should be returned.\n */\nmxGraph.prototype.getBoundingBox = function(cells)\n{\n\tvar result = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);\n\t\t\t\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Group: Cell cloning, insertion and removal\n */\n\n/**\n * Function: cloneCell\n * \n * Returns the clone for the given cell. Uses <cloneCells>.\n * \n * Parameters:\n * \n * cell - <mxCell> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCell = function(cell, allowInvalidEdges, mapping, keepPosition)\n{\n\treturn this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];\n};\n\n/**\n * Function: cloneCells\n * \n * Returns the clones for the given cells. The clones are created recursively\n * using <mxGraphModel.cloneCells>. If the terminal of an edge is not in the\n * given array, then the respective end is assigned a terminal point and the\n * terminal is removed.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCells = function(cells, allowInvalidEdges, mapping, keepPosition)\n{\n\tallowInvalidEdges = (allowInvalidEdges != null) ? allowInvalidEdges : true;\n\tvar clones = null;\n\t\n\tif (cells != null)\n\t{\n\t\t// Creates a dictionary for fast lookups\n\t\tvar dict = new mxDictionary();\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t\ttmp.push(cells[i]);\n\t\t}\n\t\t\n\t\tif (tmp.length > 0)\n\t\t{\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar trans = this.view.translate;\n\t\t\tclones = this.model.cloneCells(cells, true, mapping);\n\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!allowInvalidEdges && this.model.isEdge(clones[i]) &&\n\t\t\t\t\tthis.getEdgeValidationError(clones[i],\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], true),\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], false)) != null)\n\t\t\t\t{\n\t\t\t\t\tclones[i] = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar g = this.model.getGeometry(clones[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (g != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(this.model.getParent(cells[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null && pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = (keepPosition) ? 0 : pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = (keepPosition) ? 0 : pstate.origin.y;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (this.model.isEdge(clones[i]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Checks if the source is cloned or sets the terminal point\n\t\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (src == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - trans.y), true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Checks if the target is cloned or sets the terminal point\n\t\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (trg == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - trans.y), false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Translates the control points\n\t\t\t\t\t\t\t\tvar points = g.points;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (points != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tpoints[j].x += dx;\n\t\t\t\t\t\t\t\t\t\tpoints[j].y += dy;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tg.translate(dx, dy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones = [];\n\t\t}\n\t}\n\t\n\treturn clones;\n};\n\n/**\n * Function: insertVertex\n * \n * Adds a new vertex into the given parent <mxCell> using value as the user\n * object and the given coordinates as the <mxGeometry> of the new vertex.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * When adding new vertices from a mouse event, one should take into\n * account the offset of the graph container and the scale and translation\n * of the view in order to find the correct unscaled, untranslated\n * coordinates using <mxGraph.getPointForEvent> as follows:\n * \n * (code)\n * var pt = graph.getPointForEvent(evt);\n * var parent = graph.getDefaultParent();\n * graph.insertVertex(parent, null,\n * \t\t\t'Hello, World!', x, y, 220, 30);\n * (end)\n * \n * For adding image cells, the style parameter can be assigned as\n * \n * (code)\n * stylename;image=imageUrl\n * (end)\n * \n * See <mxGraph> for more information on using images.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent of the new vertex.\n * id - Optional string that defines the Id of the new vertex.\n * value - Object to be used as the user object.\n * x - Integer that defines the x coordinate of the vertex.\n * y - Integer that defines the y coordinate of the vertex.\n * width - Integer that defines the width of the vertex.\n * height - Integer that defines the height of the vertex.\n * style - Optional string that defines the cell style.\n * relative - Optional boolean that specifies if the geometry is relative.\n * Default is false.\n */\nmxGraph.prototype.insertVertex = function(parent, id, value,\n\tx, y, width, height, style, relative)\n{\n\tvar vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative);\n\n\treturn this.addCell(vertex, parent);\n};\n\n/**\n * Function: createVertex\n * \n * Hook method that creates the new vertex for <insertVertex>.\n */\nmxGraph.prototype.createVertex = function(parent, id, value,\n\t\tx, y, width, height, style, relative)\n{\n\t// Creates the geometry for the vertex\n\tvar geometry = new mxGeometry(x, y, width, height);\n\tgeometry.relative = (relative != null) ? relative : false;\n\t\n\t// Creates the vertex\n\tvar vertex = new mxCell(value, geometry, style);\n\tvertex.setId(id);\n\tvertex.setVertex(true);\n\tvertex.setConnectable(true);\n\t\n\treturn vertex;\n};\n\t\n/**\n * Function: insertEdge\n * \n * Adds a new edge into the given parent <mxCell> using value as the user\n * object and the given source and target as the terminals of the new edge.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent of the new edge.\n * id - Optional string that defines the Id of the new edge.\n * value - JavaScript object to be used as the user object.\n * source - <mxCell> that defines the source of the edge.\n * target - <mxCell> that defines the target of the edge.\n * style - Optional string that defines the cell style.\n */\nmxGraph.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tvar edge = this.createEdge(parent, id, value, source, target, style);\n\t\n\treturn this.addEdge(edge, parent, source, target);\n};\n\n/**\n * Function: createEdge\n * \n * Hook method that creates the new edge for <insertEdge>. This\n * implementation does not set the source and target of the edge, these\n * are set when the edge is added to the model.\n * \n */\nmxGraph.prototype.createEdge = function(parent, id, value, source, target, style)\n{\n\t// Creates the edge\n\tvar edge = new mxCell(value, new mxGeometry(), style);\n\tedge.setId(id);\n\tedge.setEdge(true);\n\tedge.geometry.relative = true;\n\t\n\treturn edge;\n};\n\n/**\n * Function: addEdge\n * \n * Adds the edge to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the edge that was\n * added.\n * \n * Parameters:\n * \n * edge - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n * index - Optional index to insert the cells at. Default is to append.\n */\nmxGraph.prototype.addEdge = function(edge, parent, source, target, index)\n{\n\treturn this.addCell(edge, parent, index, source, target);\n};\n\n/**\n * Function: addCell\n * \n * Adds the cell to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the cell that was\n * added.\n * \n * Parameters:\n * \n * cell - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.addCell = function(cell, parent, index, source, target)\n{\n\treturn this.addCells([cell], parent, index, source, target)[0];\n};\n\n/**\n * Function: addCells\n * \n * Adds the cells to the parent at the given index, connecting each cell to\n * the optional source and target terminal. The change is carried out using\n * <cellsAdded>. This method fires <mxEvent.ADD_CELLS> while the\n * transaction is in progress. Returns the cells that were added.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be inserted.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional source <mxCell> for all inserted cells.\n * target - Optional target <mxCell> for all inserted cells.\n */\nmxGraph.prototype.addCells = function(cells, parent, index, source, target)\n{\n\tif (parent == null)\n\t{\n\t\tparent = this.getDefaultParent();\n\t}\n\t\n\tif (index == null)\n\t{\n\t\tindex = this.model.getChildCount(parent);\n\t}\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsAdded(cells, parent, index, source, target, false, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsAdded\n * \n * Adds the specified cells to the given parent. This method fires\n * <mxEvent.CELLS_ADDED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsAdded = function(cells, parent, index, source, target, absolute, constrain, extend)\n{\n\tif (cells != null && parent != null && index != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar parentState = (absolute) ? this.view.getState(parent) : null;\n\t\t\tvar o1 = (parentState != null) ? parentState.origin : null;\n\t\t\tvar zero = new mxPoint(0, 0);\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (cells[i] == null)\n\t\t\t\t{\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar previous = this.model.getParent(cells[i]);\n\t\n\t\t\t\t\t// Keeps the cell at its absolute location\n\t\t\t\t\tif (o1 != null && cells[i] != parent && parent != previous)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar oldState = this.view.getState(previous);\n\t\t\t\t\t\tvar o2 = (oldState != null) ? oldState.origin : zero;\n\t\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\t\n\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = o2.x - o1.x;\n\t\t\t\t\t\t\tvar dy = o2.y - o1.y;\n\t\n\t\t\t\t\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t\t\t\t\t// to avoid forward references in sessions.\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.translate(dx, dy);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!geo.relative && this.model.isVertex(cells[i]) &&\n\t\t\t\t\t\t\t\t!this.isAllowNegativeCoordinates())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\t\t\t\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Decrements all following indices\n\t\t\t\t\t// if cell is already in parent\n\t\t\t\t\tif (parent == previous && index + i > this.model.getChildCount(parent))\n\t\t\t\t\t{\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.add(parent, cells[i], index + i);\n\t\t\t\t\t\n\t\t\t\t\tif (this.autoSizeCellsOnAdd)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.autoSizeCell(cells[i], true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extends the parent or constrains the child\n\t\t\t\t\tif ((extend == null || extend) &&\n\t\t\t\t\t\tthis.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Additionally constrains the child after extending the parent\n\t\t\t\t\tif (constrain == null || constrain)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Sets the source terminal\n\t\t\t\t\tif (source != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], source, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Sets the target terminal\n\t\t\t\t\tif (target != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], target, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target,\n\t\t\t\t'absolute', absolute));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: autoSizeCell\n * \n * Resizes the specified cell to just fit around the its label and/or children\n * \n * Parameters:\n * \n * cell - <mxCells> to be resized.\n * recurse - Optional boolean which specifies if all descendants should be\n * autosized. Default is true.\n */\nmxGraph.prototype.autoSizeCell = function(cell, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\t\n\tif (recurse)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.autoSizeCell(this.model.getChildAt(cell, i));\n\t\t}\n\t}\n\n\tif (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell))\n\t{\n\t\tthis.updateCellSize(cell);\n\t}\n};\n\n/**\n * Function: removeCells\n * \n * Removes the given cells from the graph including all connected edges if\n * includeEdges is true. The change is carried out using <cellsRemoved>.\n * This method fires <mxEvent.REMOVE_CELLS> while the transaction is in\n * progress. The removed cells are returned as an array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to remove. If null is specified then the\n * selection cells which are deletable are used.\n * includeEdges - Optional boolean which specifies if all connected edges\n * should be removed as well. Default is true.\n */\nmxGraph.prototype.removeCells = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getDeletableCells(this.getSelectionCells());\n\t}\n\n\t// Adds all edges to the cells\n\tif (includeEdges)\n\t{\n\t\t// FIXME: Remove duplicate cells in result or do not add if\n\t\t// in cells or descendant of cells\n\t\tcells = this.getDeletableCells(this.addAllEdges(cells));\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsRemoved(cells);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, \n\t\t\t\t'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: cellsRemoved\n * \n * Removes the given cells from the model. This method fires\n * <mxEvent.CELLS_REMOVED> while the transaction is in progress.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to remove.\n */\nmxGraph.prototype.cellsRemoved = function(cells)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar scale = this.view.scale;\n\t\tvar tr = this.view.translate;\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Creates hashtable for faster lookup\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\t// Disconnects edges which are not in cells\n\t\t\t\tvar edges = this.getAllEdges([cells[i]]);\n\t\t\t\t\n\t\t\t\tvar disconnectTerminal = mxUtils.bind(this, function(edge, source)\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(edge);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(edge);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Checks which side of the edge is being disconnected\n\t\t\t\t\t\t\tvar tmp = state.getVisibleTerminal(source);\n\t\t\t\t\t\t\tvar connected = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (cells[i] == tmp)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnected = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttmp = this.model.getParent(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (connected)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar dx = tr.x;\n\t\t\t\t\t\t\t\tvar dy = tr.y;\n\t\t\t\t\t\t\t\tvar parentState = this.view.getState(this.model.getParent(edge));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (parentState != null && this.model.isVertex(parentState.cell))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdx = parentState.x / scale;\n\t\t\t\t\t\t\t\t\tdy = parentState.y / scale;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\t\t\t\t\t\t\t\tvar n = (source) ? 0 : pts.length - 1;\n\t\t\t\t\t\t\t\tgeo.setTerminalPoint(new mxPoint(pts[n].x / scale - dx, pts[n].y / scale - dy), source);\n\t\t\t\t\t\t\t\tthis.model.setTerminal(edges[j], null, source);\n\t\t\t\t\t\t\t\tthis.model.setGeometry(edges[j], geo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!dict.get(edges[j]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdisconnectTerminal(edges[j], true);\n\t\t\t\t\t\tdisconnectTerminal(edges[j], false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.model.remove(cells[i]);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: splitEdge\n * \n * Splits the given edge by adding the newEdge between the previous source\n * and the given cell and reconnecting the source of the given edge to the\n * given cell. This method fires <mxEvent.SPLIT_EDGE> while the transaction\n * is in progress. Returns the new edge that was inserted.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that represents the cells to insert into the edge.\n * newEdge - <mxCell> that represents the edge to be inserted.\n * dx - Optional integer that specifies the vector to move the cells.\n * dy - Optional integer that specifies the vector to move the cells.\n */\nmxGraph.prototype.splitEdge = function(edge, cells, newEdge, dx, dy)\n{\n\tdx = dx || 0;\n\tdy = dy || 0;\n\n\tvar parent = this.model.getParent(edge);\n\tvar source = this.model.getTerminal(edge, true);\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tif (newEdge == null)\n\t\t{\n\t\t\tnewEdge = this.cloneCell(edge);\n\t\t\t\n\t\t\t// Removes waypoints before/after new cell\n\t\t\tvar state = this.view.getState(edge);\n\t\t\tvar geo = this.getCellGeometry(newEdge);\n\t\t\t\n\t\t\tif (geo != null && geo.points != null && state != null)\n\t\t\t{\n\t\t\t\tvar t = this.view.translate;\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar idx = mxUtils.findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n\t\t\t\tgeo.points = geo.points.slice(0, idx);\n\t\t\t\t\t\t\t\t\n\t\t\t\tgeo = this.getCellGeometry(edge);\n\t\t\t\t\n\t\t\t\tif (geo != null && geo.points != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\tgeo.points = geo.points.slice(idx);\n\t\t\t\t\tthis.model.setGeometry(edge, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cellsMoved(cells, dx, dy, false, false);\n\t\tthis.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null,\n\t\t\t\ttrue);\n\t\tthis.cellsAdded([newEdge], parent, this.model.getChildCount(parent),\n\t\t\t\tsource, cells[0], false);\n\t\tthis.cellConnected(edge, cells[0], true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, 'edge', edge,\n\t\t\t\t'cells', cells, 'newEdge', newEdge, 'dx', dx, 'dy', dy));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn newEdge;\n};\n\n/**\n * Group: Cell visibility\n */\n\n/**\n * Function: toggleCells\n * \n * Sets the visible state of the specified cells and all connected edges\n * if includeEdges is true. The change is carried out using <cellsToggled>.\n * This method fires <mxEvent.TOGGLE_CELLS> while the transaction is in\n * progress. Returns the cells whose visible state was changed.\n * \n * Parameters:\n * \n * show - Boolean that specifies the visible state to be assigned.\n * cells - Array of <mxCells> whose visible state should be changed. If\n * null is specified then the selection cells are used.\n * includeEdges - Optional boolean indicating if the visible state of all\n * connected edges should be changed as well. Default is true.\n */\nmxGraph.prototype.toggleCells = function(show, cells, includeEdges)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\t// Adds all connected edges recursively\n\tif (includeEdges)\n\t{\n\t\tcells = this.addAllEdges(cells);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsToggled(cells, show);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS,\n\t\t\t'show', show, 'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsToggled\n * \n * Sets the visible state of the specified cells.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose visible state should be changed.\n * show - Boolean that specifies the visible state to be assigned.\n */\nmxGraph.prototype.cellsToggled = function(cells, show)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setVisible(cells[i], show);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Folding\n */\n\n/**\n * Function: foldCells\n * \n * Sets the collapsed state of the specified cells and all descendants\n * if recurse is true. The change is carried out using <cellsFolded>.\n * This method fires <mxEvent.FOLD_CELLS> while the transaction is in\n * progress. Returns the cells whose collapsed state was changed.\n * \n * Parameters:\n * \n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Optional boolean indicating if the collapsed state of all\n * descendants should be set. Default is false.\n * cells - Array of <mxCells> whose collapsed state should be set. If\n * null is specified then the foldable selection cells are used.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n * evt - Optional native event that triggered the invocation.\n */\nmxGraph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getFoldableCells(this.getSelectionCells(), collapse);\n\t}\n\n\tthis.stopEditing(false);\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsFolded(cells, collapse, recurse, checkFoldable);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS,\n\t\t\t'collapse', collapse, 'recurse', recurse, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsFolded\n * \n * Sets the collapsed state of the specified cells. This method fires\n * <mxEvent.CELLS_FOLDED> while the transaction is in progress. Returns the\n * cells whose collapsed state was changed.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose collapsed state should be set.\n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Boolean indicating if the collapsed state of all descendants\n * should be set.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n */\nmxGraph.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n\t\t\t\t\tcollapse != this.isCellCollapsed(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.model.setCollapsed(cells[i], collapse);\n\t\t\t\t\tthis.swapBounds(cells[i], collapse);\n\n\t\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (recurse)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\t\t\t\tthis.cellsFolded(children, collapse, recurse);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED,\n\t\t\t\t'cells', cells, 'collapse', collapse, 'recurse', recurse));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: swapBounds\n * \n * Swaps the alternate and the actual bounds in the geometry of the given\n * cell invoking <updateAlternateBounds> before carrying out the swap.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the bounds should be swapped.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.swapBounds = function(cell, willCollapse)\n{\n\tif (cell != null)\n\t{\n\t\tvar geo = this.model.getGeometry(cell);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\t\n\t\t\tthis.updateAlternateBounds(cell, geo, willCollapse);\n\t\t\tgeo.swap();\n\t\t\t\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateAlternateBounds\n * \n * Updates or sets the alternate bounds in the given geometry for the given\n * cell depending on whether the cell is going to be collapsed. If no\n * alternate bounds are defined in the geometry and\n * <collapseToPreferredSize> is true, then the preferred size is used for\n * the alternate bounds. The top, left corner is always kept at the same\n * location.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the geometry is being udpated.\n * g - <mxGeometry> for which the alternate bounds should be updated.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.updateAlternateBounds = function(cell, geo, willCollapse)\n{\n\tif (cell != null && geo != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\tif (geo.alternateBounds == null)\n\t\t{\n\t\t\tvar bounds = geo;\n\t\t\t\n\t\t\tif (this.collapseToPreferredSize)\n\t\t\t{\n\t\t\t\tvar tmp = this.getPreferredSizeForCell(cell);\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tbounds = tmp;\n\n\t\t\t\t\tvar startSize = mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE);\n\n\t\t\t\t\tif (startSize > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbounds.height = Math.max(bounds.height, startSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgeo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);\n\t\t}\n\t\t\n\t\tif (geo.alternateBounds != null)\n\t\t{\n\t\t\tgeo.alternateBounds.x = geo.x;\n\t\t\tgeo.alternateBounds.y = geo.y;\n\t\t\t\n\t\t\tvar alpha = mxUtils.toRadians(style[mxConstants.STYLE_ROTATION] || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n\t\t\t\tvar dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n\t\n\t\t\t\tvar cos = Math.cos(alpha);\n\t\t\t\tvar sin = Math.sin(alpha);\n\t\n\t\t\t\tvar dx2 = cos * dx - sin * dy;\n\t\t\t\tvar dy2 = sin * dx + cos * dy;\n\t\t\t\t\n\t\t\t\tgeo.alternateBounds.x += dx2 - dx;\n\t\t\t\tgeo.alternateBounds.y += dy2 - dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: addAllEdges\n * \n * Returns an array with the given cells and all edges that are connected\n * to a cell or one of its descendants.\n */\nmxGraph.prototype.addAllEdges = function(cells)\n{\n\tvar allCells = cells.slice();\n\t\n\treturn mxUtils.removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n};\n\n/**\n * Function: getAllEdges\n * \n * Returns all edges connected to the given cells or its descendants.\n */\nmxGraph.prototype.getAllEdges = function(cells)\n{\n\tvar edges = [];\n\t\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar edgeCount = this.model.getEdgeCount(cells[i]);\n\t\t\t\n\t\t\tfor (var j = 0; j < edgeCount; j++)\n\t\t\t{\n\t\t\t\tedges.push(this.model.getEdgeAt(cells[i], j));\n\t\t\t}\n\n\t\t\t// Recurses\n\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\tedges = edges.concat(this.getAllEdges(children));\n\t\t}\n\t}\n\t\n\treturn edges;\n};\n\n/**\n * Group: Cell sizing\n */\n\n/**\n * Function: updateCellSize\n * \n * Updates the size of the given cell in the model using <cellSizeUpdated>.\n * This method fires <mxEvent.UPDATE_CELL_SIZE> while the transaction is in\n * progress. Returns the cell whose size was updated.\n * \n * Parameters:\n * \n * cell - <mxCell> whose size should be updated.\n */\nmxGraph.prototype.updateCellSize = function(cell, ignoreChildren)\n{\n\tignoreChildren = (ignoreChildren != null) ? ignoreChildren : false;\n\t\n\tthis.model.beginUpdate();\t\t\t\t\n\ttry\n\t{\n\t\tthis.cellSizeUpdated(cell, ignoreChildren);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE,\n\t\t\t\t'cell', cell, 'ignoreChildren', ignoreChildren));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellSizeUpdated\n * \n * Updates the size of the given cell in the model using\n * <getPreferredSizeForCell> to get the new size.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the size should be changed.\n */\nmxGraph.prototype.cellSizeUpdated = function(cell, ignoreChildren)\n{\n\tif (cell != null)\n\t{\n\t\tthis.model.beginUpdate();\t\t\t\t\n\t\ttry\n\t\t{\n\t\t\tvar size = this.getPreferredSizeForCell(cell);\n\t\t\tvar geo = this.model.getGeometry(cell);\n\t\t\t\n\t\t\tif (size != null && geo != null)\n\t\t\t{\n\t\t\t\tvar collapsed = this.isCellCollapsed(cell);\n\t\t\t\tgeo = geo.clone();\n\n\t\t\t\tif (this.isSwimlane(cell))\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(cell);\n\t\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\t\t\t\tvar cellStyle = this.model.getStyle(cell);\n\n\t\t\t\t\tif (cellStyle == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.height + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.height = size.height + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.width + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.width = size.width + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.setStyle(cell, cellStyle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t}\n\n\t\t\t\tif (!ignoreChildren && !collapsed)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.view.getBounds(this.model.getChildren(cell));\n\n\t\t\t\t\tif (bounds != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tr = this.view.translate;\n\t\t\t\t\t\tvar scale = this.view.scale;\n\n\t\t\t\t\t\tvar width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n\t\t\t\t\t\tvar height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n\n\t\t\t\t\t\tgeo.width = Math.max(geo.width, width);\n\t\t\t\t\t\tgeo.height = Math.max(geo.height, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.cellsResized([cell], [geo], false);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getPreferredSizeForCell\n * \n * Returns the preferred width and height of the given <mxCell> as an\n * <mxRectangle>. To implement a minimum width, add a new style eg.\n * minWidth in the vertex and override this method as follows.\n * \n * (code)\n * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;\n * graph.getPreferredSizeForCell = function(cell)\n * {\n *   var result = graphGetPreferredSizeForCell.apply(this, arguments);\n *   var style = this.getCellStyle(cell);\n *   \n *   if (style['minWidth'] > 0)\n *   {\n *     result.width = Math.max(style['minWidth'], result.width);\n *   }\n * \n *   return result;\n * };\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> for which the preferred size should be returned.\n */\nmxGraph.prototype.getPreferredSizeForCell = function(cell)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tvar state = this.view.getState(cell) || this.view.createState(cell);\n\t\tvar style = state.style;\n\n\t\tif (!this.model.isEdge(cell))\n\t\t{\n\t\t\tvar fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;\n\t\t\tvar dx = 0;\n\t\t\tvar dy = 0;\n\t\t\t\n\t\t\t// Adds dimension of image if shape is a label\n\t\t\tif (this.getImage(state) != null || style[mxConstants.STYLE_IMAGE] != null)\n\t\t\t{\n\t\t\t\tif (style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_LABEL)\n\t\t\t\t{\n\t\t\t\t\tif (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx += parseFloat(style[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy += parseFloat(style[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adds spacings\n\t\t\tdx += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdx += style[mxConstants.STYLE_SPACING_LEFT] || 0;\n\t\t\tdx += style[mxConstants.STYLE_SPACING_RIGHT] || 0;\n\n\t\t\tdy += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdy += style[mxConstants.STYLE_SPACING_TOP] || 0;\n\t\t\tdy += style[mxConstants.STYLE_SPACING_BOTTOM] || 0;\n\t\t\t\n\t\t\t// Add spacing for collapse/expand icon\n\t\t\t// LATER: Check alignment and use constants\n\t\t\t// for image spacing\n\t\t\tvar image = this.getFoldingImage(state);\n\t\t\t\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\tdx += image.width + 8;\n\t\t\t}\n\n\t\t\t// Adds space for label\n\t\t\tvar value = this.cellRenderer.getLabelValue(state);\n\n\t\t\tif (value != null && value.length > 0)\n\t\t\t{\n\t\t\t\tif (!this.isHtmlLabel(state.cell))\n\t\t\t\t{\n\t\t\t\t\tvalue = mxUtils.htmlEntities(value);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue = value.replace(/\\n/g, '<br>');\n\t\t\t\t\n\t\t\t\tvar size = mxUtils.getSizeForString(value, fontSize, style[mxConstants.STYLE_FONTFAMILY]);\n\t\t\t\tvar width = size.width + dx;\n\t\t\t\tvar height = size.height + dy;\n\t\t\t\t\n\t\t\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t{\n\t\t\t\t\tvar tmp = height;\n\t\t\t\t\t\n\t\t\t\t\theight = width;\n\t\t\t\t\twidth = tmp;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (this.gridEnabled)\n\t\t\t\t{\n\t\t\t\t\twidth = this.snap(width + this.gridSize / 2);\n\t\t\t\t\theight = this.snap(height + this.gridSize / 2);\n\t\t\t\t}\n\n\t\t\t\tresult = new mxRectangle(0, 0, width, height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar gs2 = 4 * this.gridSize;\n\t\t\t\tresult = new mxRectangle(0, 0, gs2, gs2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: resizeCell\n * \n * Sets the bounds of the given cell using <resizeCells>. Returns the\n * cell which was passed to the function.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangle> that represents the new bounds.\n */\nmxGraph.prototype.resizeCell = function(cell, bounds, recurse)\n{\n\treturn this.resizeCells([cell], [bounds], recurse)[0];\n};\n\n/**\n * Function: resizeCells\n * \n * Sets the bounds of the given cells and fires a <mxEvent.RESIZE_CELLS>\n * event while the transaction is in progress. Returns the cells which\n * have been passed to the function.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n */\nmxGraph.prototype.resizeCells = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : this.isRecursiveResize();\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsResized(cells, bounds, recurse);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS,\n\t\t\t\t'cells', cells, 'bounds', bounds));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsResized\n * \n * Sets the bounds of the given cells and fires a <mxEvent.CELLS_RESIZED>\n * event. If <extendParents> is true, then the parent is extended if a\n * child size is changed so that it overlaps with the parent.\n * \n * The following example shows how to control group resizes to make sure\n * that all child cells stay within the group.\n * \n * (code)\n * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n *   \n *   if (cells != null)\n *   {\n *     for (var i = 0; i < cells.length; i++)\n *     {\n *       if (graph.getModel().getChildCount(cells[i]) > 0)\n *       {\n *         var geo = graph.getCellGeometry(cells[i]);\n *         \n *         if (geo != null)\n *         {\n *           var children = graph.getChildCells(cells[i], true, true);\n *           var bounds = graph.getBoundingBoxFromGeometry(children, true);\n *           \n *           geo = geo.clone();\n *           geo.width = Math.max(geo.width, bounds.width);\n *           geo.height = Math.max(geo.height, bounds.height);\n *           \n *           graph.getModel().setGeometry(cells[i], geo);\n *         }\n *       }\n *     }\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellsResized = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\t\n\tif (cells != null && bounds != null && cells.length == bounds.length)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.cellResized(cells[i], bounds[i], false, recurse);\n\n\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnResize)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED,\n\t\t\t\t\t'cells', cells, 'bounds', bounds));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: cellResized\n * \n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangles> that represent the new bounds.\n * ignoreRelative - Boolean that indicates if relative cells should be ignored.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellResized = function(cell, bounds, ignoreRelative, recurse)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null && (geo.x != bounds.x || geo.y != bounds.y ||\n\t\tgeo.width != bounds.width || geo.height != bounds.height))\n\t{\n\t\tgeo = geo.clone();\n\n\t\tif (!ignoreRelative && geo.relative)\n\t\t{\n\t\t\tvar offset = geo.offset;\n\n\t\t\tif (offset != null)\n\t\t\t{\n\t\t\t\toffset.x += bounds.x - geo.x;\n\t\t\t\toffset.y += bounds.y - geo.y;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeo.x = bounds.x;\n\t\t\tgeo.y = bounds.y;\n\t\t}\n\n\t\tgeo.width = bounds.width;\n\t\tgeo.height = bounds.height;\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (recurse)\n\t\t\t{\n\t\t\t\tthis.resizeChildCells(cell, geo);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\tthis.constrainChildCells(cell);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resizeChildCells\n * \n * Resizes the child cells of the given cell for the given new geometry with\n * respect to the current geometry of the cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n * newGeo - <mxGeometry> that represents the new bounds.\n */\nmxGraph.prototype.resizeChildCells = function(cell, newGeo)\n{\n\tvar geo = this.model.getGeometry(cell);\n\tvar dx = newGeo.width / geo.width;\n\tvar dy = newGeo.height / geo.height;\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.scaleCell(this.model.getChildAt(cell, i), dx, dy, true);\n\t}\n};\n\n/**\n * Function: constrainChildCells\n * \n * Constrains the children of the given cell using <constrainChild>.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.constrainChildCells = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.constrainChild(this.model.getChildAt(cell, i));\n\t}\n};\n\n/**\n * Function: scaleCell\n * \n * Scales the points, position and size of the given cell according to the\n * given vertical and horizontal scaling factors.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be scaled.\n * dx - Horizontal scaling factor.\n * dy - Vertical scaling factor.\n * recurse - Boolean indicating if the child cells should be scaled.\n */\nmxGraph.prototype.scaleCell = function(cell, dx, dy, recurse)\n{\n\tvar geo = this.model.getGeometry(cell);\n\t\n\tif (geo != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\t\n\t\tgeo = geo.clone();\n\t\t\n\t\t// Stores values for restoring based on style\n\t\tvar x = geo.x;\n\t\tvar y = geo.y\n\t\tvar w = geo.width;\n\t\tvar h = geo.height;\n\t\t\n\t\tgeo.scale(dx, dy, style[mxConstants.STYLE_ASPECT] == 'fixed');\n\t\t\n\t\tif (style[mxConstants.STYLE_RESIZE_WIDTH] == '1')\n\t\t{\n\t\t\tgeo.width = w * dx;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_WIDTH] == '0')\n\t\t{\n\t\t\tgeo.width = w;\n\t\t}\n\t\t\n\t\tif (style[mxConstants.STYLE_RESIZE_HEIGHT] == '1')\n\t\t{\n\t\t\tgeo.height = h * dy;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_HEIGHT] == '0')\n\t\t{\n\t\t\tgeo.height = h;\n\t\t}\n\t\t\n\t\tif (!this.isCellMovable(cell))\n\t\t{\n\t\t\tgeo.x = x;\n\t\t\tgeo.y = y;\n\t\t}\n\t\t\n\t\tif (!this.isCellResizable(cell))\n\t\t{\n\t\t\tgeo.width = w;\n\t\t\tgeo.height = h;\n\t\t}\n\n\t\tif (this.model.isVertex(cell))\n\t\t{\n\t\t\tthis.cellResized(cell, geo, true, recurse);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendParent\n * \n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.extendParent = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\t\tvar p = this.getCellGeometry(parent);\n\t\t\n\t\tif (parent != null && p != null && !this.isCellCollapsed(parent))\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cell);\n\t\t\t\n\t\t\tif (geo != null && !geo.relative &&\n\t\t\t\t(p.width < geo.x + geo.width ||\n\t\t\t\tp.height < geo.y + geo.height))\n\t\t\t{\n\t\t\t\tp = p.clone();\n\t\t\t\t\n\t\t\t\tp.width = Math.max(p.width, geo.x + geo.width);\n\t\t\t\tp.height = Math.max(p.height, geo.y + geo.height);\n\t\t\t\t\n\t\t\t\tthis.cellsResized([parent], [p], false);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Cell moving\n */\n\n/**\n * Function: importCells\n * \n * Clones and inserts the given cells into the graph using the move\n * method and returns the inserted cells. This shortcut is used if\n * cells are inserted via datatransfer.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be imported.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.importCells = function(cells, dx, dy, target, evt, mapping)\n{\t\n\treturn this.moveCells(cells, dx, dy, true, target, evt, mapping);\n};\n\n/**\n * Function: moveCells\n * \n * Moves or clones the specified cells and moves the cells or clones by the\n * given amount, adding them to the optional target cell. The evt is the\n * mouse event as the mouse was released. The change is carried out using\n * <cellsMoved>. This method fires <mxEvent.MOVE_CELLS> while the\n * transaction is in progress. Returns the cells that were moved.\n * \n * Use the following code to move all cells in the graph.\n * \n * (code)\n * graph.moveCells(graph.getChildCells(null, true, true), 10, 10);\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be moved, cloned or added to the target.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * clone - Boolean indicating if the cells should be cloned. Default is false.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.moveCells = function(cells, dx, dy, clone, target, evt, mapping)\n{\n\tdx = (dx != null) ? dx : 0;\n\tdy = (dy != null) ? dy : 0;\n\tclone = (clone != null) ? clone : false;\n\t\n\tif (cells != null && (dx != 0 || dy != 0 || clone || target != null))\n\t{\n\t\t// Removes descendants with ancestors in cells to avoid multiple moving\n\t\tcells = this.model.getTopmostCells(cells);\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Faster cell lookups to remove relative edge labels with selected\n\t\t\t// terminals to avoid explicit and implicit move at same time\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tvar isSelected = mxUtils.bind(this, function(cell)\n\t\t\t{\n\t\t\t\twhile (cell != null)\n\t\t\t\t{\n\t\t\t\t\tif (dict.get(cell))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcell = this.model.getParent(cell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\t\n\t\t\t// Removes relative edge labels with selected terminals\n\t\t\tvar checked = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\n\t\t\t\tif ((geo == null || !geo.relative) || !this.model.isEdge(parent) ||\n\t\t\t\t\t(!isSelected(this.model.getTerminal(parent, true)) &&\n\t\t\t\t\t!isSelected(this.model.getTerminal(parent, false))))\n\t\t\t\t{\n\t\t\t\t\tchecked.push(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcells = checked;\n\t\t\t\n\t\t\tif (clone)\n\t\t\t{\n\t\t\t\tcells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\ttarget = this.getDefaultParent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t// to avoid forward references in sessions.\n\t\t\t// Need to disable allowNegativeCoordinates if target not null to\n\t\t\t// allow for temporary negative numbers until cellsAdded is called.\n\t\t\tvar previous = this.isAllowNegativeCoordinates();\n\t\t\t\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tthis.setAllowNegativeCoordinates(true);\n\t\t\t}\n\t\t\t\n\t\t\tthis.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove()\n\t\t\t\t\t&& this.isAllowDanglingEdges(), target == null,\n\t\t\t\t\tthis.isExtendParentsOnMove() && target == null);\n\t\t\t\n\t\t\tthis.setAllowNegativeCoordinates(previous);\n\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tvar index = this.model.getChildCount(target);\n\t\t\t\tthis.cellsAdded(cells, target, index, null, null, true);\n\t\t\t}\n\n\t\t\t// Dispatches a move event\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, 'cells', cells,\n\t\t\t\t'dx', dx, 'dy', dy, 'clone', clone, 'target', target, 'event', evt));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsMoved\n * \n * Moves the specified cells by the given vector, disconnecting the cells\n * using disconnectGraph is disconnect is true. This method fires\n * <mxEvent.CELLS_MOVED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsMoved = function(cells, dx, dy, disconnect, constrain, extend)\n{\n\tif (cells != null && (dx != 0 || dy != 0))\n\t{\n\t\textend = (extend != null) ? extend : false;\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (disconnect)\n\t\t\t{\n\t\t\t\tthis.disconnectGraph(cells);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.translateCell(cells[i], dx, dy);\n\t\t\t\t\n\t\t\t\tif (extend && this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\t\t\t\telse if (constrain)\n\t\t\t\t{\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnMove)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED,\n\t\t\t\t'cells', cells, 'dx', dx, 'dy', dy, 'disconnect', disconnect));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: translateCell\n * \n * Translates the geometry of the given cell and stores the new,\n * translated geometry in the model as an atomic change.\n */\nmxGraph.prototype.translateCell = function(cell, dx, dy)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null)\n\t{\n\t\tdx = parseFloat(dx);\n\t\tdy = parseFloat(dy);\n\t\tgeo = geo.clone();\n\t\tgeo.translate(dx, dy);\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, parseFloat(geo.x));\n\t\t\tgeo.y = Math.max(0, parseFloat(geo.y));\n\t\t}\n\t\t\n\t\tif (geo.relative && !this.model.isEdge(cell))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar angle = 0;\n\t\t\t\n\t\t\tif (this.model.isVertex(parent))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(parent);\n\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(parent);\n\t\t\t\t\n\t\t\t\tangle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t}\n\t\t\t\n\t\t\tif (angle != 0)\n\t\t\t{\n\t\t\t\tvar rad = mxUtils.toRadians(-angle);\n\t\t\t\tvar cos = Math.cos(rad);\n\t\t\t\tvar sin = Math.sin(rad);\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(dx, dy), cos, sin, new mxPoint(0, 0));\n\t\t\t\tdx = pt.x;\n\t\t\t\tdy = pt.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (geo.offset == null)\n\t\t\t{\n\t\t\t\tgeo.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgeo.offset.x = parseFloat(geo.offset.x) + dx;\n\t\t\t\tgeo.offset.y = parseFloat(geo.offset.y) + dy;\n\t\t\t}\n\t\t}\n\n\t\tthis.model.setGeometry(cell, geo);\n\t}\n};\n\n/**\n * Function: getCellContainmentArea\n * \n * Returns the <mxRectangle> inside which a cell is to be kept.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the area should be returned.\n */\nmxGraph.prototype.getCellContainmentArea = function(cell)\n{\n\tif (cell != null && !this.model.isEdge(cell))\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\t\t\n\t\tif (parent != null && parent != this.getDefaultParent())\n\t\t{\n\t\t\tvar g = this.model.getGeometry(parent);\n\t\t\t\n\t\t\tif (g != null)\n\t\t\t{\n\t\t\t\tvar x = 0;\n\t\t\t\tvar y = 0;\n\t\t\t\tvar w = g.width;\n\t\t\t\tvar h = g.height;\n\t\t\t\t\n\t\t\t\tif (this.isSwimlane(parent))\n\t\t\t\t{\n\t\t\t\t\tvar size = this.getStartSize(parent);\n\t\t\t\t\t\n\t\t\t\t\tvar state = this.view.getState(parent);\n\t\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(parent);\n\t\t\t\t\tvar dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\t\t\t\t\tvar flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tvar flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;\n\t\t\t\t\t\n\t\t\t\t\tif (dir == mxConstants.DIRECTION_SOUTH || dir == mxConstants.DIRECTION_NORTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = size.width;\n\t\t\t\t\t\tsize.width = size.height;\n\t\t\t\t\t\tsize.height = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((dir == mxConstants.DIRECTION_EAST && !flipV) || (dir == mxConstants.DIRECTION_NORTH && !flipH) ||\n\t\t\t\t\t\t(dir == mxConstants.DIRECTION_WEST && flipV) || (dir == mxConstants.DIRECTION_SOUTH && flipH))\n\t\t\t\t\t{\n\t\t\t\t\t\tx = size.width;\n\t\t\t\t\t\ty = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tw -= size.width;\n\t\t\t\t\th -= size.height;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new mxRectangle(x, y, w, h);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getMaximumGraphBounds\n * \n * Returns the bounds inside which the diagram should be kept as an\n * <mxRectangle>.\n */\nmxGraph.prototype.getMaximumGraphBounds = function()\n{\n\treturn this.maximumGraphBounds;\n};\n\n/**\n * Function: constrainChild\n * \n * Keeps the given cell inside the bounds returned by\n * <getCellContainmentArea> for its parent, according to the rules defined by\n * <getOverlap> and <isConstrainChild>. This modifies the cell's geometry\n * in-place and does not clone it.\n * \n * Parameters:\n * \n * cells - <mxCell> which should be constrained.\n * sizeFirst - Specifies if the size should be changed first. Default is true.\n */\nmxGraph.prototype.constrainChild = function(cell, sizeFirst)\n{\n\tsizeFirst = (sizeFirst != null) ? sizeFirst : true;\n\t\n\tif (cell != null)\n\t{\n\t\tvar geo = this.getCellGeometry(cell);\n\t\t\n\t\tif (geo != null && (this.isConstrainRelativeChildren() || !geo.relative))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar pgeo = this.getCellGeometry(parent);\n\t\t\tvar max = this.getMaximumGraphBounds();\n\t\t\t\n\t\t\t// Finds parent offset\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar off = this.getBoundingBoxFromGeometry([parent], false);\n\t\t\t\t\n\t\t\t\tif (off != null)\n\t\t\t\t{\n\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\t\n\t\t\t\t\tmax.x -= off.x;\n\t\t\t\t\tmax.y -= off.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (this.isConstrainChild(cell))\n\t\t\t{\n\t\t\t\tvar tmp = this.getCellContainmentArea(cell);\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tvar overlap = this.getOverlap(cell);\n\t\n\t\t\t\t\tif (overlap > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = mxRectangle.fromRectangle(tmp);\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp.x -= tmp.width * overlap;\n\t\t\t\t\t\ttmp.y -= tmp.height * overlap;\n\t\t\t\t\t\ttmp.width += 2 * tmp.width * overlap;\n\t\t\t\t\t\ttmp.height += 2 * tmp.height * overlap;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Find the intersection between max and tmp\n\t\t\t\t\tif (max == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\t\tmax.intersect(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar cells = [cell];\n\t\t\t\t\n\t\t\t\tif (!this.isCellCollapsed(cell))\n\t\t\t\t{\n\t\t\t\t\tvar desc = this.model.getDescendants(cell);\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < desc.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.isCellVisible(desc[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcells.push(desc[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar bbox = this.getBoundingBoxFromGeometry(cells, false);\n\t\t\t\t\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\n\t\t\t\t\t// Cumulative horizontal movement\n\t\t\t\t\tvar dx = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (geo.width > max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = geo.width - max.width;\n\t\t\t\t\t\tgeo.width -= dx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.x + bbox.width > max.x + max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x + bbox.width - max.x - max.width - dx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Cumulative vertical movement\n\t\t\t\t\tvar dy = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (geo.height > max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy = geo.height - max.height;\n\t\t\t\t\t\tgeo.height -= dy;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.y + bbox.height > max.y + max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y + bbox.height - max.y - max.height - dy;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.x < max.x)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x - max.x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.y < max.y)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y - max.y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (dx != 0 || dy != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Relative geometries are moved via absolute offset\n\t\t\t\t\t\t\tif (geo.offset == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.offset = new mxPoint();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgeo.offset.x += dx;\n\t\t\t\t\t\t\tgeo.offset.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x += dx;\n\t\t\t\t\t\t\tgeo.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdges\n * \n * Resets the control points of the edges that are connected to the given\n * cells if not both ends of the edge are in the given cells array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> for which the connected edges should be\n * reset.\n */\nmxGraph.prototype.resetEdges = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\t// Prepares faster cells lookup\n\t\tvar dict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t}\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar edges = this.model.getEdges(cells[i]);\n\t\t\t\t\n\t\t\t\tif (edges != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(edges[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);\n\t\t\t\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Checks if one of the terminals is not in the given array\n\t\t\t\t\t\tif (!dict.get(source) || !dict.get(target))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.resetEdge(edges[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.resetEdges(this.model.getChildren(cells[i]));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdge\n * \n * Resets the control points of the given edge.\n * \n * Parameters:\n * \n * edge - <mxCell> whose points should be reset.\n */\nmxGraph.prototype.resetEdge = function(edge)\n{\n\tvar geo = this.model.getGeometry(edge);\n\t\n\t// Resets the control points\n\tif (geo != null && geo.points != null && geo.points.length > 0)\n\t{\n\t\tgeo = geo.clone();\n\t\tgeo.points = [];\n\t\tthis.model.setGeometry(edge, geo);\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Group: Cell connecting and connection constraints\n */\n\n/**\n * Function: getOutlineConstraint\n * \n * Returns the constraint used to connect to the outline of the given state.\n */\nmxGraph.prototype.getOutlineConstraint = function(point, terminalState, me)\n{\n\tif (terminalState.shape != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(terminalState);\n\t\tvar direction = terminalState.style[mxConstants.STYLE_DIRECTION];\n\t\t\n\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tbounds.x += bounds.width / 2 - bounds.height / 2;\n\t\t\tbounds.y += bounds.height / 2 - bounds.width / 2;\n\t\t\tvar tmp = bounds.width;\n\t\t\tbounds.width = bounds.height;\n\t\t\tbounds.height = tmp;\n\t\t}\n\t\n\t\tvar alpha = mxUtils.toRadians(terminalState.shape.getShapeRotation());\n\t\t\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(-alpha);\n\t\t\tvar sin = Math.sin(-alpha);\n\t\n\t\t\tvar ct = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\t\tpoint = mxUtils.getRotatedPoint(point, cos, sin, ct);\n\t\t}\n\n\t\tvar sx = 1;\n\t\tvar sy = 1;\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\t\t\n\t\t// LATER: Add flipping support for image shapes\n\t\tif (this.getModel().isVertex(terminalState.cell))\n\t\t{\n\t\t\tvar flipH = terminalState.style[mxConstants.STYLE_FLIPH];\n\t\t\tvar flipV = terminalState.style[mxConstants.STYLE_FLIPV];\n\t\t\t\n\t\t\t// Legacy support for stencilFlipH/V\n\t\t\tif (terminalState.shape != null && terminalState.shape.stencil != null)\n\t\t\t{\n\t\t\t\tflipH = mxUtils.getValue(terminalState.style, 'stencilFlipH', 0) == 1 || flipH;\n\t\t\t\tflipV = mxUtils.getValue(terminalState.style, 'stencilFlipV', 0) == 1 || flipV;\n\t\t\t}\n\t\t\t\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tvar tmp = flipH;\n\t\t\t\tflipH = flipV;\n\t\t\t\tflipV = tmp;\n\t\t\t}\n\t\t\t\n\t\t\tif (flipH)\n\t\t\t{\n\t\t\t\tsx = -1;\n\t\t\t\tdx = -bounds.width;\n\t\t\t}\n\t\t\t\n\t\t\tif (flipV)\n\t\t\t{\n\t\t\t\tsy = -1;\n\t\t\t\tdy = -bounds.height ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpoint = new mxPoint((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n\t\t\n\t\tvar x = (bounds.width == 0) ? 0 : Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;\n\t\tvar y = (bounds.height == 0) ? 0 : Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;\n\t\t\n\t\treturn new mxConnectionConstraint(new mxPoint(x, y), false);\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getAllConnectionConstraints\n * \n * Returns an array of all <mxConnectionConstraints> for the given terminal. If\n * the shape of the given terminal is a <mxStencilShape> then the constraints\n * of the corresponding <mxStencil> are returned.\n * \n * Parameters:\n * \n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean that specifies if the terminal is the source or target.\n */\nmxGraph.prototype.getAllConnectionConstraints = function(terminal, source)\n{\n\tif (terminal != null && terminal.shape != null && terminal.shape.stencil != null)\n\t{\n\t\treturn terminal.shape.stencil.constraints;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getConnectionConstraint\n * \n * Returns an <mxConnectionConstraint> that describes the given connection\n * point. This result can then be passed to <getConnectionPoint>.\n * \n * Parameters:\n * \n * edge - <mxCellState> that represents the edge.\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n */\nmxGraph.prototype.getConnectionConstraint = function(edge, terminal, source)\n{\n\tvar point = null;\n\tvar x = edge.style[(source) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];\n\n\tif (x != null)\n\t{\n\t\tvar y = edge.style[(source) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];\n\t\t\n\t\tif (y != null)\n\t\t{\n\t\t\tpoint = new mxPoint(parseFloat(x), parseFloat(y));\n\t\t}\n\t}\n\t\n\tvar perimeter = false;\n\t\n\tif (point != null)\n\t{\n\t\tperimeter = mxUtils.getValue(edge.style, (source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, true);\n\t}\n\t\n\treturn new mxConnectionConstraint(point, perimeter);\n};\n\n/**\n * Function: setConnectionConstraint\n * \n * Sets the <mxConnectionConstraint> that describes the given connection point.\n * If no constraint is given then nothing is changed. To remove an existing\n * constraint from the given edge, use an empty constraint instead.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge.\n * terminal - <mxCell> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.setConnectionConstraint = function(edge, terminal, source, constraint)\n{\n\tif (constraint != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tif (constraint == null || constraint.point == null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t}\n\t\t\telse if (constraint.point != null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);\n\t\t\t\t\n\t\t\t\t// Only writes 0 since 1 is default\n\t\t\t\tif (!constraint.perimeter)\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, '0', [edge]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getConnectionPoint\n *\n * Returns the nearest point in the list of absolute points or the center\n * of the opposite terminal.\n * \n * Parameters:\n * \n * vertex - <mxCellState> that represents the vertex.\n * constraint - <mxConnectionConstraint> that represents the connection point\n * constraint as returned by <getConnectionConstraint>.\n */\nmxGraph.prototype.getConnectionPoint = function(vertex, constraint)\n{\n\tvar point = null;\n\t\n\tif (vertex != null && constraint.point != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(vertex);\n        var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\tvar direction = vertex.style[mxConstants.STYLE_DIRECTION];\n\t\tvar r1 = 0;\n\t\t\n\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\tif (direction != null && mxUtils.getValue(vertex.style,\n\t\t\tmxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1) == 1)\n\t\t{\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t\t{\n\t\t\t\tr1 += 270;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t\t{\n\t\t\t\tr1 += 180;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tr1 += 90;\n\t\t\t}\n\n\t\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\t\tdirection == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tbounds.rotate90();\n\t\t\t}\n\t\t}\n\n\t\tpoint = new mxPoint(bounds.x + constraint.point.x * bounds.width,\n\t\t\t\tbounds.y + constraint.point.y * bounds.height);\n\t\t\n\t\t// Rotation for direction before projection on perimeter\n\t\tvar r2 = vertex.style[mxConstants.STYLE_ROTATION] || 0;\n\t\t\n\t\tif (constraint.perimeter)\n\t\t{\n\t\t\tif (r1 != 0)\n\t\t\t{\n\t\t\t\t// Only 90 degrees steps possible here so no trig needed\n\t\t\t\tvar cos = 0;\n\t\t\t\tvar sin = 0;\n\t\t\t\t\n\t\t\t\tif (r1 == 90)\n\t\t\t\t{\n\t\t\t\t\tsin = 1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 180)\n\t\t\t\t{\n\t\t\t\t\tcos = -1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 270)\n\t\t\t\t{\n\t\t\t\t\tsin = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t\t}\n\t\n\t\t\tpoint = this.view.getPerimeterPoint(vertex, point, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr2 += r1;\n\t\t\t\n\t\t\tif (this.getModel().isVertex(vertex.cell))\n\t\t\t{\n\t\t\t\tvar flipH = vertex.style[mxConstants.STYLE_FLIPH] == 1;\n\t\t\t\tvar flipV = vertex.style[mxConstants.STYLE_FLIPV] == 1;\n\t\t\t\t\n\t\t\t\t// Legacy support for stencilFlipH/V\n\t\t\t\tif (vertex.shape != null && vertex.shape.stencil != null)\n\t\t\t\t{\n\t\t\t\t\tflipH = (mxUtils.getValue(vertex.style, 'stencilFlipH', 0) == 1) || flipH;\n\t\t\t\t\tflipV = (mxUtils.getValue(vertex.style, 'stencilFlipV', 0) == 1) || flipV;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (flipH)\n\t\t\t\t{\n\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (flipV)\n\t\t\t\t{\n\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Generic rotation after projection on perimeter\n\t\tif (r2 != 0 && point != null)\n\t\t{\n\t        var rad = mxUtils.toRadians(r2);\n\t        var cos = Math.cos(rad);\n\t        var sin = Math.sin(rad);\n\t        \n\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t}\n\t}\n\t\n\tif (point != null)\n\t{\n\t\tpoint.x = Math.round(point.x);\n\t\tpoint.y = Math.round(point.y);\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: connectCell\n * \n * Connects the specified end of the given edge to the given terminal\n * using <cellConnected> and fires <mxEvent.CONNECT_CELL> while the\n * transaction is in progress. Returns the updated edge.\n * \n * Parameters:\n * \n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.connectCell = function(edge, terminal, source, constraint)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar previous = this.model.getTerminal(edge, source);\n\t\tthis.cellConnected(edge, terminal, source, constraint);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL,\n\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t'previous', previous));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: cellConnected\n * \n * Sets the new terminal for the given edge and resets the edge points if\n * <resetEdgesOnConnect> is true. This method fires\n * <mxEvent.CELL_CONNECTED> while the transaction is in progress.\n * \n * Parameters:\n * \n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - <mxConnectionConstraint> to be used for this connection.\n */\nmxGraph.prototype.cellConnected = function(edge, terminal, source, constraint)\n{\n\tif (edge != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar previous = this.model.getTerminal(edge, source);\n\n\t\t\t// Updates the constraint\n\t\t\tthis.setConnectionConstraint(edge, terminal, source, constraint);\n\t\t\t\n\t\t\t// Checks if the new terminal is a port, uses the ID of the port in the\n\t\t\t// style and the parent of the port as the actual terminal of the edge.\n\t\t\tif (this.isPortsEnabled())\n\t\t\t{\n\t\t\t\tvar id = null;\n\t\n\t\t\t\tif (this.isPort(terminal))\n\t\t\t\t{\n\t\t\t\t\tid = terminal.getId();\n\t\t\t\t\tterminal = this.getTerminalForPort(terminal, source);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Sets or resets all previous information for connecting to a child port\n\t\t\t\tvar key = (source) ? mxConstants.STYLE_SOURCE_PORT :\n\t\t\t\t\tmxConstants.STYLE_TARGET_PORT;\n\t\t\t\tthis.setCellStyles(key, id, [edge]);\n\t\t\t}\n\t\t\t\n\t\t\tthis.model.setTerminal(edge, terminal, source);\n\t\t\t\n\t\t\tif (this.resetEdgesOnConnect)\n\t\t\t{\n\t\t\t\tthis.resetEdge(edge);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED,\n\t\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t\t'previous', previous));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: disconnectGraph\n * \n * Disconnects the given edges from the terminals which are not in the\n * given array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be disconnected.\n */\nmxGraph.prototype.disconnectGraph = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\t\t\t\t\t\t\t\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar tr = this.view.translate;\n\t\t\t\n\t\t\t// Fast lookup for finding cells in array\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(\n\t\t\t\t\t\t\tthis.model.getParent(cells[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null &&\n\t\t\t\t\t\t\tpstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar dx = -pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = -pstate.origin.y;\n\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\n\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (src != null && this.isCellDisconnectable(cells[i], src, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (src == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - tr.y + dy), true);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (trg != null && this.isCellDisconnectable(cells[i], trg, false))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (trg == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - tr.y + dy), false);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Drilldown\n */\n\n/**\n * Function: getCurrentRoot\n * \n * Returns the current root of the displayed cell hierarchy. This is a\n * shortcut to <mxGraphView.currentRoot> in <view>.\n */\nmxGraph.prototype.getCurrentRoot = function()\n{\n\treturn this.view.currentRoot;\n};\n \n/**\n * Function: getTranslateForRoot\n * \n * Returns the translation to be used if the given cell is the root cell as\n * an <mxPoint>. This implementation returns null.\n * \n * Example:\n * \n * To keep the children at their absolute position while stepping into groups,\n * this function can be overridden as follows.\n * \n * (code)\n * var offset = new mxPoint(0, 0);\n * \n * while (cell != null)\n * {\n *   var geo = this.model.getGeometry(cell);\n * \n *   if (geo != null)\n *   {\n *     offset.x -= geo.x;\n *     offset.y -= geo.y;\n *   }\n * \n *   cell = this.model.getParent(cell);\n * }\n * \n * return offset;\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the root.\n */\nmxGraph.prototype.getTranslateForRoot = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, the cell returned by getTerminalForPort should be used as the\n * terminal and the port should be referenced by the ID in either the\n * mxConstants.STYLE_SOURCE_PORT or the or the\n * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.\n * This implementation always returns false.\n * \n * A typical implementation is the following:\n * \n * (code)\n * graph.isPort = function(cell)\n * {\n *   var geo = this.getCellGeometry(cell);\n *   \n *   return (geo != null) ? geo.relative : false;\n * };\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxGraph.prototype.isPort = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getTerminalForPort\n * \n * Returns the terminal to be used for a given port. This implementation\n * always returns the parent cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n * source - If the cell is the source or target port.\n */\nmxGraph.prototype.getTerminalForPort = function(cell, source)\n{\n\treturn this.model.getParent(cell);\n};\n\n/**\n * Function: getChildOffsetForCell\n * \n * Returns the offset to be used for the cells inside the given cell. The\n * root and layer cells may be identified using <mxGraphModel.isRoot> and\n * <mxGraphModel.isLayer>. For all other current roots, the\n * <mxGraphView.currentRoot> field points to the respective cell, so that\n * the following holds: cell == this.view.currentRoot. This implementation\n * returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose offset should be returned.\n */\nmxGraph.prototype.getChildOffsetForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: enterGroup\n * \n * Uses the given cell as the root of the displayed cell hierarchy. If no\n * cell is specified then the selection cell is used. The cell is only used\n * if <isValidRoot> returns true.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> to be used as the new root. Default is the\n * selection cell.\n */\nmxGraph.prototype.enterGroup = function(cell)\n{\n\tcell = cell || this.getSelectionCell();\n\t\n\tif (cell != null && this.isValidRoot(cell))\n\t{\n\t\tthis.view.setCurrentRoot(cell);\n\t\tthis.clearSelection();\n\t}\n};\n\n/**\n * Function: exitGroup\n * \n * Changes the current root to the next valid root in the displayed cell\n * hierarchy.\n */\nmxGraph.prototype.exitGroup = function()\n{\n\tvar root = this.model.getRoot();\n\tvar current = this.getCurrentRoot();\n\t\n\tif (current != null)\n\t{\n\t\tvar next = this.model.getParent(current);\n\t\t\n\t\t// Finds the next valid root in the hierarchy\n\t\twhile (next != root && !this.isValidRoot(next) &&\n\t\t\t\tthis.model.getParent(next) != root)\n\t\t{\n\t\t\tnext = this.model.getParent(next);\n\t\t}\n\t\t\n\t\t// Clears the current root if the new root is\n\t\t// the model's root or one of the layers.\n\t\tif (next == root || this.model.getParent(next) == root)\n\t\t{\n\t\t\tthis.view.setCurrentRoot(null);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.view.setCurrentRoot(next);\n\t\t}\n\t\t\n\t\tvar state = this.view.getState(current);\n\t\t\n\t\t// Selects the previous root in the graph\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: home\n * \n * Uses the root of the model as the root of the displayed cell hierarchy\n * and selects the previous root.\n */\nmxGraph.prototype.home = function()\n{\n\tvar current = this.getCurrentRoot();\n\t\n\tif (current != null)\n\t{\n\t\tthis.view.setCurrentRoot(null);\n\t\tvar state = this.view.getState(current);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: isValidRoot\n * \n * Returns true if the given cell is a valid root for the cell display\n * hierarchy. This implementation returns true for all non-null values.\n * \n * Parameters:\n * \n * cell - <mxCell> which should be checked as a possible root.\n */\nmxGraph.prototype.isValidRoot = function(cell)\n{\n\treturn (cell != null);\n};\n\n/**\n * Group: Graph display\n */\n \n/**\n * Function: getGraphBounds\n * \n * Returns the bounds of the visible graph. Shortcut to\n * <mxGraphView.getGraphBounds>. See also: <getBoundingBoxFromGeometry>.\n */\n mxGraph.prototype.getGraphBounds = function()\n {\n \treturn this.view.getGraphBounds();\n };\n\n/**\n * Function: getCellBounds\n * \n * Returns the scaled, translated bounds for the given cell. See\n * <mxGraphView.getBounds> for arrays.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be returned.\n * includeEdge - Optional boolean that specifies if the bounds of\n * the connected edges should be included. Default is false.\n * includeDescendants - Optional boolean that specifies if the bounds\n * of all descendants should be included. Default is false.\n */\nmxGraph.prototype.getCellBounds = function(cell, includeEdges, includeDescendants)\n{\n\tvar cells = [cell];\n\t\n\t// Includes all connected edges\n\tif (includeEdges)\n\t{\n\t\tcells = cells.concat(this.model.getEdges(cell));\n\t}\n\t\n\tvar result = this.view.getBounds(cells);\n\t\n\t// Recursively includes the bounds of the children\n\tif (includeDescendants)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar tmp = this.getCellBounds(this.model.getChildAt(cell, i),\n\t\t\t\tincludeEdges, true);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\tresult.add(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getBoundingBoxFromGeometry\n * \n * Returns the bounding box for the geometries of the vertices in the\n * given array of cells. This can be used to find the graph bounds during\n * a layout operation (ie. before the last endUpdate) as follows:\n * \n * (code)\n * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);\n * var bounds = graph.getBoundingBoxFromGeometry(cells, true);\n * (end)\n * \n * This can then be used to move cells to the origin:\n * \n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))\n * }\n * (end)\n * \n * Or to translate the graph view:\n * \n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));\n * }\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be returned.\n * includeEdges - Specifies if edge bounds should be included by computing\n * the bounding box for all points in geometry. Default is false.\n */\nmxGraph.prototype.getBoundingBoxFromGeometry = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : false;\n\tvar result = null;\n\t\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (includeEdges || this.model.isVertex(cells[i]))\n\t\t\t{\n\t\t\t\t// Computes the bounding box for the points in the geometry\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\t\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = null;\n\t\t\t\t\t\n\t\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar addPoint = function(pt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pt != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp = new mxRectangle(pt.x, pt.y, 0, 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp.add(new mxRectangle(pt.x, pt.y, 0, 0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], true) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(true));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], false) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(false));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar pts = geo.points;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (pts != null && pts.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = new mxRectangle(pts[0].x, pts[0].y, 0, 0);\n\n\t\t\t\t\t\t\tfor (var j = 1; j < pts.length; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddPoint(pts[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbbox = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && parent != this.view.currentRoot)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox = mxRectangle.fromRectangle(geo);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bbox != null && geo.offset != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox.x += geo.offset.x;\n\t\t\t\t\t\t\tbbox.y += geo.offset.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (result == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: refresh\n * \n * Clears all cell states or the states for the hierarchy starting at the\n * given cell and validates the graph. This fires a refresh event as the\n * last step.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> for which the cell states should be cleared.\n */\nmxGraph.prototype.refresh = function(cell)\n{\n\tthis.view.clear(cell, cell == null);\n\tthis.view.validate();\n\tthis.sizeDidChange();\n\tthis.fireEvent(new mxEventObject(mxEvent.REFRESH));\n};\n\n/**\n * Function: snap\n * \n * Snaps the given numeric value to the grid if <gridEnabled> is true.\n * \n * Parameters:\n * \n * value - Numeric value to be snapped to the grid.\n */\nmxGraph.prototype.snap = function(value)\n{\n\tif (this.gridEnabled)\n\t{\n\t\tvalue = Math.round(value / this.gridSize ) * this.gridSize;\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: panGraph\n * \n * Shifts the graph display by the given amount. This is used to preview\n * panning operations, use <mxGraphView.setTranslate> to set a persistent\n * translation of the view. Fires <mxEvent.PAN>.\n * \n * Parameters:\n * \n * dx - Amount to shift the graph along the x-axis.\n * dy - Amount to shift the graph along the y-axis.\n */\nmxGraph.prototype.panGraph = function(dx, dy)\n{\n\tif (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.container.scrollLeft = -dx;\n\t\tthis.container.scrollTop = -dy;\n\t}\n\telse\n\t{\n\t\tvar canvas = this.view.getCanvas();\n\t\t\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\t// Puts everything inside the container in a DIV so that it\n\t\t\t// can be moved without changing the state of the container\n\t\t\tif (dx == 0 && dy == 0)\n\t\t\t{\n\t\t\t\t// Workaround for ignored removeAttribute on SVG element in IE9 standards\n\t\t\t\tif (mxClient.IS_IE)\n\t\t\t\t{\n\t\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcanvas.removeAttribute('transform');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.shiftPreview1 != null)\n\t\t\t\t{\n\t\t\t\t\tvar child = this.shiftPreview1.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview1.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview1 = null;\n\t\t\t\t\t\n\t\t\t\t\tthis.container.appendChild(canvas.parentNode);\n\t\t\t\t\t\n\t\t\t\t\tchild = this.shiftPreview2.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview2.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview2.parentNode.removeChild(this.shiftPreview2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview2 = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t\t\n\t\t\t\tif (this.shiftPreview1 == null)\n\t\t\t\t{\n\t\t\t\t\t// Needs two divs for stuff before and after the SVG element\n\t\t\t\t\tthis.shiftPreview1 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview1.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview1.style.overflow = 'visible';\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview2 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview2.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview2.style.overflow = 'visible';\n\n\t\t\t\t\tvar current = this.shiftPreview1;\n\t\t\t\t\tvar child = this.container.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// SVG element is moved via transform attribute\n\t\t\t\t\t\tif (child != canvas.parentNode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent.appendChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = this.shiftPreview2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Inserts elements only if not empty\n\t\t\t\t\tif (this.shiftPreview1.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.insertBefore(this.shiftPreview1, canvas.parentNode);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.shiftPreview2.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.appendChild(this.shiftPreview2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.shiftPreview1.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview1.style.top = dy + 'px';\n\t\t\t\tthis.shiftPreview2.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview2.style.top = dy + 'px';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcanvas.style.left = dx + 'px';\n\t\t\tcanvas.style.top = dy + 'px';\n\t\t}\n\t\t\n\t\tthis.panDx = dx;\n\t\tthis.panDy = dy;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN));\n\t}\n};\n\n/**\n * Function: zoomIn\n * \n * Zooms into the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomIn = function()\n{\n\tthis.zoom(this.zoomFactor);\n};\n\n/**\n * Function: zoomOut\n * \n * Zooms out of the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomOut = function()\n{\n\tthis.zoom(1 / this.zoomFactor);\n};\n\n/**\n * Function: zoomActual\n * \n * Resets the zoom and panning in the view.\n */\nmxGraph.prototype.zoomActual = function()\n{\n\tif (this.view.scale == 1)\n\t{\n\t\tthis.view.setTranslate(0, 0);\n\t}\n\telse\n\t{\n\t\tthis.view.translate.x = 0;\n\t\tthis.view.translate.y = 0;\n\n\t\tthis.view.setScale(1);\n\t}\n};\n\n/**\n * Function: zoomTo\n * \n * Zooms the graph to the given scale with an optional boolean center\n * argument, which is passd to <zoom>.\n */\nmxGraph.prototype.zoomTo = function(scale, center)\n{\n\tthis.zoom(scale / this.view.scale, center);\n};\n\n/**\n * Function: center\n * \n * Centers the graph in the container.\n * \n * Parameters:\n * \n * horizontal - Optional boolean that specifies if the graph should be centered\n * horizontally. Default is true.\n * vertical - Optional boolean that specifies if the graph should be centered\n * vertically. Default is true.\n * cx - Optional float that specifies the horizontal center. Default is 0.5.\n * cy - Optional float that specifies the vertical center. Default is 0.5.\n */\nmxGraph.prototype.center = function(horizontal, vertical, cx, cy)\n{\n\thorizontal = (horizontal != null) ? horizontal : true;\n\tvertical = (vertical != null) ? vertical : true;\n\tcx = (cx != null) ? cx : 0.5;\n\tcy = (cy != null) ? cy : 0.5;\n\t\n\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\tvar cw = this.container.clientWidth;\n\tvar ch = this.container.clientHeight;\n\tvar bounds = this.getGraphBounds();\n\n\tvar t = this.view.translate;\n\tvar s = this.view.scale;\n\n\tvar dx = (horizontal) ? cw - bounds.width : 0;\n\tvar dy = (vertical) ? ch - bounds.height : 0;\n\t\n\tif (!hasScrollbars)\n\t{\n\t\tthis.view.setTranslate((horizontal) ? Math.floor(t.x - bounds.x * s + dx * cx / s) : t.x,\n\t\t\t(vertical) ? Math.floor(t.y - bounds.y * s + dy * cy / s) : t.y);\n\t}\n\telse\n\t{\n\t\tbounds.x -= t.x;\n\t\tbounds.y -= t.y;\n\t\n\t\tvar sw = this.container.scrollWidth;\n\t\tvar sh = this.container.scrollHeight;\n\t\t\n\t\tif (sw > cw)\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t\t\n\t\tif (sh > ch)\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\n\t\tthis.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));\n\t\tthis.container.scrollLeft = (sw - cw) / 2;\n\t\tthis.container.scrollTop = (sh - ch) / 2;\n\t}\n};\n\n/**\n * Function: zoom\n * \n * Zooms the graph using the given factor. Center is an optional boolean\n * argument that keeps the graph scrolled to the center. If the center argument\n * is omitted, then <centerZoom> will be used as its value.\n */\nmxGraph.prototype.zoom = function(factor, center)\n{\n\tcenter = (center != null) ? center : this.centerZoom;\n\tvar scale = Math.round(this.view.scale * factor * 100) / 100;\n\tvar state = this.view.getState(this.getSelectionCell());\n\tfactor = scale / this.view.scale;\n\t\n\tif (this.keepSelectionVisibleOnZoom && state != null)\n\t{\n\t\tvar rect = new mxRectangle(state.x * factor, state.y * factor,\n\t\t\tstate.width * factor, state.height * factor);\n\t\t\n\t\t// Refreshes the display only once if a scroll is carried out\n\t\tthis.view.scale = scale;\n\t\t\n\t\tif (!this.scrollRectToVisible(rect))\n\t\t{\n\t\t\tthis.view.revalidate();\n\t\t\t\n\t\t\t// Forces an event to be fired but does not revalidate again\n\t\t\tthis.view.setScale(scale);\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\t\t\n\t\tif (center && !hasScrollbars)\n\t\t{\n\t\t\tvar dx = this.container.offsetWidth;\n\t\t\tvar dy = this.container.offsetHeight;\n\t\t\t\n\t\t\tif (factor > 1)\n\t\t\t{\n\t\t\t\tvar f = (factor - 1) / (scale * 2);\n\t\t\t\tdx *= -f;\n\t\t\t\tdy *= -f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar f = (1 / factor - 1) / (this.view.scale * 2);\n\t\t\t\tdx *= f;\n\t\t\t\tdy *= f;\n\t\t\t}\n\n\t\t\tthis.view.scaleAndTranslate(scale,\n\t\t\t\tthis.view.translate.x + dx,\n\t\t\t\tthis.view.translate.y + dy);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Allows for changes of translate and scrollbars during setscale\n\t\t\tvar tx = this.view.translate.x;\n\t\t\tvar ty = this.view.translate.y;\n\t\t\tvar sl = this.container.scrollLeft;\n\t\t\tvar st = this.container.scrollTop;\n\t\t\t\n\t\t\tthis.view.setScale(scale);\n\t\t\t\n\t\t\tif (hasScrollbars)\n\t\t\t{\n\t\t\t\tvar dx = 0;\n\t\t\t\tvar dy = 0;\n\t\t\t\t\n\t\t\t\tif (center)\n\t\t\t\t{\n\t\t\t\t\tdx = this.container.offsetWidth * (factor - 1) / 2;\n\t\t\t\t\tdy = this.container.offsetHeight * (factor - 1) / 2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);\n\t\t\t\tthis.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: zoomToRect\n * \n * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect\n * ratio as the display container, it is increased in the smaller relative dimension only\n * until the aspect match. The original rectangle is centralised within this expanded one.\n * \n * Note that the input rectangular must be un-scaled and un-translated.\n * \n * Parameters:\n * \n * rect - The un-scaled and un-translated rectangluar region that should be just visible \n * after the operation\n */\nmxGraph.prototype.zoomToRect = function(rect)\n{\n\tvar scaleX = this.container.clientWidth / rect.width;\n\tvar scaleY = this.container.clientHeight / rect.height;\n\tvar aspectFactor = scaleX / scaleY;\n\n\t// Remove any overlap of the rect outside the client area\n\trect.x = Math.max(0, rect.x);\n\trect.y = Math.max(0, rect.y);\n\tvar rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\tvar rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\trect.width = rectRight - rect.x;\n\trect.height = rectBottom - rect.y;\n\n\t// The selection area has to be increased to the same aspect\n\t// ratio as the container, centred around the centre point of the \n\t// original rect passed in.\n\tif (aspectFactor < 1.0)\n\t{\n\t\t// Height needs increasing\n\t\tvar newHeight = rect.height / aspectFactor;\n\t\tvar deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n\t\trect.height = newHeight;\n\t\t\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar upperBuffer = Math.min(rect.y , deltaHeightBuffer);\n\t\trect.y = rect.y - upperBuffer;\n\t\t\n\t\t// Check if the bottom has extended too far\n\t\trectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\t\trect.height = rectBottom - rect.y;\n\t}\n\telse\n\t{\n\t\t// Width needs increasing\n\t\tvar newWidth = rect.width * aspectFactor;\n\t\tvar deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n\t\trect.width = newWidth;\n\t\t\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar leftBuffer = Math.min(rect.x , deltaWidthBuffer);\n\t\trect.x = rect.x - leftBuffer;\n\t\t\n\t\t// Check if the right hand side has extended too far\n\t\trectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\t\trect.width = rectRight - rect.x;\n\t}\n\n\tvar scale = this.container.clientWidth / rect.width;\n\tvar newScale = this.view.scale * scale;\n\n\tif (!mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.view.scaleAndTranslate(newScale, (this.view.translate.x - rect.x / this.view.scale), (this.view.translate.y - rect.y / this.view.scale));\n\t}\n\telse\n\t{\n\t\tthis.view.setScale(newScale);\n\t\tthis.container.scrollLeft = Math.round(rect.x * scale);\n\t\tthis.container.scrollTop = Math.round(rect.y * scale);\n\t}\n};\n\n/**\n * Function: scrollCellToVisible\n * \n * Pans the graph so that it shows the given cell. Optionally the cell may\n * be centered in the container.\n * \n * To center a given graph if the <container> has no scrollbars, use the following code.\n * \n * [code]\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\n * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\n * [/code]\n * \n * Parameters:\n * \n * cell - <mxCell> to be made visible.\n * center - Optional boolean flag. Default is false.\n */\nmxGraph.prototype.scrollCellToVisible = function(cell, center)\n{\n\tvar x = -this.view.translate.x;\n\tvar y = -this.view.translate.y;\n\n\tvar state = this.view.getState(cell);\n\n\tif (state != null)\n\t{\n\t\tvar bounds = new mxRectangle(x + state.x, y + state.y, state.width,\n\t\t\tstate.height);\n\n\t\tif (center && this.container != null)\n\t\t{\n\t\t\tvar w = this.container.clientWidth;\n\t\t\tvar h = this.container.clientHeight;\n\n\t\t\tbounds.x = bounds.getCenterX() - w / 2;\n\t\t\tbounds.width = w;\n\t\t\tbounds.y = bounds.getCenterY() - h / 2;\n\t\t\tbounds.height = h;\n\t\t}\n\t\t\n\t\tvar tr = new mxPoint(this.view.translate.x, this.view.translate.y);\n\n\t\tif (this.scrollRectToVisible(bounds))\n\t\t{\n\t\t\t// Triggers an update via the view's event source\n\t\t\tvar tr2 = new mxPoint(this.view.translate.x, this.view.translate.y);\n\t\t\tthis.view.translate.x = tr.x;\n\t\t\tthis.view.translate.y = tr.y;\n\t\t\tthis.view.setTranslate(tr2.x, tr2.y);\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollRectToVisible\n * \n * Pans the graph so that it shows the given rectangle.\n * \n * Parameters:\n * \n * rect - <mxRectangle> to be made visible.\n */\nmxGraph.prototype.scrollRectToVisible = function(rect)\n{\n\tvar isChanged = false;\n\t\n\tif (rect != null)\n\t{\n\t\tvar w = this.container.offsetWidth;\n\t\tvar h = this.container.offsetHeight;\n\n        var widthLimit = Math.min(w, rect.width);\n        var heightLimit = Math.min(h, rect.height);\n\n\t\tif (mxUtils.hasScrollbars(this.container))\n\t\t{\n\t\t\tvar c = this.container;\n\t\t\trect.x += this.view.translate.x;\n\t\t\trect.y += this.view.translate.y;\n\t\t\tvar dx = c.scrollLeft - rect.x;\n\t\t\tvar ddx = Math.max(dx - c.scrollLeft, 0);\n\n\t\t\tif (dx > 0)\n\t\t\t{\n\t\t\t\tc.scrollLeft -= dx + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;\n\n\t\t\t\tif (dx > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft += dx + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dy = c.scrollTop - rect.y;\n\t\t\tvar ddy = Math.max(0, dy - c.scrollTop);\n\n\t\t\tif (dy > 0)\n\t\t\t{\n\t\t\t\tc.scrollTop -= dy + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = rect.y + heightLimit - c.scrollTop - c.clientHeight;\n\n\t\t\t\tif (dy > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop += dy + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0))\n\t\t\t{\n\t\t\t\tthis.view.setTranslate(ddx, ddy);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar x = -this.view.translate.x;\n\t\t\tvar y = -this.view.translate.y;\n\n\t\t\tvar s = this.view.scale;\n\n\t\t\tif (rect.x + widthLimit > x + w)\n\t\t\t{\n\t\t\t\tthis.view.translate.x -= (rect.x + widthLimit - w - x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y + heightLimit > y + h)\n\t\t\t{\n\t\t\t\tthis.view.translate.y -= (rect.y + heightLimit - h - y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.x < x)\n\t\t\t{\n\t\t\t\tthis.view.translate.x += (x - rect.x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y  < y)\n\t\t\t{\n\t\t\t\tthis.view.translate.y += (y - rect.y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (isChanged)\n\t\t\t{\n\t\t\t\tthis.view.refresh();\n\t\t\t\t\n\t\t\t\t// Repaints selection marker (ticket 18)\n\t\t\t\tif (this.selectionCellsHandler != null)\n\t\t\t\t{\n\t\t\t\t\tthis.selectionCellsHandler.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn isChanged;\n};\n\n/**\n * Function: getCellGeometry\n * \n * Returns the <mxGeometry> for the given cell. This implementation uses\n * <mxGraphModel.getGeometry>. Subclasses can override this to implement\n * specific geometries for cells in only one graph, that is, it can return\n * geometries that depend on the current state of the view.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraph.prototype.getCellGeometry = function(cell)\n{\n\treturn this.model.getGeometry(cell);\n};\n\n/**\n * Function: isCellVisible\n * \n * Returns true if the given cell is visible in this graph. This\n * implementation uses <mxGraphModel.isVisible>. Subclassers can override\n * this to implement specific visibility for cells in only one graph, that\n * is, without affecting the visible state of the cell.\n * \n * When using dynamic filter expressions for cell visibility, then the\n * graph should be revalidated after the filter expression has changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraph.prototype.isCellVisible = function(cell)\n{\n\treturn this.model.isVisible(cell);\n};\n\n/**\n * Function: isCellCollapsed\n * \n * Returns true if the given cell is collapsed in this graph. This\n * implementation uses <mxGraphModel.isCollapsed>. Subclassers can override\n * this to implement specific collapsed states for cells in only one graph,\n * that is, without affecting the collapsed state of the cell.\n * \n * When using dynamic filter expressions for the collapsed state, then the\n * graph should be revalidated after the filter expression has changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraph.prototype.isCellCollapsed = function(cell)\n{\n\treturn this.model.isCollapsed(cell);\n};\n\n/**\n * Function: isCellConnectable\n * \n * Returns true if the given cell is connectable in this graph. This\n * implementation uses <mxGraphModel.isConnectable>. Subclassers can override\n * this to implement specific connectable states for cells in only one graph,\n * that is, without affecting the connectable state of the cell in the model.\n * \n * Parameters:\n * \n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraph.prototype.isCellConnectable = function(cell)\n{\n\treturn this.model.isConnectable(cell);\n};\n\n/**\n * Function: isOrthogonal\n * \n * Returns true if perimeter points should be computed such that the\n * resulting edge has only horizontal or vertical segments.\n * \n * Parameters:\n * \n * edge - <mxCellState> that represents the edge.\n */\nmxGraph.prototype.isOrthogonal = function(edge)\n{\n\tvar orthogonal = edge.style[mxConstants.STYLE_ORTHOGONAL];\n\t\n\tif (orthogonal != null)\n\t{\n\t\treturn orthogonal;\n\t}\n\t\n\tvar tmp = this.view.getEdgeStyle(edge);\n\t\n\treturn tmp == mxEdgeStyle.SegmentConnector ||\n\t\ttmp == mxEdgeStyle.ElbowConnector ||\n\t\ttmp == mxEdgeStyle.SideToSide ||\n\t\ttmp == mxEdgeStyle.TopToBottom ||\n\t\ttmp == mxEdgeStyle.EntityRelation ||\n\t\ttmp == mxEdgeStyle.OrthConnector;\n};\n\n/**\n * Function: isLoop\n * \n * Returns true if the given cell state is a loop.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents a potential loop.\n */\nmxGraph.prototype.isLoop = function(state)\n{\n\tvar src = state.getVisibleTerminalState(true);\n\tvar trg = state.getVisibleTerminalState(false);\n\t\n\treturn (src != null && src == trg);\n};\n\n/**\n * Function: isCloneEvent\n * \n * Returns true if the given event is a clone event. This implementation\n * returns true if control is pressed.\n */\nmxGraph.prototype.isCloneEvent = function(evt)\n{\n\treturn mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isTransparentClickEvent\n * \n * Hook for implementing click-through behaviour on selected cells. If this\n * returns true the cell behind the selected cell will be selected. This\n * implementation returns false;\n */\nmxGraph.prototype.isTransparentClickEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Function: isToggleEvent\n * \n * Returns true if the given event is a toggle event. This implementation\n * returns true if the meta key (Cmd) is pressed on Macs or if control is\n * pressed on any other platform.\n */\nmxGraph.prototype.isToggleEvent = function(evt)\n{\n\treturn (mxClient.IS_MAC) ? mxEvent.isMetaDown(evt) : mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isGridEnabledEvent\n * \n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isGridEnabledEvent = function(evt)\n{\n\treturn evt != null && !mxEvent.isAltDown(evt);\n};\n\n/**\n * Function: isConstrainedEvent\n * \n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isConstrainedEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: isIgnoreTerminalEvent\n * \n * Returns true if the given mouse event should not allow any connections to be\n * made. This implementation returns false.\n */\nmxGraph.prototype.isIgnoreTerminalEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Group: Validation\n */\n\n/**\n * Function: validationAlert\n * \n * Displays the given validation error in a dialog. This implementation uses\n * mxUtils.alert.\n */\nmxGraph.prototype.validationAlert = function(message)\n{\n\tmxUtils.alert(message);\n};\n\n/**\n * Function: isEdgeValid\n * \n * Checks if the return value of <getEdgeValidationError> for the given\n * arguments is null.\n *  \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.isEdgeValid = function(edge, source, target)\n{\n\treturn this.getEdgeValidationError(edge, source, target) == null;\n};\n\n/**\n * Function: getEdgeValidationError\n * \n * Returns the validation error message to be displayed when inserting or\n * changing an edges' connectivity. A return value of null means the edge\n * is valid, a return value of '' means it's not valid, but do not display\n * an error message. Any other (non-empty) string returned from this method\n * is displayed as an error message when trying to connect an edge to a\n * source and target. This implementation uses the <multiplicities>, and\n * checks <multigraph>, <allowDanglingEdges> and <allowLoops> to generate\n * validation errors.\n * \n * For extending this method with specific checks for source/target cells,\n * the method can be extended as follows. Returning an empty string means\n * the edge is invalid with no error message, a non-null string specifies\n * the error message, and null means the edge is valid.\n * \n * (code)\n * graph.getEdgeValidationError = function(edge, source, target)\n * {\n *   if (source != null && target != null &&\n *     this.model.getValue(source) != null &&\n *     this.model.getValue(target) != null)\n *   {\n *     if (target is not valid for source)\n *     {\n *       return 'Invalid Target';\n *     }\n *   }\n *   \n *   // \"Supercall\"\n *   return mxGraph.prototype.getEdgeValidationError.apply(this, arguments);\n * }\n * (end)\n *  \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.getEdgeValidationError = function(edge, source, target)\n{\n\tif (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null))\n\t{\n\t\treturn '';\n\t}\n\t\n\tif (edge != null && this.model.getTerminal(edge, true) == null &&\n\t\tthis.model.getTerminal(edge, false) == null)\t\n\t{\n\t\treturn null;\n\t}\n\t\n\t// Checks if we're dealing with a loop\n\tif (!this.allowLoops && source == target && source != null)\n\t{\n\t\treturn '';\n\t}\n\t\n\t// Checks if the connection is generally allowed\n\tif (!this.isValidConnection(source, target))\n\t{\n\t\treturn '';\n\t}\n\n\tif (source != null && target != null)\n\t{\n\t\tvar error = '';\n\n\t\t// Checks if the cells are already connected\n\t\t// and adds an error message if required\t\t\t\n\t\tif (!this.multigraph)\n\t\t{\n\t\t\tvar tmp = this.model.getEdgesBetween(source, target, true);\n\t\t\t\n\t\t\t// Checks if the source and target are not connected by another edge\n\t\t\tif (tmp.length > 1 || (tmp.length == 1 && tmp[0] != edge))\n\t\t\t{\n\t\t\t\terror += (mxResources.get(this.alreadyConnectedResource) ||\n\t\t\t\t\tthis.alreadyConnectedResource)+'\\n';\n\t\t\t}\n\t\t}\n\n\t\t// Gets the number of outgoing edges from the source\n\t\t// and the number of incoming edges from the target\n\t\t// without counting the edge being currently changed.\n\t\tvar sourceOut = this.model.getDirectedEdgeCount(source, true, edge);\n\t\tvar targetIn = this.model.getDirectedEdgeCount(target, false, edge);\n\n\t\t// Checks the change against each multiplicity rule\n\t\tif (this.multiplicities != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t\t{\n\t\t\t\tvar err = this.multiplicities[i].check(this, edge, source,\n\t\t\t\t\ttarget, sourceOut, targetIn);\n\t\t\t\t\n\t\t\t\tif (err != null)\n\t\t\t\t{\n\t\t\t\t\terror += err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validates the source and target terminals independently\n\t\tvar err = this.validateEdge(edge, source, target);\n\t\t\n\t\tif (err != null)\n\t\t{\n\t\t\terror += err;\n\t\t}\n\t\t\n\t\treturn (error.length > 0) ? error : null;\n\t}\n\t\n\treturn (this.allowDanglingEdges) ? null : '';\n};\n\n/**\n * Function: validateEdge\n * \n * Hook method for subclassers to return an error message for the given\n * edge and terminals. This implementation returns null.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.validateEdge = function(edge, source, target)\n{\n\treturn null;\n};\n\n/**\n * Function: validateGraph\n * \n * Validates the graph by validating each descendant of the given cell or\n * the root of the model. Context is an object that contains the validation\n * state for the complete validation run. The validation errors are\n * attached to their cells using <setCellWarning>. Returns null in the case of\n * successful validation or an array of strings (warnings) in the case of\n * failed validations.\n * \n * Paramters:\n * \n * cell - Optional <mxCell> to start the validation recursion. Default is\n * the graph root.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateGraph = function(cell, context)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tcontext = (context != null) ? context : new Object();\n\t\n\tvar isValid = true;\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar tmp = this.model.getChildAt(cell, i);\n\t\tvar ctx = context;\n\t\t\n\t\tif (this.isValidRoot(tmp))\n\t\t{\n\t\t\tctx = new Object();\n\t\t}\n\t\t\n\t\tvar warn = this.validateGraph(tmp, ctx);\n\t\t\n\t\tif (warn != null)\n\t\t{\n\t\t\tthis.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.setCellWarning(tmp, null);\n\t\t}\n\t\t\n\t\tisValid = isValid && warn == null;\n\t}\n\t\n\tvar warning = '';\n\t\n\t// Adds error for invalid children if collapsed (children invisible)\n\tif (this.isCellCollapsed(cell) && !isValid)\n\t{\n\t\twarning += (mxResources.get(this.containsValidationErrorsResource) ||\n\t\t\tthis.containsValidationErrorsResource) + '\\n';\n\t}\n\t\n\t// Checks edges and cells using the defined multiplicities\n\tif (this.model.isEdge(cell))\n\t{\n\t\twarning += this.getEdgeValidationError(cell,\n\t\tthis.model.getTerminal(cell, true),\n\t\tthis.model.getTerminal(cell, false)) || '';\n\t}\n\telse\n\t{\n\t\twarning += this.getCellValidationError(cell) || '';\n\t}\n\t\n\t// Checks custom validation rules\n\tvar err = this.validateCell(cell, context);\n\t\n\tif (err != null)\n\t{\n\t\twarning += err;\n\t}\n\t\n\t// Updates the display with the warning icons\n\t// before any potential alerts are displayed.\n\t// LATER: Move this into addCellOverlay. Redraw\n\t// should check if overlay was added or removed.\n\tif (this.model.getParent(cell) == null)\n\t{\n\t\tthis.view.validate();\n\t}\n\n\treturn (warning.length > 0 || !isValid) ? warning : null;\n};\n\n/**\n * Function: getCellValidationError\n * \n * Checks all <multiplicities> that cannot be enforced while the graph is\n * being modified, namely, all multiplicities that require a minimum of\n * 1 edge.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the multiplicities should be checked.\n */\nmxGraph.prototype.getCellValidationError = function(cell)\n{\n\tvar outCount = this.model.getDirectedEdgeCount(cell, true);\n\tvar inCount = this.model.getDirectedEdgeCount(cell, false);\n\tvar value = this.model.getValue(cell);\n\tvar error = '';\n\n\tif (this.multiplicities != null)\n\t{\n\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t{\n\t\t\tvar rule = this.multiplicities[i];\n\t\t\t\n\t\t\tif (rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\trule.attr, rule.value) && (outCount > rule.max ||\n\t\t\t\toutCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t\telse if (!rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\t\trule.attr, rule.value) && (inCount > rule.max ||\n\t\t\t\t\tinCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: validateCell\n * \n * Hook method for subclassers to return an error message for the given\n * cell and validation context. This implementation returns null. Any HTML\n * breaks will be converted to linefeeds in the calling method.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to validate.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateCell = function(cell, context)\n{\n\treturn null;\n};\n\n/**\n * Group: Graph appearance\n */\n\n/**\n * Function: getBackgroundImage\n * \n * Returns the <backgroundImage> as an <mxImage>.\n */\nmxGraph.prototype.getBackgroundImage = function()\n{\n\treturn this.backgroundImage;\n};\n\n/**\n * Function: setBackgroundImage\n * \n * Sets the new <backgroundImage>.\n * \n * Parameters:\n * \n * image - New <mxImage> to be used for the background.\n */\nmxGraph.prototype.setBackgroundImage = function(image)\n{\n\tthis.backgroundImage = image;\n};\n\n/**\n * Function: getFoldingImage\n * \n * Returns the <mxImage> used to display the collapsed state of\n * the specified cell state. This returns null for all edges.\n */\nmxGraph.prototype.getFoldingImage = function(state)\n{\n\tif (state != null && this.foldingEnabled && !this.getModel().isEdge(state.cell))\n\t{\n\t\tvar tmp = this.isCellCollapsed(state.cell);\n\t\t\n\t\tif (this.isCellFoldable(state.cell, !tmp))\n\t\t{\n\t\t\treturn (tmp) ? this.collapsedImage : this.expandedImage;\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: convertValueToString\n * \n * Returns the textual representation for the given cell. This\n * implementation returns the nodename or string-representation of the user\n * object.\n *\n * Example:\n * \n * The following returns the label attribute from the cells user\n * object if it is an XML node.\n * \n * (code)\n * graph.convertValueToString = function(cell)\n * {\n * \treturn cell.getAttribute('label');\n * }\n * (end)\n * \n * See also: <cellLabelChanged>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose textual representation should be returned.\n */\nmxGraph.prototype.convertValueToString = function(cell)\n{\n\tvar value = this.model.getValue(cell);\n\t\n\tif (value != null)\n\t{\n\t\tif (mxUtils.isNode(value))\n\t\t{\n\t\t\treturn value.nodeName;\n\t\t}\n\t\telse if (typeof(value.toString) == 'function')\n\t\t{\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\treturn '';\n};\n\n/**\n * Function: getLabel\n * \n * Returns a string or DOM node that represents the label for the given\n * cell. This implementation uses <convertValueToString> if <labelsVisible>\n * is true. Otherwise it returns an empty string.\n * \n * To truncate a label to match the size of the cell, the following code\n * can be used.\n * \n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var label = mxGraph.prototype.getLabel.apply(this, arguments);\n * \n *   if (label != null && this.model.isVertex(cell))\n *   {\n *     var geo = this.getCellGeometry(cell);\n * \n *     if (geo != null)\n *     {\n *       var max = parseInt(geo.width / 8);\n * \n *       if (label.length > max)\n *       {\n *         label = label.substring(0, max)+'...';\n *       }\n *     }\n *   } \n *   return mxUtils.htmlEntities(label);\n * }\n * (end)\n * \n * A resize listener is needed in the graph to force a repaint of the label\n * after a resize.\n * \n * (code)\n * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n * \n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     this.view.removeState(cells[i]);\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be returned.\n */\nmxGraph.prototype.getLabel = function(cell)\n{\n\tvar result = '';\n\t\n\tif (this.labelsVisible && cell != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\t\n\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_NOLABEL, false))\n\t\t{\n\t\t\tresult = this.convertValueToString(cell);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: isHtmlLabel\n * \n * Returns true if the label must be rendered as HTML markup. The default\n * implementation returns <htmlLabels>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be displayed as HTML markup.\n */\nmxGraph.prototype.isHtmlLabel = function(cell)\n{\n\treturn this.isHtmlLabels();\n};\n \n/**\n * Function: isHtmlLabels\n * \n * Returns <htmlLabels>.\n */\nmxGraph.prototype.isHtmlLabels = function()\n{\n\treturn this.htmlLabels;\n};\n \n/**\n * Function: setHtmlLabels\n * \n * Sets <htmlLabels>.\n */\nmxGraph.prototype.setHtmlLabels = function(value)\n{\n\tthis.htmlLabels = value;\n};\n\n/**\n * Function: isWrapping\n * \n * This enables wrapping for HTML labels.\n * \n * Returns true if no white-space CSS style directive should be used for\n * displaying the given cells label. This implementation returns true if\n * <mxConstants.STYLE_WHITE_SPACE> in the style of the given cell is 'wrap'.\n * \n * This is used as a workaround for IE ignoring the white-space directive\n * of child elements if the directive appears in a parent element. It\n * should be overridden to return true if a white-space directive is used\n * in the HTML markup that represents the given cells label. In order for\n * HTML markup to work in labels, <isHtmlLabel> must also return true\n * for the given cell.\n * \n * Example:\n * \n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\n *   \n *   if (this.model.isEdge(cell))\n *   {\n *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\n *   }\n *   \n *   return tmp;\n * }\n * \n * graph.isWrapping = function(state)\n * {\n * \t return this.model.isEdge(state.cell);\n * }\n * (end)\n * \n * Makes sure no edge label is wider than 150 pixels, otherwise the content\n * is wrapped. Note: No width must be specified for wrapped vertex labels as\n * the vertex defines the width in its geometry.\n * \n * Parameters:\n * \n * state - <mxCell> whose label should be wrapped.\n */\nmxGraph.prototype.isWrapping = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn (style != null) ? style[mxConstants.STYLE_WHITE_SPACE] == 'wrap' : false;\n};\n\n/**\n * Function: isLabelClipped\n * \n * Returns true if the overflow portion of labels should be hidden. If this\n * returns true then vertex labels will be clipped to the size of the vertices.\n * This implementation returns true if <mxConstants.STYLE_OVERFLOW> in the\n * style of the given cell is 'hidden'.\n * \n * Parameters:\n * \n * state - <mxCell> whose label should be clipped.\n */\nmxGraph.prototype.isLabelClipped = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn (style != null) ? style[mxConstants.STYLE_OVERFLOW] == 'hidden' : false;\n};\n\n/**\n * Function: getTooltip\n * \n * Returns the string or DOM node that represents the tooltip for the given\n * state, node and coordinate pair. This implementation checks if the given\n * node is a folding icon or overlay and returns the respective tooltip. If\n * this does not result in a tooltip, the handler for the cell is retrieved\n * from <selectionCellsHandler> and the optional getTooltipForNode method is\n * called. If no special tooltip exists here then <getTooltipForCell> is used\n * with the cell in the given state as the argument to return a tooltip for the\n * given state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose tooltip should be returned.\n * node - DOM node that is currently under the mouse.\n * x - X-coordinate of the mouse.\n * y - Y-coordinate of the mouse.\n */\nmxGraph.prototype.getTooltip = function(state, node, x, y)\n{\n\tvar tip = null;\n\t\n\tif (state != null)\n\t{\n\t\t// Checks if the mouse is over the folding icon\n\t\tif (state.control != null && (node == state.control.node ||\n\t\t\tnode.parentNode == state.control.node))\n\t\t{\n\t\t\ttip = this.collapseExpandResource;\n\t\t\ttip = mxUtils.htmlEntities(mxResources.get(tip) || tip).replace(/\\\\n/g, '<br>');\n\t\t}\n\n\t\tif (tip == null && state.overlays != null)\n\t\t{\n\t\t\tstate.overlays.visit(function(id, shape)\n\t\t\t{\n\t\t\t\t// LATER: Exit loop if tip is not null\n\t\t\t\tif (tip == null && (node == shape.node || node.parentNode == shape.node))\n\t\t\t\t{\n\t\t\t\t\ttip = shape.overlay.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (tip == null)\n\t\t{\n\t\t\tvar handler = this.selectionCellsHandler.getHandler(state.cell);\n\t\t\t\n\t\t\tif (handler != null && typeof(handler.getTooltipForNode) == 'function')\n\t\t\t{\n\t\t\t\ttip = handler.getTooltipForNode(node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tip == null)\n\t\t{\n\t\t\ttip = this.getTooltipForCell(state.cell);\n\t\t}\n\t}\n\t\n\treturn tip;\n};\n\n/**\n * Function: getTooltipForCell\n * \n * Returns the string or DOM node to be used as the tooltip for the given\n * cell. This implementation uses the cells getTooltip function if it\n * exists, or else it returns <convertValueToString> for the cell.\n * \n * Example:\n * \n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   return 'Hello, World!';\n * }\n * (end)\n * \n * Replaces all tooltips with the string Hello, World!\n * \n * Parameters:\n * \n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getTooltipForCell = function(cell)\n{\n\tvar tip = null;\n\t\n\tif (cell != null && cell.getTooltip != null)\n\t{\n\t\ttip = cell.getTooltip();\n\t}\n\telse\n\t{\n\t\ttip = this.convertValueToString(cell);\n\t}\n\t\n\treturn tip;\n};\n\n/**\n * Function: getLinkForCell\n * \n * Returns the string to be used as the link for the given cell. This\n * implementation returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getLinkForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getCursorForMouseEvent\n * \n * Returns the cursor value to be used for the CSS of the shape for the\n * given event. This implementation calls <getCursorForCell>.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForMouseEvent = function(me)\n{\n\treturn this.getCursorForCell(me.getCell());\n};\n\n/**\n * Function: getCursorForCell\n * \n * Returns the cursor value to be used for the CSS of the shape for the\n * given cell. This implementation returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getStartSize\n * \n * Returns the start size of the given swimlane, that is, the width or\n * height of the part that contains the title, depending on the\n * horizontal style. The return value is an <mxRectangle> with either\n * width or height set as appropriate.\n * \n * Parameters:\n * \n * swimlane - <mxCell> whose start size should be returned.\n */\nmxGraph.prototype.getStartSize = function(swimlane)\n{\n\tvar result = new mxRectangle();\n\tvar state = this.view.getState(swimlane);\n\tvar style = (state != null) ? state.style : this.getCellStyle(swimlane);\n\t\n\tif (style != null)\n\t{\n\t\tvar size = parseInt(mxUtils.getValue(style,\n\t\t\tmxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));\n\t\t\n\t\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t{\n\t\t\tresult.height = size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.width = size;\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getImage\n * \n * Returns the image URL for the given cell state. This implementation\n * returns the value stored under <mxConstants.STYLE_IMAGE> in the cell\n * style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose image URL should be returned.\n */\nmxGraph.prototype.getImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_IMAGE] : null;\n};\n\n/**\n * Function: getVerticalAlign\n * \n * Returns the vertical alignment for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_VERTICAL_ALIGN> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose vertical alignment should be\n * returned.\n */\nmxGraph.prototype.getVerticalAlign = function(state)\n{\n\treturn (state != null && state.style != null) ?\n\t\t(state.style[mxConstants.STYLE_VERTICAL_ALIGN] ||\n\t\tmxConstants.ALIGN_MIDDLE) : null;\n};\n\n/**\n * Function: getIndicatorColor\n * \n * Returns the indicator color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_COLOR> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;\n};\n\n/**\n * Function: getIndicatorGradientColor\n * \n * Returns the indicator gradient color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_GRADIENTCOLOR> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator gradient color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorGradientColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;\n};\n\n/**\n * Function: getIndicatorShape\n * \n * Returns the indicator shape for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_SHAPE> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator shape should be returned.\n */\nmxGraph.prototype.getIndicatorShape = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;\n};\n\n/**\n * Function: getIndicatorImage\n * \n * Returns the indicator image for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_IMAGE> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator image should be returned.\n */\nmxGraph.prototype.getIndicatorImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;\n};\n\n/**\n * Function: getBorder\n * \n * Returns the value of <border>.\n */\nmxGraph.prototype.getBorder = function()\n{\n\treturn this.border;\n};\n\n/**\n * Function: setBorder\n * \n * Sets the value of <border>.\n * \n * Parameters:\n * \n * value - Positive integer that represents the border to be used.\n */\nmxGraph.prototype.setBorder = function(value)\n{\n\tthis.border = value;\n};\n\n/**\n * Function: isSwimlane\n * \n * Returns true if the given cell is a swimlane in the graph. A swimlane is\n * a container cell with some specific behaviour. This implementation\n * checks if the shape associated with the given cell is a <mxSwimlane>.\n * \n * Parameters:\n * \n * cell - <mxCell> to be checked.\n */\nmxGraph.prototype.isSwimlane = function (cell)\n{\n\tif (cell != null)\n\t{\n\t\tif (this.model.getParent(cell) != this.model.getRoot())\n\t\t{\n\t\t\tvar state = this.view.getState(cell);\n\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\t\tif (style != null && !this.model.isEdge(cell))\n\t\t\t{\n\t\t\t\treturn style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Group: Graph behaviour\n */\n\n/**\n * Function: isResizeContainer\n * \n * Returns <resizeContainer>.\n */\nmxGraph.prototype.isResizeContainer = function()\n{\n\treturn this.resizeContainer;\n};\n\n/**\n * Function: setResizeContainer\n * \n * Sets <resizeContainer>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the container should be resized.\n */\nmxGraph.prototype.setResizeContainer = function(value)\n{\n\tthis.resizeContainer = value;\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if the graph is <enabled>.\n */\nmxGraph.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Specifies if the graph should allow any interactions. This\n * implementation updates <enabled>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should be enabled.\n */\nmxGraph.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isEscapeEnabled\n * \n * Returns <escapeEnabled>.\n */\nmxGraph.prototype.isEscapeEnabled = function()\n{\n\treturn this.escapeEnabled;\n};\n\n/**\n * Function: setEscapeEnabled\n * \n * Sets <escapeEnabled>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if escape should be enabled.\n */\nmxGraph.prototype.setEscapeEnabled = function(value)\n{\n\tthis.escapeEnabled = value;\n};\n\n/**\n * Function: isInvokesStopCellEditing\n * \n * Returns <invokesStopCellEditing>.\n */\nmxGraph.prototype.isInvokesStopCellEditing = function()\n{\n\treturn this.invokesStopCellEditing;\n};\n\n/**\n * Function: setInvokesStopCellEditing\n * \n * Sets <invokesStopCellEditing>.\n */\nmxGraph.prototype.setInvokesStopCellEditing = function(value)\n{\n\tthis.invokesStopCellEditing = value;\n};\n\n/**\n * Function: isEnterStopsCellEditing\n * \n * Returns <enterStopsCellEditing>.\n */\nmxGraph.prototype.isEnterStopsCellEditing = function()\n{\n\treturn this.enterStopsCellEditing;\n};\n\n/**\n * Function: setEnterStopsCellEditing\n * \n * Sets <enterStopsCellEditing>.\n */\nmxGraph.prototype.setEnterStopsCellEditing = function(value)\n{\n\tthis.enterStopsCellEditing = value;\n};\n\n/**\n * Function: isCellLocked\n * \n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n * \n * Parameters:\n * \n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellLocked = function(cell)\n{\n\tvar geometry = this.model.getGeometry(cell);\n\t\n\treturn this.isCellsLocked() || (geometry != null && this.model.isVertex(cell) && geometry.relative);\n};\n\n/**\n * Function: isCellsLocked\n * \n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n * \n * Parameters:\n * \n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellsLocked = function()\n{\n\treturn this.cellsLocked;\n};\n\n/**\n * Function: setCellsLocked\n * \n * Sets if any cell may be moved, sized, bended, disconnected, edited or\n * selected.\n * \n * Parameters:\n * \n * value - Boolean that defines the new value for <cellsLocked>.\n */\nmxGraph.prototype.setCellsLocked = function(value)\n{\n\tthis.cellsLocked = value;\n};\n\n/**\n * Function: getCloneableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getCloneableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellCloneable(cell);\n\t}));\n};\n\n/**\n * Function: isCellCloneable\n * \n * Returns true if the given cell is cloneable. This implementation returns\n * <isCellsCloneable> for all cells unless a cell style specifies\n * <mxConstants.STYLE_CLONEABLE> to be 0. \n * \n * Parameters:\n * \n * cell - Optional <mxCell> whose cloneable state should be returned.\n */\nmxGraph.prototype.isCellCloneable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsCloneable() && style[mxConstants.STYLE_CLONEABLE] != 0;\n};\n\n/**\n * Function: isCellsCloneable\n * \n * Returns <cellsCloneable>, that is, if the graph allows cloning of cells\n * by using control-drag.\n */\nmxGraph.prototype.isCellsCloneable = function()\n{\n\treturn this.cellsCloneable;\n};\n\n/**\n * Function: setCellsCloneable\n * \n * Specifies if the graph should allow cloning of cells by holding down the\n * control key while cells are being moved. This implementation updates\n * <cellsCloneable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should be cloneable.\n */\nmxGraph.prototype.setCellsCloneable = function(value)\n{\n\tthis.cellsCloneable = value;\n};\n\n/**\n * Function: getExportableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getExportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canExportCell(cell);\n\t}));\n};\n\n/**\n * Function: canExportCell\n * \n * Returns true if the given cell may be exported to the clipboard. This\n * implementation returns <exportEnabled> for all cells.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to be exported.\n */\nmxGraph.prototype.canExportCell = function(cell)\n{\n\treturn this.exportEnabled;\n};\n\n/**\n * Function: getImportableCells\n * \n * Returns the cells which may be imported in the given array of cells.\n */\nmxGraph.prototype.getImportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canImportCell(cell);\n\t}));\n};\n\n/**\n * Function: canImportCell\n * \n * Returns true if the given cell may be imported from the clipboard.\n * This implementation returns <importEnabled> for all cells.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to be imported.\n */\nmxGraph.prototype.canImportCell = function(cell)\n{\n\treturn this.importEnabled;\n};\n\n/**\n * Function: isCellSelectable\n *\n * Returns true if the given cell is selectable. This implementation\n * returns <cellsSelectable>.\n * \n * To add a new style for making cells (un)selectable, use the following code.\n * \n * (code)\n * mxGraph.prototype.isCellSelectable = function(cell)\n * {\n *   var state = this.view.getState(cell);\n *   var style = (state != null) ? state.style : this.getCellStyle(cell);\n *   \n *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;\n * };\n * (end)\n * \n * You can then use the new style as shown in this example.\n * \n * (code)\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose selectable state should be returned.\n */\nmxGraph.prototype.isCellSelectable = function(cell)\n{\n\treturn this.isCellsSelectable();\n};\n\n/**\n * Function: isCellsSelectable\n *\n * Returns <cellsSelectable>.\n */\nmxGraph.prototype.isCellsSelectable = function()\n{\n\treturn this.cellsSelectable;\n};\n\n/**\n * Function: setCellsSelectable\n *\n * Sets <cellsSelectable>.\n */\nmxGraph.prototype.setCellsSelectable = function(value)\n{\n\tthis.cellsSelectable = value;\n};\n\n/**\n * Function: getDeletableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getDeletableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellDeletable(cell);\n\t}));\n};\n\n/**\n * Function: isCellDeletable\n *\n * Returns true if the given cell is moveable. This returns\n * <cellsDeletable> for all given cells if a cells style does not specify\n * <mxConstants.STYLE_DELETABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose deletable state should be returned.\n */\nmxGraph.prototype.isCellDeletable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.isCellsDeletable() && style[mxConstants.STYLE_DELETABLE] != 0;\n};\n\n/**\n * Function: isCellsDeletable\n *\n * Returns <cellsDeletable>.\n */\nmxGraph.prototype.isCellsDeletable = function()\n{\n\treturn this.cellsDeletable;\n};\n\n/**\n * Function: setCellsDeletable\n * \n * Sets <cellsDeletable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow deletion of cells.\n */\nmxGraph.prototype.setCellsDeletable = function(value)\n{\n\tthis.cellsDeletable = value;\n};\n\n/**\n * Function: isLabelMovable\n *\n * Returns true if the given edges's label is moveable. This returns\n * <movable> for all given cells if <isLocked> does not return true\n * for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be moved.\n */\nmxGraph.prototype.isLabelMovable = function(cell)\n{\n\treturn !this.isCellLocked(cell) &&\n\t\t((this.model.isEdge(cell) && this.edgeLabelsMovable) ||\n\t\t(this.model.isVertex(cell) && this.vertexLabelsMovable));\n};\n\n/**\n * Function: isCellRotatable\n *\n * Returns true if the given cell is rotatable. This returns true for the given\n * cell if its style does not specify <mxConstants.STYLE_ROTATABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose rotatable state should be returned.\n */\nmxGraph.prototype.isCellRotatable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn style[mxConstants.STYLE_ROTATABLE] != 0;\n};\n\n/**\n * Function: getMovableCells\n * \n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getMovableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellMovable(cell);\n\t}));\n};\n\n/**\n * Function: isCellMovable\n *\n * Returns true if the given cell is moveable. This returns <cellsMovable>\n * for all given cells if <isCellLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_MOVABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraph.prototype.isCellMovable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.isCellsMovable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_MOVABLE] != 0;\n};\n\n/**\n * Function: isCellsMovable\n *\n * Returns <cellsMovable>.\n */\nmxGraph.prototype.isCellsMovable = function()\n{\n\treturn this.cellsMovable;\n};\n\n/**\n * Function: setCellsMovable\n * \n * Specifies if the graph should allow moving of cells. This implementation\n * updates <cellsMsovable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow moving of cells.\n */\nmxGraph.prototype.setCellsMovable = function(value)\n{\n\tthis.cellsMovable = value;\n};\n\n/**\n * Function: isGridEnabled\n *\n * Returns <gridEnabled> as a boolean.\n */\nmxGraph.prototype.isGridEnabled = function()\n{\n\treturn this.gridEnabled;\n};\n\n/**\n * Function: setGridEnabled\n * \n * Specifies if the grid should be enabled.\n * \n * Parameters:\n * \n * value - Boolean indicating if the grid should be enabled.\n */\nmxGraph.prototype.setGridEnabled = function(value)\n{\n\tthis.gridEnabled = value;\n};\n\n/**\n * Function: isPortsEnabled\n *\n * Returns <portsEnabled> as a boolean.\n */\nmxGraph.prototype.isPortsEnabled = function()\n{\n\treturn this.portsEnabled;\n};\n\n/**\n * Function: setPortsEnabled\n * \n * Specifies if the ports should be enabled.\n * \n * Parameters:\n * \n * value - Boolean indicating if the ports should be enabled.\n */\nmxGraph.prototype.setPortsEnabled = function(value)\n{\n\tthis.portsEnabled = value;\n};\n\n/**\n * Function: getGridSize\n *\n * Returns <gridSize>.\n */\nmxGraph.prototype.getGridSize = function()\n{\n\treturn this.gridSize;\n};\n\n/**\n * Function: setGridSize\n * \n * Sets <gridSize>.\n */\nmxGraph.prototype.setGridSize = function(value)\n{\n\tthis.gridSize = value;\n};\n\n/**\n * Function: getTolerance\n *\n * Returns <tolerance>.\n */\nmxGraph.prototype.getTolerance = function()\n{\n\treturn this.tolerance;\n};\n\n/**\n * Function: setTolerance\n * \n * Sets <tolerance>.\n */\nmxGraph.prototype.setTolerance = function(value)\n{\n\tthis.tolerance = value;\n};\n\n/**\n * Function: isVertexLabelsMovable\n *\n * Returns <vertexLabelsMovable>.\n */\nmxGraph.prototype.isVertexLabelsMovable = function()\n{\n\treturn this.vertexLabelsMovable;\n};\n\n/**\n * Function: setVertexLabelsMovable\n * \n * Sets <vertexLabelsMovable>.\n */\nmxGraph.prototype.setVertexLabelsMovable = function(value)\n{\n\tthis.vertexLabelsMovable = value;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n *\n * Returns <edgeLabelsMovable>.\n */\nmxGraph.prototype.isEdgeLabelsMovable = function()\n{\n\treturn this.edgeLabelsMovable;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n * \n * Sets <edgeLabelsMovable>.\n */\nmxGraph.prototype.setEdgeLabelsMovable = function(value)\n{\n\tthis.edgeLabelsMovable = value;\n};\n\n/**\n * Function: isSwimlaneNesting\n *\n * Returns <swimlaneNesting> as a boolean.\n */\nmxGraph.prototype.isSwimlaneNesting = function()\n{\n\treturn this.swimlaneNesting;\n};\n\n/**\n * Function: setSwimlaneNesting\n * \n * Specifies if swimlanes can be nested by drag and drop. This is only\n * taken into account if dropEnabled is true.\n * \n * Parameters:\n * \n * value - Boolean indicating if swimlanes can be nested.\n */\nmxGraph.prototype.setSwimlaneNesting = function(value)\n{\n\tthis.swimlaneNesting = value;\n};\n\n/**\n * Function: isSwimlaneSelectionEnabled\n *\n * Returns <swimlaneSelectionEnabled> as a boolean.\n */\nmxGraph.prototype.isSwimlaneSelectionEnabled = function()\n{\n\treturn this.swimlaneSelectionEnabled;\n};\n\n/**\n * Function: setSwimlaneSelectionEnabled\n * \n * Specifies if swimlanes should be selected if the mouse is released\n * over their content area.\n * \n * Parameters:\n * \n * value - Boolean indicating if swimlanes content areas\n * should be selected when the mouse is released over them.\n */\nmxGraph.prototype.setSwimlaneSelectionEnabled = function(value)\n{\n\tthis.swimlaneSelectionEnabled = value;\n};\n\n/**\n * Function: isMultigraph\n *\n * Returns <multigraph> as a boolean.\n */\nmxGraph.prototype.isMultigraph = function()\n{\n\treturn this.multigraph;\n};\n\n/**\n * Function: setMultigraph\n * \n * Specifies if the graph should allow multiple connections between the\n * same pair of vertices.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph allows multiple connections\n * between the same pair of vertices.\n */\nmxGraph.prototype.setMultigraph = function(value)\n{\n\tthis.multigraph = value;\n};\n\n/**\n * Function: isAllowLoops\n *\n * Returns <allowLoops> as a boolean.\n */\nmxGraph.prototype.isAllowLoops = function()\n{\n\treturn this.allowLoops;\n};\n\n/**\n * Function: setAllowDanglingEdges\n * \n * Specifies if dangling edges are allowed, that is, if edges are allowed\n * that do not have a source and/or target terminal defined.\n * \n * Parameters:\n * \n * value - Boolean indicating if dangling edges are allowed.\n */\nmxGraph.prototype.setAllowDanglingEdges = function(value)\n{\n\tthis.allowDanglingEdges = value;\n};\n\n/**\n * Function: isAllowDanglingEdges\n *\n * Returns <allowDanglingEdges> as a boolean.\n */\nmxGraph.prototype.isAllowDanglingEdges = function()\n{\n\treturn this.allowDanglingEdges;\n};\n\n/**\n * Function: setConnectableEdges\n * \n * Specifies if edges should be connectable.\n * \n * Parameters:\n * \n * value - Boolean indicating if edges should be connectable.\n */\nmxGraph.prototype.setConnectableEdges = function(value)\n{\n\tthis.connectableEdges = value;\n};\n\n/**\n * Function: isConnectableEdges\n *\n * Returns <connectableEdges> as a boolean.\n */\nmxGraph.prototype.isConnectableEdges = function()\n{\n\treturn this.connectableEdges;\n};\n\n/**\n * Function: setCloneInvalidEdges\n * \n * Specifies if edges should be inserted when cloned but not valid wrt.\n * <getEdgeValidationError>. If false such edges will be silently ignored.\n * \n * Parameters:\n * \n * value - Boolean indicating if cloned invalid edges should be\n * inserted into the graph or ignored.\n */\nmxGraph.prototype.setCloneInvalidEdges = function(value)\n{\n\tthis.cloneInvalidEdges = value;\n};\n\n/**\n * Function: isCloneInvalidEdges\n *\n * Returns <cloneInvalidEdges> as a boolean.\n */\nmxGraph.prototype.isCloneInvalidEdges = function()\n{\n\treturn this.cloneInvalidEdges;\n};\n\n/**\n * Function: setAllowLoops\n * \n * Specifies if loops are allowed.\n * \n * Parameters:\n * \n * value - Boolean indicating if loops are allowed.\n */\nmxGraph.prototype.setAllowLoops = function(value)\n{\n\tthis.allowLoops = value;\n};\n\n/**\n * Function: isDisconnectOnMove\n *\n * Returns <disconnectOnMove> as a boolean.\n */\nmxGraph.prototype.isDisconnectOnMove = function()\n{\n\treturn this.disconnectOnMove;\n};\n\n/**\n * Function: setDisconnectOnMove\n * \n * Specifies if edges should be disconnected when moved. (Note: Cloned\n * edges are always disconnected.)\n * \n * Parameters:\n * \n * value - Boolean indicating if edges should be disconnected\n * when moved.\n */\nmxGraph.prototype.setDisconnectOnMove = function(value)\n{\n\tthis.disconnectOnMove = value;\n};\n\n/**\n * Function: isDropEnabled\n *\n * Returns <dropEnabled> as a boolean.\n */\nmxGraph.prototype.isDropEnabled = function()\n{\n\treturn this.dropEnabled;\n};\n\n/**\n * Function: setDropEnabled\n * \n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n * \n * Parameters:\n * \n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setDropEnabled = function(value)\n{\n\tthis.dropEnabled = value;\n};\n\n/**\n * Function: isSplitEnabled\n *\n * Returns <splitEnabled> as a boolean.\n */\nmxGraph.prototype.isSplitEnabled = function()\n{\n\treturn this.splitEnabled;\n};\n\n/**\n * Function: setSplitEnabled\n * \n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n * \n * Parameters:\n * \n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setSplitEnabled = function(value)\n{\n\tthis.splitEnabled = value;\n};\n\n/**\n * Function: isCellResizable\n *\n * Returns true if the given cell is resizable. This returns\n * <cellsResizable> for all given cells if <isCellLocked> does not return\n * true for the given cell and its style does not specify\n * <mxConstants.STYLE_RESIZABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose resizable state should be returned.\n */\nmxGraph.prototype.isCellResizable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsResizable() && !this.isCellLocked(cell) &&\n\t\tmxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, '1') != '0';\n};\n\n/**\n * Function: isCellsResizable\n *\n * Returns <cellsResizable>.\n */\nmxGraph.prototype.isCellsResizable = function()\n{\n\treturn this.cellsResizable;\n};\n\n/**\n * Function: setCellsResizable\n * \n * Specifies if the graph should allow resizing of cells. This\n * implementation updates <cellsResizable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow resizing of\n * cells.\n */\nmxGraph.prototype.setCellsResizable = function(value)\n{\n\tthis.cellsResizable = value;\n};\n\n/**\n * Function: isTerminalPointMovable\n *\n * Returns true if the given terminal point is movable. This is independent\n * from <isCellConnectable> and <isCellDisconnectable> and controls if terminal\n * points can be moved in the graph if the edge is not connected. Note that it\n * is required for this to return true to connect unconnected edges. This\n * implementation returns true.\n * \n * Parameters:\n * \n * cell - <mxCell> whose terminal point should be moved.\n * source - Boolean indicating if the source or target terminal should be moved.\n */\nmxGraph.prototype.isTerminalPointMovable = function(cell, source)\n{\n\treturn true;\n};\n\n/**\n * Function: isCellBendable\n *\n * Returns true if the given cell is bendable. This returns <cellsBendable>\n * for all given cells if <isLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_BENDABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bendable state should be returned.\n */\nmxGraph.prototype.isCellBendable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.isCellsBendable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_BENDABLE] != 0;\n};\n\n/**\n * Function: isCellsBendable\n *\n * Returns <cellsBenadable>.\n */\nmxGraph.prototype.isCellsBendable = function()\n{\n\treturn this.cellsBendable;\n};\n\n/**\n * Function: setCellsBendable\n * \n * Specifies if the graph should allow bending of edges. This\n * implementation updates <bendable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow bending of\n * edges.\n */\nmxGraph.prototype.setCellsBendable = function(value)\n{\n\tthis.cellsBendable = value;\n};\n\n/**\n * Function: isCellEditable\n *\n * Returns true if the given cell is editable. This returns <cellsEditable> for\n * all given cells if <isCellLocked> does not return true for the given cell\n * and its style does not specify <mxConstants.STYLE_EDITABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose editable state should be returned.\n */\nmxGraph.prototype.isCellEditable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.isCellsEditable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_EDITABLE] != 0;\n};\n\n/**\n * Function: isCellsEditable\n *\n * Returns <cellsEditable>.\n */\nmxGraph.prototype.isCellsEditable = function()\n{\n\treturn this.cellsEditable;\n};\n\n/**\n * Function: setCellsEditable\n * \n * Specifies if the graph should allow in-place editing for cell labels.\n * This implementation updates <cellsEditable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow in-place\n * editing.\n */\nmxGraph.prototype.setCellsEditable = function(value)\n{\n\tthis.cellsEditable = value;\n};\n\n/**\n * Function: isCellDisconnectable\n *\n * Returns true if the given cell is disconnectable from the source or\n * target terminal. This returns <isCellsDisconnectable> for all given\n * cells if <isCellLocked> does not return true for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose disconnectable state should be returned.\n * terminal - <mxCell> that represents the source or target terminal.\n * source - Boolean indicating if the source or target terminal is to be\n * disconnected.\n */\nmxGraph.prototype.isCellDisconnectable = function(cell, terminal, source)\n{\n\treturn this.isCellsDisconnectable() && !this.isCellLocked(cell);\n};\n\n/**\n * Function: isCellsDisconnectable\n *\n * Returns <cellsDisconnectable>.\n */\nmxGraph.prototype.isCellsDisconnectable = function()\n{\n\treturn this.cellsDisconnectable;\n};\n\n/**\n * Function: setCellsDisconnectable\n *\n * Sets <cellsDisconnectable>.\n */\nmxGraph.prototype.setCellsDisconnectable = function(value)\n{\n\tthis.cellsDisconnectable = value;\n};\n\n/**\n * Function: isValidSource\n * \n * Returns true if the given cell is a valid source for new connections.\n * This implementation returns true for all non-null values and is\n * called by is called by <isValidConnection>.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents a possible source or null.\n */\nmxGraph.prototype.isValidSource = function(cell)\n{\n\treturn (cell == null && this.allowDanglingEdges) ||\n\t\t(cell != null && (!this.model.isEdge(cell) ||\n\t\tthis.connectableEdges) && this.isCellConnectable(cell));\n};\n\t\n/**\n * Function: isValidTarget\n * \n * Returns <isValidSource> for the given cell. This is called by\n * <isValidConnection>.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents a possible target or null.\n */\nmxGraph.prototype.isValidTarget = function(cell)\n{\n\treturn this.isValidSource(cell);\n};\n\n/**\n * Function: isValidConnection\n * \n * Returns true if the given target cell is a valid target for source.\n * This is a boolean implementation for not allowing connections between\n * certain pairs of vertices and is called by <getEdgeValidationError>.\n * This implementation returns true if <isValidSource> returns true for\n * the source and <isValidTarget> returns true for the target.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source cell.\n * target - <mxCell> that represents the target cell.\n */\nmxGraph.prototype.isValidConnection = function(source, target)\n{\n\treturn this.isValidSource(source) && this.isValidTarget(target);\n};\n\n/**\n * Function: setConnectable\n * \n * Specifies if the graph should allow new connections. This implementation\n * updates <mxConnectionHandler.enabled> in <connectionHandler>.\n * \n * Parameters:\n * \n * connectable - Boolean indicating if new connections should be allowed.\n */\nmxGraph.prototype.setConnectable = function(connectable)\n{\n\tthis.connectionHandler.setEnabled(connectable);\n};\n\t\n/**\n * Function: isConnectable\n * \n * Returns true if the <connectionHandler> is enabled.\n */\nmxGraph.prototype.isConnectable = function(connectable)\n{\n\treturn this.connectionHandler.isEnabled();\n};\n\n/**\n * Function: setTooltips\n * \n * Specifies if tooltips should be enabled. This implementation updates\n * <mxTooltipHandler.enabled> in <tooltipHandler>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if tooltips should be enabled.\n */\nmxGraph.prototype.setTooltips = function (enabled)\n{\n\tthis.tooltipHandler.setEnabled(enabled);\n};\n\n/**\n * Function: setPanning\n * \n * Specifies if panning should be enabled. This implementation updates\n * <mxPanningHandler.panningEnabled> in <panningHandler>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if panning should be enabled.\n */\nmxGraph.prototype.setPanning = function(enabled)\n{\n\tthis.panningHandler.panningEnabled = enabled;\n};\n\n/**\n * Function: isEditing\n * \n * Returns true if the given cell is currently being edited.\n * If no cell is specified then this returns true if any\n * cell is currently being edited.\n *\n * Parameters:\n * \n * cell - <mxCell> that should be checked.\n */\nmxGraph.prototype.isEditing = function(cell)\n{\n\tif (this.cellEditor != null)\n\t{\n\t\tvar editingCell = this.cellEditor.getEditingCell();\n\t\t\n\t\treturn (cell == null) ? editingCell != null : cell == editingCell;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: isAutoSizeCell\n * \n * Returns true if the size of the given cell should automatically be\n * updated after a change of the label. This implementation returns\n * <autoSizeCells> or checks if the cell style does specify\n * <mxConstants.STYLE_AUTOSIZE> to be 1.\n * \n * Parameters:\n * \n * cell - <mxCell> that should be resized.\n */\nmxGraph.prototype.isAutoSizeCell = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.isAutoSizeCells() || style[mxConstants.STYLE_AUTOSIZE] == 1;\n};\n\n/**\n * Function: isAutoSizeCells\n * \n * Returns <autoSizeCells>.\n */\nmxGraph.prototype.isAutoSizeCells = function()\n{\n\treturn this.autoSizeCells;\n};\n\n/**\n * Function: setAutoSizeCells\n * \n * Specifies if cell sizes should be automatically updated after a label\n * change. This implementation sets <autoSizeCells> to the given parameter.\n * To update the size of cells when the cells are added, set\n * <autoSizeCellsOnAdd> to true.\n * \n * Parameters:\n * \n * value - Boolean indicating if cells should be resized\n * automatically.\n */\nmxGraph.prototype.setAutoSizeCells = function(value)\n{\n\tthis.autoSizeCells = value;\n};\n\n/**\n * Function: isExtendParent\n * \n * Returns true if the parent of the given cell should be extended if the\n * child has been resized so that it overlaps the parent. This\n * implementation returns <isExtendParents> if the cell is not an edge.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.isExtendParent = function(cell)\n{\n\treturn !this.getModel().isEdge(cell) && this.isExtendParents();\n};\n\n/**\n * Function: isExtendParents\n * \n * Returns <extendParents>.\n */\nmxGraph.prototype.isExtendParents = function()\n{\n\treturn this.extendParents;\n};\n\n/**\n * Function: setExtendParents\n * \n * Sets <extendParents>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParents>.\n */\nmxGraph.prototype.setExtendParents = function(value)\n{\n\tthis.extendParents = value;\n};\n\n/**\n * Function: isExtendParentsOnAdd\n * \n * Returns <extendParentsOnAdd>.\n */\nmxGraph.prototype.isExtendParentsOnAdd = function(cell)\n{\n\treturn this.extendParentsOnAdd;\n};\n\n/**\n * Function: setExtendParentsOnAdd\n * \n * Sets <extendParentsOnAdd>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnAdd = function(value)\n{\n\tthis.extendParentsOnAdd = value;\n};\n\n/**\n * Function: isExtendParentsOnMove\n * \n * Returns <extendParentsOnMove>.\n */\nmxGraph.prototype.isExtendParentsOnMove = function()\n{\n\treturn this.extendParentsOnMove;\n};\n\n/**\n * Function: setExtendParentsOnMove\n * \n * Sets <extendParentsOnMove>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnMove = function(value)\n{\n\tthis.extendParentsOnMove = value;\n};\n\n/**\n * Function: isRecursiveResize\n * \n * Returns <recursiveResize>.\n * \n * Parameters:\n * \n * state - <mxCellState> that is being resized.\n */\nmxGraph.prototype.isRecursiveResize = function(state)\n{\n\treturn this.recursiveResize;\n};\n\n/**\n * Function: setRecursiveResize\n * \n * Sets <recursiveResize>.\n * \n * Parameters:\n * \n * value - New boolean value for <recursiveResize>.\n */\nmxGraph.prototype.setRecursiveResize = function(value)\n{\n\tthis.recursiveResize = value;\n};\n\n/**\n * Function: isConstrainChild\n * \n * Returns true if the given cell should be kept inside the bounds of its\n * parent according to the rules defined by <getOverlap> and\n * <isAllowOverlapParent>. This implementation returns false for all children\n * of edges and <isConstrainChildren> otherwise.\n * \n * Parameters:\n * \n * cell - <mxCell> that should be constrained.\n */\nmxGraph.prototype.isConstrainChild = function(cell)\n{\n\treturn this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell));\n};\n\n/**\n * Function: isConstrainChildren\n * \n * Returns <constrainChildren>.\n */\nmxGraph.prototype.isConstrainChildren = function()\n{\n\treturn this.constrainChildren;\n};\n\n/**\n * Function: setConstrainChildren\n * \n * Sets <constrainChildren>.\n */\nmxGraph.prototype.setConstrainChildren = function(value)\n{\n\tthis.constrainChildren = value;\n};\n\n/**\n * Function: isConstrainRelativeChildren\n * \n * Returns <constrainRelativeChildren>.\n */\nmxGraph.prototype.isConstrainRelativeChildren = function()\n{\n\treturn this.constrainRelativeChildren;\n};\n\n/**\n * Function: setConstrainRelativeChildren\n * \n * Sets <constrainRelativeChildren>.\n */\nmxGraph.prototype.setConstrainRelativeChildren = function(value)\n{\n\tthis.constrainRelativeChildren = value;\n};\n\n/**\n * Function: isConstrainChildren\n * \n * Returns <allowNegativeCoordinates>.\n */\nmxGraph.prototype.isAllowNegativeCoordinates = function()\n{\n\treturn this.allowNegativeCoordinates;\n};\n\n/**\n * Function: setConstrainChildren\n * \n * Sets <allowNegativeCoordinates>.\n */\nmxGraph.prototype.setAllowNegativeCoordinates = function(value)\n{\n\tthis.allowNegativeCoordinates = value;\n};\n\n/**\n * Function: getOverlap\n * \n * Returns a decimal number representing the amount of the width and height\n * of the given cell that is allowed to overlap its parent. A value of 0\n * means all children must stay inside the parent, 1 means the child is\n * allowed to be placed outside of the parent such that it touches one of\n * the parents sides. If <isAllowOverlapParent> returns false for the given\n * cell, then this method returns 0.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the overlap ratio should be returned.\n */\nmxGraph.prototype.getOverlap = function(cell)\n{\n\treturn (this.isAllowOverlapParent(cell)) ? this.defaultOverlap : 0;\n};\n\t\n/**\n * Function: isAllowOverlapParent\n * \n * Returns true if the given cell is allowed to be placed outside of the\n * parents area.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the child to be checked.\n */\nmxGraph.prototype.isAllowOverlapParent = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getFoldableCells\n * \n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getFoldableCells = function(cells, collapse)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellFoldable(cell, collapse);\n\t}));\n};\n\n/**\n * Function: isCellFoldable\n * \n * Returns true if the given cell is foldable. This implementation\n * returns true if the cell has at least one child and its style\n * does not specify <mxConstants.STYLE_FOLDABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose foldable state should be returned.\n */\nmxGraph.prototype.isCellFoldable = function(cell, collapse)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\n\treturn this.model.getChildCount(cell) > 0 && style[mxConstants.STYLE_FOLDABLE] != 0;\n};\n\n/**\n * Function: isValidDropTarget\n *\n * Returns true if the given cell is a valid drop target for the specified\n * cells. If <splitEnabled> is true then this returns <isSplitTarget> for\n * the given arguments else it returns true if the cell is not collapsed\n * and its child count is greater than 0.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the possible drop target.\n * cells - <mxCells> that should be dropped into the target.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isValidDropTarget = function(cell, cells, evt)\n{\n\treturn cell != null && ((this.isSplitEnabled() &&\n\t\tthis.isSplitTarget(cell, cells, evt)) || (!this.model.isEdge(cell) &&\n\t\t(this.isSwimlane(cell) || (this.model.getChildCount(cell) > 0 &&\n\t\t!this.isCellCollapsed(cell)))));\n};\n\n/**\n * Function: isSplitTarget\n *\n * Returns true if the given edge may be splitted into two edges with the\n * given cell as a new terminal between the two.\n * \n * Parameters:\n * \n * target - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that should split the edge.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isSplitTarget = function(target, cells, evt)\n{\n\tif (this.model.isEdge(target) && cells != null && cells.length == 1 &&\n\t\tthis.isCellConnectable(cells[0]) && this.getEdgeValidationError(target,\n\t\t\tthis.model.getTerminal(target, true), cells[0]) == null)\n\t{\n\t\tvar src = this.model.getTerminal(target, true);\n\t\tvar trg = this.model.getTerminal(target, false);\n\n\t\treturn (!this.model.isAncestor(cells[0], src) &&\n\t\t\t\t!this.model.isAncestor(cells[0], trg));\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getDropTarget\n * \n * Returns the given cell if it is a drop target for the given cells or the\n * nearest ancestor that may be used as a drop target for the given cells.\n * If the given array contains a swimlane and <swimlaneNesting> is false\n * then this always returns null. If no cell is given, then the bottommost\n * swimlane at the location of the given event is returned.\n * \n * This function should only be used if <isDropEnabled> returns true.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> which are to be dropped onto the target.\n * evt - Mouseevent for the drag and drop.\n * cell - <mxCell> that is under the mousepointer.\n * clone - Optional boolean to indicate of cells will be cloned.\n */\nmxGraph.prototype.getDropTarget = function(cells, evt, cell, clone)\n{\n\tif (!this.isSwimlaneNesting())\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.isSwimlane(cells[i]))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar pt = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\tpt.x -= this.panDx;\n\tpt.y -= this.panDy;\n\tvar swimlane = this.getSwimlaneAt(pt.x, pt.y);\n\t\n\tif (cell == null)\n\t{\n\t\tcell = swimlane;\n\t}\n\telse if (swimlane != null)\n\t{\n\t\t// Checks if the cell is an ancestor of the swimlane\n\t\t// under the mouse and uses the swimlane in that case\n\t\tvar tmp = this.model.getParent(swimlane);\n\t\t\n\t\twhile (tmp != null && this.isSwimlane(tmp) && tmp != cell)\n\t\t{\n\t\t\ttmp = this.model.getParent(tmp);\n\t\t}\n\t\t\n\t\tif (tmp == cell)\n\t\t{\n\t\t\tcell = swimlane;\n\t\t}\n\t}\n\t\n\twhile (cell != null && !this.isValidDropTarget(cell, cells, evt) &&\n\t\t!this.model.isLayer(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\t\n\t// Checks if parent is dropped into child if not cloning\n\tif (clone == null || !clone)\n\t{\n\t\tvar parent = cell;\n\t\t\n\t\twhile (parent != null && mxUtils.indexOf(cells, parent) < 0)\n\t\t{\n\t\t\tparent = this.model.getParent(parent);\n\t\t}\n\t}\n\n\treturn (!this.model.isLayer(cell) && parent == null) ? cell : null;\n};\n\n/**\n * Group: Cell retrieval\n */\n\n/**\n * Function: getDefaultParent\n * \n * Returns <defaultParent> or <mxGraphView.currentRoot> or the first child\n * child of <mxGraphModel.root> if both are null. The value returned by\n * this function should be used as the parent for new cells (aka default\n * layer).\n */\nmxGraph.prototype.getDefaultParent = function()\n{\n\tvar parent = this.getCurrentRoot();\n\t\n\tif (parent == null)\n\t{\n\t\tparent = this.defaultParent;\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tvar root = this.model.getRoot();\n\t\t\tparent = this.model.getChildAt(root, 0);\n\t\t}\n\t}\n\t\n\treturn parent;\n};\n\n/**\n * Function: setDefaultParent\n * \n * Sets the <defaultParent> to the given cell. Set this to null to return\n * the first child of the root in getDefaultParent.\n */\nmxGraph.prototype.setDefaultParent = function(cell)\n{\n\tthis.defaultParent = cell;\n};\n\n/**\n * Function: getSwimlane\n * \n * Returns the nearest ancestor of the given cell which is a swimlane, or\n * the given cell, if it is itself a swimlane.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the ancestor swimlane should be returned.\n */\nmxGraph.prototype.getSwimlane = function(cell)\n{\n\twhile (cell != null && !this.isSwimlane(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: getSwimlaneAt\n * \n * Returns the bottom-most swimlane that intersects the given point (x, y)\n * in the cell hierarchy that starts at the given parent.\n * \n * Parameters:\n * \n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is <defaultParent>.\n */\nmxGraph.prototype.getSwimlaneAt = function (x, y, parent)\n{\n\tparent = parent || this.getDefaultParent();\n\t\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\tvar result = this.getSwimlaneAt(x, y, child);\n\t\t\t\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse if (this.isSwimlane(child))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(child);\n\t\t\t\t\n\t\t\t\tif (this.intersects(state, x, y))\n\t\t\t\t{\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getCellAt\n * \n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy starting at the given parent. This will also return\n * swimlanes if the given location intersects the content area of the\n * swimlane. If this is not desired, then the <hitsSwimlaneContent> may be\n * used if the returned cell is a swimlane to determine if the location\n * is inside the content area or on the actual title of the swimlane.\n * \n * Parameters:\n * \n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * vertices - Optional boolean indicating if vertices should be returned.\n * Default is true.\n * edges - Optional boolean indicating if edges should be returned. Default\n * is true.\n * ignoreFn - Optional function that returns true if cell should be ignored.\n * The function is passed the cell state and the x and y parameter.\n */\nmxGraph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn)\n{\n\tvertices = (vertices != null) ? vertices : true;\n\tedges = (edges != null) ? edges : true;\n\n\tif (parent == null)\n\t{\n\t\tparent = this.getCurrentRoot();\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getModel().getRoot();\n\t\t}\n\t}\n\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar cell = this.model.getChildAt(parent, i);\n\t\t\tvar result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n\t\t\t\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse if (this.isCellVisible(cell) && (edges && this.model.isEdge(cell) ||\n\t\t\t\tvertices && this.model.isVertex(cell)))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cell);\n\n\t\t\t\tif (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) &&\n\t\t\t\t\tthis.intersects(state, x, y))\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: intersects\n * \n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy that starts at the given parent.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the cell state.\n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n */\nmxGraph.prototype.intersects = function(state, x, y)\n{\n\tif (state != null)\n\t{\n\t\tvar pts = state.absolutePoints;\n\n\t\tif (pts != null)\n\t\t{\n\t\t\tvar t2 = this.tolerance * this.tolerance;\n\t\t\tvar pt = pts[0];\n\t\t\t\n\t\t\tfor (var i = 1; i < pts.length; i++)\n\t\t\t{\n\t\t\t\tvar next = pts[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n\t\t\t\t\n\t\t\t\tif (dist <= t2)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpt = next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (mxUtils.contains(state, x, y))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: hitsSwimlaneContent\n * \n * Returns true if the given coordinate pair is inside the content\n * are of the given swimlane.\n * \n * Parameters:\n * \n * swimlane - <mxCell> that specifies the swimlane.\n * x - X-coordinate of the mouse event.\n * y - Y-coordinate of the mouse event.\n */\nmxGraph.prototype.hitsSwimlaneContent = function(swimlane, x, y)\n{\n\tvar state = this.getView().getState(swimlane);\n\tvar size = this.getStartSize(swimlane);\n\t\n\tif (state != null)\n\t{\n\t\tvar scale = this.getView().getScale();\n\t\tx -= state.x;\n\t\ty -= state.y;\n\t\t\n\t\tif (size.width > 0 && x > 0 && x > size.width * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if (size.height > 0 && y > 0 && y > size.height * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getChildVertices\n * \n * Returns the visible child vertices of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be returned.\n */\nmxGraph.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\t\n/**\n * Function: getChildEdges\n * \n * Returns the visible child edges of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose child vertices should be returned.\n */\nmxGraph.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n * \n * Returns the visible child vertices or edges in the given parent. If\n * vertices and edges is false, then all children are returned.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be returned.\n * vertices - Optional boolean that specifies if child vertices should\n * be returned. Default is false.\n * edges - Optional boolean that specifies if child edges should\n * be returned. Default is false.\n */\nmxGraph.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tparent = (parent != null) ? parent : this.getDefaultParent();\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\n\tvar cells = this.model.getChildCells(parent, vertices, edges);\n\tvar result = [];\n\n\t// Filters out the non-visible child cells\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (this.isCellVisible(cells[i]))\n\t\t{\n\t\t\tresult.push(cells[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\t\n/**\n * Function: getConnections\n * \n * Returns all visible edges connected to the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose connections should be returned.\n * parent - Optional parent of the opposite end for a connection to be\n * returned.\n */\nmxGraph.prototype.getConnections = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, true, false);\n};\n\t\n/**\n * Function: getIncomingEdges\n * \n * Returns the visible incoming edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n * \n * Parameters:\n * \n * cell - <mxCell> whose incoming edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getIncomingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, false, false);\n};\n\t\n/**\n * Function: getOutgoingEdges\n * \n * Returns the visible outgoing edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n * \n * Parameters:\n * \n * cell - <mxCell> whose outgoing edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getOutgoingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, false, true, false);\n};\n\t\n/**\n * Function: getEdges\n * \n * Returns the incoming and/or outgoing edges for the given cell.\n * If the optional parent argument is specified, then only edges are returned\n * where the opposite is in the given parent cell. If at least one of incoming\n * or outgoing is true, then loops are ignored, if both are false, then all\n * edges connected to the given cell are returned including loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n * incoming - Optional boolean that specifies if incoming edges should\n * be included in the result. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should\n * be included in the result. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be\n * included in the result. Default is true.\n * recurse - Optional boolean the specifies if the parent specified only \n * need be an ancestral parent, true, or the direct parent, false.\n * Default is false\n */\nmxGraph.prototype.getEdges = function(cell, parent, incoming, outgoing, includeLoops, recurse)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\trecurse = (recurse != null) ? recurse : false;\n\t\n\tvar edges = [];\n\tvar isCollapsed = this.isCellCollapsed(cell);\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\n\t\tif (isCollapsed || !this.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(this.model.getEdges(child, incoming, outgoing));\n\t\t}\n\t}\n\n\tedges = edges.concat(this.model.getEdges(cell, incoming, outgoing));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\t\t\n\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming &&\n\t\t\ttarget == cell && (parent == null || this.isValidAncestor(source, parent, recurse))) ||\n\t\t\t(outgoing && source == cell && (parent == null ||\n\t\t\t\t\tthis.isValidAncestor(target, parent, recurse))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isValidAncestor\n * \n * Returns whether or not the specified parent is a valid\n * ancestor of the specified cell, either direct or indirectly\n * based on whether ancestor recursion is enabled.\n * \n * Parameters:\n * \n * cell - <mxCell> the possible child cell\n * parent - <mxCell> the possible parent cell\n * recurse - boolean whether or not to recurse the child ancestors\n */\nmxGraph.prototype.isValidAncestor = function(cell, parent, recurse)\n{\n\treturn (recurse ? this.model.isAncestor(parent, cell) : this.model\n\t\t\t.getParent(cell) == parent);\n};\n\n/**\n * Function: getOpposites\n * \n * Returns all distinct visible opposite cells for the specified terminal\n * on the given edges.\n * \n * Parameters:\n * \n * edges - Array of <mxCells> that contains the edges whose opposite\n * terminals should be returned.\n * terminal - Terminal that specifies the end whose opposite should be\n * returned.\n * source - Optional boolean that specifies if source terminals should be\n * included in the result. Default is true.\n * targets - Optional boolean that specifies if targer terminals should be\n * included in the result. Default is true.\n */\nmxGraph.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\t\n\tvar terminals = [];\n\t\n\t// Fast lookup to avoid duplicates in terminals array\n\tvar dict = new mxDictionary();\n\t\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar state = this.view.getState(edges[i]);\n\t\t\t\n\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\t\t\t\n\t\t\t// Checks if the terminal is the source of the edge and if the\n\t\t\t// target should be stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tif (!dict.get(target))\n\t\t\t\t{\n\t\t\t\t\tdict.put(target, true);\n\t\t\t\t\tterminals.push(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Checks if the terminal is the taget of the edge and if the\n\t\t\t// source should be stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tif (!dict.get(source))\n\t\t\t\t{\n\t\t\t\t\tdict.put(source, true);\n\t\t\t\t\tterminals.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn terminals;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and returns the connected edges\n * as displayed on the screen.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxGraph.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\t\t\n\t\tvar src = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar trg = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getPointForEvent\n * \n * Returns an <mxPoint> representing the given event in the unscaled,\n * non-translated coordinate space of <container> and applies the grid.\n * \n * Parameters:\n * \n * evt - Mousevent that contains the mouse pointer location.\n * addOffset - Optional boolean that specifies if the position should be\n * offset by half of the <gridSize>. Default is true.\n */\n mxGraph.prototype.getPointForEvent = function(evt, addOffset)\n {\n\tvar p = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\n\tvar s = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar off = (addOffset != false) ? this.gridSize / 2 : 0;\n\t\n\tp.x = this.snap(p.x / s - tr.x - off);\n\tp.y = this.snap(p.y / s - tr.y - off);\n\t\n\treturn p;\n };\n\n/**\n * Function: getCells\n * \n * Returns the child vertices and edges of the given parent that are contained\n * in the given rectangle. The result is added to the optional result array,\n * which is returned. If no result array is specified then a new array is\n * created and returned.\n * \n * Parameters:\n * \n * x - X-coordinate of the rectangle.\n * y - Y-coordinate of the rectangle.\n * width - Width of the rectangle.\n * height - Height of the rectangle.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * result - Optional array to store the result in.\n */\nmxGraph.prototype.getCells = function(x, y, width, height, parent, result)\n{\n\tresult = (result != null) ? result : [];\n\t\n\tif (width > 0 || height > 0)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar right = x + width;\n\t\tvar bottom = y + height;\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getCurrentRoot();\n\t\t\t\n\t\t\tif (parent == null)\n\t\t\t{\n\t\t\t\tparent = model.getRoot();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(parent);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(cell);\n\t\t\t\t\n\t\t\t\tif (state != null && this.isCellVisible(cell))\n\t\t\t\t{\n\t\t\t\t\tvar deg = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0;\n\t\t\t\t\tvar box = state;\n\t\t\t\t\t\n\t\t\t\t\tif (deg != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbox = mxUtils.getBoundingBox(box, deg);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((model.isEdge(cell) || model.isVertex(cell)) &&\n\t\t\t\t\t\tbox.x >= x && box.y + box.height <= bottom &&\n\t\t\t\t\t\tbox.y >= y && box.x + box.width <= right)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(cell);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.getCells(x, y, width, height, cell, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getCellsBeyond\n * \n * Returns the children of the given parent that are contained in the\n * halfpane from the given point (x0, y0) rightwards or downwards\n * depending on rightHalfpane and bottomHalfpane.\n * \n * Parameters:\n * \n * x0 - X-coordinate of the origin.\n * y0 - Y-coordinate of the origin.\n * parent - Optional <mxCell> whose children should be checked. Default is\n * <defaultParent>.\n * rightHalfpane - Boolean indicating if the cells in the right halfpane\n * from the origin should be returned.\n * bottomHalfpane - Boolean indicating if the cells in the bottom halfpane\n * from the origin should be returned.\n */\nmxGraph.prototype.getCellsBeyond = function(x0, y0, parent, rightHalfpane, bottomHalfpane)\n{\n\tvar result = [];\n\t\n\tif (rightHalfpane || bottomHalfpane)\n\t{\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getDefaultParent();\n\t\t}\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(child);\n\t\t\t\t\n\t\t\t\tif (this.isCellVisible(child) && state != null)\n\t\t\t\t{\n\t\t\t\t\tif ((!rightHalfpane || state.x >= x0) &&\n\t\t\t\t\t\t(!bottomHalfpane || state.y >= y0))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: findTreeRoots\n * \n * Returns all children in the given parent which do not have incoming\n * edges. If the result is empty then the with the greatest difference\n * between incoming and outgoing edges is returned.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * isolate - Optional boolean that specifies if edges should be ignored if\n * the opposite end is not a child of the given parent cell. Default is\n * false.\n * invert - Optional boolean that specifies if outgoing or incoming edges\n * should be counted for a tree root. If false then outgoing edges will be\n * counted. Default is false.\n */\nmxGraph.prototype.findTreeRoots = function(parent, isolate, invert)\n{\n\tisolate = (isolate != null) ? isolate : false;\n\tinvert = (invert != null) ? invert : false;\n\tvar roots = [];\n\t\n\tif (parent != null)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar childCount = model.getChildCount(parent);\n\t\tvar best = null;\n\t\tvar maxDiff = 0;\n\t\t\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (this.model.isVertex(cell) && this.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getConnections(cell, (isolate) ? parent : null);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\t\t\t\t\n\t\t\t\tfor (var j = 0; j < conns.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.view.getVisibleTerminal(conns[j], true);\n\n                    if (src == cell)\n                    {\n                        fanOut++;\n                    }\n                    else\n                    {\n                        fanIn++;\n                    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((invert && fanOut == 0 && fanIn > 0) ||\n\t\t\t\t\t(!invert && fanIn == 0 && fanOut > 0))\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar diff = (invert) ? fanIn - fanOut : fanOut - fanIn;\n\t\t\t\t\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: traverse\n * \n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Example:\n * \n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> from cells to true for the visited cells.\n * inverse - Optional boolean to traverse in inverse direction. Default is false.\n * This is ignored if directed is false.\n */\nmxGraph.prototype.traverse = function(vertex, directed, func, edge, visited, inverse)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tinverse = (inverse != null) ? inverse : false;\n\t\tvisited = visited || new mxDictionary();\n\t\t\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\t\t\t\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.model.getEdgeCount(vertex);\n\t\t\t\t\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.model.getTerminal(e, true) == vertex;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!directed || (!inverse == isSource))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.model.getTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited, inverse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Selection\n */\n\n/**\n * Function: isCellSelected\n * \n * Returns true if the given cell is selected.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the selection state should be returned.\n */\nmxGraph.prototype.isCellSelected = function(cell)\n{\n\treturn this.getSelectionModel().isSelected(cell);\n};\n\n/**\n * Function: isSelectionEmpty\n * \n * Returns true if the selection is empty.\n */\nmxGraph.prototype.isSelectionEmpty = function()\n{\n\treturn this.getSelectionModel().isEmpty();\n};\n\n/**\n * Function: clearSelection\n * \n * Clears the selection using <mxGraphSelectionModel.clear>.\n */\nmxGraph.prototype.clearSelection = function()\n{\n\treturn this.getSelectionModel().clear();\n};\n\n/**\n * Function: getSelectionCount\n * \n * Returns the number of selected cells.\n */\nmxGraph.prototype.getSelectionCount = function()\n{\n\treturn this.getSelectionModel().cells.length;\n};\n\t\n/**\n * Function: getSelectionCell\n * \n * Returns the first cell from the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCell = function()\n{\n\treturn this.getSelectionModel().cells[0];\n};\n\n/**\n * Function: getSelectionCells\n * \n * Returns the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCells = function()\n{\n\treturn this.getSelectionModel().cells.slice();\n};\n\n/**\n * Function: setSelectionCell\n * \n * Sets the selection cell.\n * \n * Parameters:\n * \n * cell - <mxCell> to be selected.\n */\nmxGraph.prototype.setSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().setCell(cell);\n};\n\n/**\n * Function: setSelectionCells\n * \n * Sets the selection cell.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be selected.\n */\nmxGraph.prototype.setSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().setCells(cells);\n};\n\n/**\n * Function: addSelectionCell\n * \n * Adds the given cell to the selection.\n * \n * Parameters:\n * \n * cell - <mxCell> to be add to the selection.\n */\nmxGraph.prototype.addSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().addCell(cell);\n};\n\n/**\n * Function: addSelectionCells\n * \n * Adds the given cells to the selection.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be added to the selection.\n */\nmxGraph.prototype.addSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().addCells(cells);\n};\n\n/**\n * Function: removeSelectionCell\n * \n * Removes the given cell from the selection.\n * \n * Parameters:\n * \n * cell - <mxCell> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().removeCell(cell);\n};\n\n/**\n * Function: removeSelectionCells\n * \n * Removes the given cells from the selection.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().removeCells(cells);\n};\n\n/**\n * Function: selectRegion\n * \n * Selects and returns the cells inside the given rectangle for the\n * specified event.\n * \n * Parameters:\n * \n * rect - <mxRectangle> that represents the region to be selected.\n * evt - Mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectRegion = function(rect, evt)\n{\n\tvar cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n\tthis.selectCellsForEvent(cells, evt);\n\t\n\treturn cells;\n};\n\n/**\n * Function: selectNextCell\n * \n * Selects the next cell.\n */\nmxGraph.prototype.selectNextCell = function()\n{\n\tthis.selectCell(true);\n};\n\n/**\n * Function: selectPreviousCell\n * \n * Selects the previous cell.\n */\nmxGraph.prototype.selectPreviousCell = function()\n{\n\tthis.selectCell();\n};\n\n/**\n * Function: selectParentCell\n * \n * Selects the parent cell.\n */\nmxGraph.prototype.selectParentCell = function()\n{\n\tthis.selectCell(false, true);\n};\n\n/**\n * Function: selectChildCell\n * \n * Selects the first child cell.\n */\nmxGraph.prototype.selectChildCell = function()\n{\n\tthis.selectCell(false, false, true);\n};\n\n/**\n * Function: selectCell\n * \n * Selects the next, parent, first child or previous cell, if all arguments\n * are false.\n * \n * Parameters:\n * \n * isNext - Boolean indicating if the next cell should be selected.\n * isParent - Boolean indicating if the parent cell should be selected.\n * isChild - Boolean indicating if the first child cell should be selected.\n */\nmxGraph.prototype.selectCell = function(isNext, isParent, isChild)\n{\n\tvar sel = this.selectionModel;\n\tvar cell = (sel.cells.length > 0) ? sel.cells[0] : null;\n\t\n\tif (sel.cells.length > 1)\n\t{\n\t\tsel.clear();\n\t}\n\t\n\tvar parent = (cell != null) ?\n\t\tthis.model.getParent(cell) :\n\t\tthis.getDefaultParent();\n\t\n\tvar childCount = this.model.getChildCount(parent);\n\t\n\tif (cell == null && childCount > 0)\n\t{\n\t\tvar child = this.model.getChildAt(parent, 0);\n\t\tthis.setSelectionCell(child);\n\t}\n\telse if ((cell == null || isParent) &&\n\t\tthis.view.getState(parent) != null &&\n\t\tthis.model.getGeometry(parent) != null)\n\t{\n\t\tif (this.getCurrentRoot() != parent)\n\t\t{\n\t\t\tthis.setSelectionCell(parent);\n\t\t}\n\t}\n\telse if (cell != null && isChild)\n\t{\n\t\tvar tmp = this.model.getChildCount(cell);\n\t\t\n\t\tif (tmp > 0)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(cell, 0);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n\telse if (childCount > 0)\n\t{\n\t\tvar i = parent.getIndex(cell);\n\t\t\n\t\tif (isNext)\n\t\t{\n\t\t\ti++;\n\t\t\tvar child = this.model.getChildAt(parent, i % childCount);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t\tvar index =  (i < 0) ? childCount - 1 : i;\n\t\t\tvar child = this.model.getChildAt(parent, index);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectAll\n * \n * Selects all children of the given parent cell or the children of the\n * default parent if no parent is specified. To select leaf vertices and/or\n * edges use <selectCells>.\n * \n * Parameters:\n * \n * parent - Optional <mxCell> whose children should be selected.\n * Default is <defaultParent>.\n * descendants - Optional boolean specifying whether all descendants should be\n * selected. Default is false.\n */\nmxGraph.prototype.selectAll = function(parent, descendants)\n{\n\tparent = parent || this.getDefaultParent();\n\t\n\tvar cells = (descendants) ? this.model.filterDescendants(function(cell)\n\t{\n\t\treturn cell != parent;\n\t}, parent) : this.model.getChildren(parent);\n\t\n\tif (cells != null)\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Function: selectVertices\n * \n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectVertices = function(parent)\n{\n\tthis.selectCells(true, false, parent);\n};\n\n/**\n * Function: selectVertices\n * \n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectEdges = function(parent)\n{\n\tthis.selectCells(false, true, parent);\n};\n\n/**\n * Function: selectCells\n * \n * Selects all vertices and/or edges depending on the given boolean\n * arguments recursively, starting at the given parent or the default\n * parent if no parent is specified. Use <selectAll> to select all cells.\n * For vertices, only cells with no children are selected.\n * \n * Parameters:\n * \n * vertices - Boolean indicating if vertices should be selected.\n * edges - Boolean indicating if edges should be selected.\n * parent - Optional <mxCell> that acts as the root of the recursion.\n * Default is <defaultParent>.\n */\nmxGraph.prototype.selectCells = function(vertices, edges, parent)\n{\n\tparent = parent || this.getDefaultParent();\n\t\n\tvar filter = mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.view.getState(cell) != null &&\n\t\t\t((this.model.getChildCount(cell) == 0 && this.model.isVertex(cell) && vertices\n\t\t\t&& !this.model.isEdge(this.model.getParent(cell))) ||\n\t\t\t(this.model.isEdge(cell) && edges));\n\t});\n\t\n\tvar cells = this.model.filterDescendants(filter, parent);\n\tthis.setSelectionCells(cells);\n};\n\n/**\n * Function: selectCellForEvent\n * \n * Selects the given cell by either adding it to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n * \n * Parameters:\n * \n * cell - <mxCell> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellForEvent = function(cell, evt)\n{\n\tvar isSelected = this.isCellSelected(cell);\n\t\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tif (isSelected)\n\t\t{\n\t\t\tthis.removeSelectionCell(cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.addSelectionCell(cell);\n\t\t}\n\t}\n\telse if (!isSelected || this.getSelectionCount() != 1)\n\t{\n\t\tthis.setSelectionCell(cell);\n\t}\n};\n\n/**\n * Function: selectCellsForEvent\n * \n * Selects the given cells by either adding them to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellsForEvent = function(cells, evt)\n{\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tthis.addSelectionCells(cells);\n\t}\n\telse\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Group: Selection state\n */\n\n/**\n * Function: createHandler\n * \n * Creates a new handler for the given cell state. This implementation\n * returns a new <mxEdgeHandler> of the corresponding cell is an edge,\n * otherwise it returns an <mxVertexHandler>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose handler should be created.\n */\nmxGraph.prototype.createHandler = function(state)\n{\n\tvar result = null;\n\t\n\tif (state != null)\n\t{\n\t\tif (this.model.isEdge(state.cell))\n\t\t{\n\t\t\tvar source = state.getVisibleTerminalState(true);\n\t\t\tvar target = state.getVisibleTerminalState(false);\n\t\t\tvar geo = this.getCellGeometry(state.cell);\n\t\t\t\n\t\t\tvar edgeStyle = this.view.getEdgeStyle(state, (geo != null) ? geo.points : null, source, target);\n\t\t\tresult = this.createEdgeHandler(state, edgeStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.createVertexHandler(state);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createVertexHandler\n * \n * Hooks to create a new <mxVertexHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createVertexHandler = function(state)\n{\n\treturn new mxVertexHandler(state);\n};\n\n/**\n * Function: createEdgeHandler\n * \n * Hooks to create a new <mxEdgeHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeHandler = function(state, edgeStyle)\n{\n\tvar result = null;\n\t\n\tif (edgeStyle == mxEdgeStyle.Loop ||\n\t\tedgeStyle == mxEdgeStyle.ElbowConnector ||\n\t\tedgeStyle == mxEdgeStyle.SideToSide ||\n\t\tedgeStyle == mxEdgeStyle.TopToBottom)\n\t{\n\t\tresult = this.createElbowEdgeHandler(state);\n\t}\n\telse if (edgeStyle == mxEdgeStyle.SegmentConnector || \n\t\t\tedgeStyle == mxEdgeStyle.OrthConnector)\n\t{\n\t\tresult = this.createEdgeSegmentHandler(state);\n\t}\n\telse\n\t{\n\t\tresult = new mxEdgeHandler(state);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createEdgeSegmentHandler\n * \n * Hooks to create a new <mxEdgeSegmentHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeSegmentHandler = function(state)\n{\n\treturn new mxEdgeSegmentHandler(state);\n};\n\n/**\n * Function: createElbowEdgeHandler\n * \n * Hooks to create a new <mxElbowEdgeHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createElbowEdgeHandler = function(state)\n{\n\treturn new mxElbowEdgeHandler(state);\n};\n\n/**\n * Group: Graph events\n */\n\n/**\n * Function: addMouseListener\n * \n * Adds a listener to the graph event dispatch loop. The listener\n * must implement the mouseDown, mouseMove and mouseUp methods\n * as shown in the <mxMouseEvent> class.\n * \n * Parameters:\n * \n * listener - Listener to be added to the graph event listeners.\n */\nmxGraph.prototype.addMouseListener = function(listener)\n{\n\tif (this.mouseListeners == null)\n\t{\n\t\tthis.mouseListeners = [];\n\t}\n\t\n\tthis.mouseListeners.push(listener);\n};\n\n/**\n * Function: removeMouseListener\n * \n * Removes the specified graph listener.\n * \n * Parameters:\n * \n * listener - Listener to be removed from the graph event listeners.\n */\nmxGraph.prototype.removeMouseListener = function(listener)\n{\n\tif (this.mouseListeners != null)\n\t{\n\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t{\n\t\t\tif (this.mouseListeners[i] == listener)\n\t\t\t{\n\t\t\t\tthis.mouseListeners.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: updateMouseEvent\n * \n * Sets the graphX and graphY properties if the given <mxMouseEvent> if\n * required and returned the event.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> to be updated.\n * evtName - Name of the mouse event.\n */\nmxGraph.prototype.updateMouseEvent = function(me, evtName)\n{\n\tif (me.graphX == null || me.graphY == null)\n\t{\n\t\tvar pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());\n\t\t\n\t\tme.graphX = pt.x - this.panDx;\n\t\tme.graphY = pt.y - this.panDy;\n\t\t\n\t\t// Searches for rectangles using method if native hit detection is disabled on shape\n\t\tif (me.getCell() == null && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE)\n\t\t{\n\t\t\tme.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state)\n\t\t\t{\n\t\t\t\treturn state.shape == null || state.shape.paintBackground != mxRectangleShape.prototype.paintBackground ||\n\t\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1' ||\n\t\t\t\t\t(state.shape.fill != null && state.shape.fill != mxConstants.NONE);\n\t\t\t}));\n\t\t}\n\t}\n\t\n\treturn me;\n};\n\n/**\n * Function: getStateForEvent\n * \n * Returns the state for the given touch event.\n */\nmxGraph.prototype.getStateForTouchEvent = function(evt)\n{\n\tvar x = mxEvent.getClientX(evt);\n\tvar y = mxEvent.getClientY(evt);\n\t\n\t// Dispatches the drop event to the graph which\n\t// consumes and executes the source function\n\tvar pt = mxUtils.convertPoint(this.container, x, y);\n\n\treturn this.view.getState(this.getCellAt(pt.x, pt.y));\n};\n\n/**\n * Function: isEventIgnored\n * \n * Returns true if the event should be ignored in <fireMouseEvent>.\n */\nmxGraph.prototype.isEventIgnored = function(evtName, me, sender)\n{\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\tvar result = false;\n\n\t// Drops events that are fired more than once\n\tif (me.getEvent() == this.lastEvent)\n\t{\n\t\tresult = true;\n\t}\n\telse\n\t{\n\t\tthis.lastEvent = me.getEvent();\n\t}\n\n\t// Installs event listeners to capture the complete gesture from the event source\n\t// for non-MS touch events as a workaround for all events for the same geture being\n\t// fired from the event source even if that was removed from the DOM.\n\tif (this.eventSource != null && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tmxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t\tthis.mouseMoveRedirect = null;\n\t\tthis.mouseUpRedirect = null;\n\t\tthis.eventSource = null;\n\t}\n\telse if (!mxClient.IS_GC && this.eventSource != null && me.getSource() != this.eventSource)\n\t{\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_TOUCH && evtName == mxEvent.MOUSE_DOWN && !mouseEvent && !mxEvent.isPenEvent(me.getEvent()))\n\t{\n\t\tthis.eventSource = me.getSource();\n\n\t\tthis.mouseMoveRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\t\tthis.mouseUpRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\t\t\n\t\tmxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t}\n\n\t// Factored out the workarounds for FF to make it easier to override/remove\n\t// Note this method has side-effects!\n\tif (this.isSyntheticEventIgnored(evtName, me, sender))\n\t{\n\t\tresult = true;\n\t}\n\n\t// Never fires mouseUp/-Down for double clicks\n\tif (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && this.lastEvent.detail == 2)\n\t{\n\t\treturn true;\n\t}\n\t\n\t// Filters out of sequence events or mixed event types during a gesture\n\tif (evtName == mxEvent.MOUSE_UP && this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = false;\n\t}\n\telse if (evtName == mxEvent.MOUSE_DOWN && !this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = true;\n\t\tthis.isMouseTrigger = mouseEvent;\n\t}\n\t// Drops mouse events that are fired during touch gestures as a workaround for Webkit\n\t// and mouse events that are not in sync with the current internal button state\n\telse if (!result && (((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) &&\n\t\tthis.isMouseDown && this.isMouseTrigger != mouseEvent) ||\n\t\t(evtName == mxEvent.MOUSE_DOWN && this.isMouseDown) ||\n\t\t(evtName == mxEvent.MOUSE_UP && !this.isMouseDown)))\n\t{\n\t\tresult = true;\n\t}\n\t\n\tif (!result && evtName == mxEvent.MOUSE_DOWN)\n\t{\n\t\tthis.lastMouseX = me.getX();\n\t\tthis.lastMouseY = me.getY();\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isSyntheticEventIgnored\n * \n * Hook for ignoring synthetic mouse events after touchend in Firefox.\n */\nmxGraph.prototype.isSyntheticEventIgnored = function(evtName, me, sender)\n{\n\tvar result = false;\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\t\n\t// LATER: This does not cover all possible cases that can go wrong in FF\n\tif (this.ignoreMouseEvents && mouseEvent && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tthis.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_FF && !mouseEvent && evtName == mxEvent.MOUSE_UP)\n\t{\n\t\tthis.ignoreMouseEvents = true;\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: isEventSourceIgnored\n * \n * Returns true if the event should be ignored in <fireMouseEvent>. This\n * implementation returns true for select, option and input (if not of type\n * checkbox, radio, button, submit or file) event sources if the event is not\n * a mouse event or a left mouse button press event.\n * \n * Parameters:\n * \n * evtName - The name of the event.\n * me - <mxMouseEvent> that should be ignored.\n */\nmxGraph.prototype.isEventSourceIgnored = function(evtName, me)\n{\n\tvar source = me.getSource();\n\tvar name = (source.nodeName != null) ? source.nodeName.toLowerCase() : '';\n\tvar candidate = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());\n\t\n\treturn evtName == mxEvent.MOUSE_DOWN && candidate && (name == 'select' || name == 'option' ||\n\t\t(name == 'input' && source.type != 'checkbox' && source.type != 'radio' &&\n\t\tsource.type != 'button' && source.type != 'submit' && source.type != 'file'));\n};\n\n/**\n * Function: getEventState\n * \n * Returns the <mxCellState> to be used when firing the mouse event for the\n * given state. This implementation returns the given state.\n * \n * Parameters:\n * \n * <mxCellState> - State whose event source should be returned.\n */\nmxGraph.prototype.getEventState = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: fireMouseEvent\n * \n * Dispatches the given event in the graph event dispatch loop. Possible\n * event names are <mxEvent.MOUSE_DOWN>, <mxEvent.MOUSE_MOVE> and\n * <mxEvent.MOUSE_UP>. All listeners are invoked for all events regardless\n * of the consumed state of the event.\n * \n * Parameters:\n * \n * evtName - String that specifies the type of event to be dispatched.\n * me - <mxMouseEvent> to be fired.\n * sender - Optional sender argument. Default is this.\n */\nmxGraph.prototype.fireMouseEvent = function(evtName, me, sender)\n{\n\tif (this.isEventSourceIgnored(evtName, me))\n\t{\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tif (sender == null)\n\t{\n\t\tsender = this;\n\t}\n\n\t// Updates the graph coordinates in the event\n\tme = this.updateMouseEvent(me, evtName);\n\n\t// Detects and processes double taps for touch-based devices which do not have native double click events\n\t// or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n\t// double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n\t// two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n\t// detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n\tif ((!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent())) || (this.doubleTapEnabled &&\n\t\tmxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))))\n\t{\n\t\tvar currentTime = new Date().getTime();\n\t\t\n\t\t// NOTE: Second mouseDown for double click missing in quirks mode\n\t\tif ((!mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_DOWN) || (mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_UP && !this.fireDoubleClick))\n\t\t{\n\t\t\tif (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() &&\n\t\t\t\tcurrentTime - this.lastTouchTime < this.doubleTapTimeout &&\n\t\t\t\tMath.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n\t\t\t\tthis.doubleClickCounter < 2)\n\t\t\t{\n\t\t\t\tthis.doubleClickCounter++;\n\t\t\t\tvar doubleClickFired = false;\n\t\t\t\t\n\t\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t{\n\t\t\t\t\tif (me.getCell() == this.lastTouchCell && this.lastTouchCell != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t\t\tvar cell = this.lastTouchCell;\n\t\t\t\t\t\tthis.lastTouchCell = null;\n\n\t\t\t\t\t\t// Fires native dblclick event via event source\n\t\t\t\t\t\t// NOTE: This fires two double click events on edges in quirks mode. While\n\t\t\t\t\t\t// trying to fix this, we realized that nativeDoubleClick can be disabled for\n\t\t\t\t\t\t// quirks and IE10+ (or we didn't find the case mentioned above where it\n\t\t\t\t\t\t// would not work), ie. all double clicks seem to be working without this.\n\t\t\t\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tme.getSource().fireEvent('ondblclick');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t\t\t\tdoubleClickFired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.fireDoubleClick = true;\n\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t}\n\n\t\t\t\t// Do not ignore mouse up in quirks in this case\n\t\t\t\tif (!mxClient.IS_QUIRKS || doubleClickFired)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent())\n\t\t\t{\n\t\t\t\tthis.lastTouchCell = me.getCell();\n\t\t\t\tthis.lastTouchX = me.getX();\n\t\t\t\tthis.lastTouchY = me.getY();\n\t\t\t\tthis.lastTouchTime = currentTime;\n\t\t\t\tthis.lastTouchEvent = me.getEvent();\n\t\t\t\tthis.doubleClickCounter = 0;\n\t\t\t}\n\t\t}\n\t\telse if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick)\n\t\t{\n\t\t\tthis.fireDoubleClick = false;\n\t\t\tvar cell = this.lastTouchCell;\n\t\t\tthis.lastTouchCell = null;\n\t\t\tthis.isMouseDown = false;\n\t\t\t\n\t\t\t// Workaround for Chrome/Safari not firing native double click events for double touch on background\n\t\t\tvar valid = (cell != null) || ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\t\t(mxClient.IS_GC || mxClient.IS_SF));\n\t\t\t\n\t\t\tif (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance)\n\t\t\t{\n\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.isEventIgnored(evtName, me, sender))\n\t{\n\t\t// Updates the event state via getEventState\n\t\tme.state = this.getEventState(me.getState());\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, 'eventName', evtName, 'event', me));\n\t\t\n\t\tif ((mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 ||\n\t\t\t(mxClient.IS_IE && mxClient.IS_SVG) || me.getEvent().target != this.container))\n\t\t{\n\t\t\tif (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent))\n\t\t\t{\n\t\t\t\tthis.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);\n\t\t\t}\n\t\t\telse if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition &&\n\t\t\t\t\t(this.container.scrollLeft != 0 || this.container.scrollTop != 0))\n\t\t\t{\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar tr = this.view.translate;\n\t\t\t\tthis.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);\n\t\t\t\tthis.container.scrollLeft = 0;\n\t\t\t\tthis.container.scrollTop = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.mouseListeners != null)\n\t\t\t{\n\t\t\t\tvar args = [sender, me];\n\t\n\t\t\t\t// Does not change returnValue in Opera\n\t\t\t\tif (!me.getEvent().preventDefault)\n\t\t\t\t{\n\t\t\t\t\tme.getEvent().returnValue = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar l = this.mouseListeners[i];\n\t\t\t\t\t\n\t\t\t\t\tif (evtName == mxEvent.MOUSE_DOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseDown.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_MOVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseMove.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseUp.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Invokes the click handler\n\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t{\n\t\t\t\tthis.click(me);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Detects tapAndHold events using a timer\n\t\tif ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\tevtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = true;\n\t\t\tthis.initialTouchX = me.getGraphX();\n\t\t\tthis.initialTouchY = me.getGraphY();\n\t\t\t\n\t\t\tvar handler = function()\n\t\t\t{\n\t\t\t\tif (this.tapAndHoldValid)\n\t\t\t\t{\n\t\t\t\t\tthis.tapAndHold(me);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\t\tthis.tapAndHoldValid = false;\n\t\t\t};\n\t\t\t\n\t\t\tif (this.tapAndHoldThread)\n\t\t\t{\n\t\t\t\twindow.clearTimeout(this.tapAndHoldThread);\n\t\t\t}\n\t\n\t\t\tthis.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, handler), this.tapAndHoldDelay);\n\t\t\tthis.tapAndHoldValid = true;\n\t\t}\n\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\tthis.tapAndHoldValid = false;\n\t\t}\n\t\telse if (this.tapAndHoldValid)\n\t\t{\n\t\t\tthis.tapAndHoldValid =\n\t\t\t\tMath.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n\t\t\t\tMath.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n\t\t}\n\n\t\t// Stops editing for all events other than from cellEditor\n\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent()))\n\t\t{\n\t\t\tthis.stopEditing(!this.isInvokesStopCellEditing());\n\t\t}\n\n\t\tthis.consumeMouseEvent(evtName, me, sender);\n\t}\n};\n\n/**\n * Function: consumeMouseEvent\n * \n * Consumes the given <mxMouseEvent> if it's a touchStart event.\n */\nmxGraph.prototype.consumeMouseEvent = function(evtName, me, sender)\n{\n\t// Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n\tif (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent()))\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: fireGestureEvent\n * \n * Dispatches a <mxEvent.GESTURE> event. The following example will resize the\n * cell under the mouse based on the scale property of the native touch event.\n * \n * (code)\n * graph.addListener(mxEvent.GESTURE, function(sender, eo)\n * {\n *   var evt = eo.getProperty('event');\n *   var state = graph.view.getState(eo.getProperty('cell'));\n *   \n *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\n *   {\n *     var scale = graph.view.scale;\n *     var tr = graph.view.translate;\n *     \n *     var w = state.width * evt.scale;\n *     var h = state.height * evt.scale;\n *     var x = state.x - (w - state.width) / 2;\n *     var y = state.y - (h - state.height) / 2;\n *     \n *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\n *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\n *     graph.resizeCell(state.cell, bounds);\n *     eo.consume();\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * evt - Gestureend event that represents the gesture.\n * cell - Optional <mxCell> associated with the gesture.\n */\nmxGraph.prototype.fireGestureEvent = function(evt, cell)\n{\n\t// Resets double tap event handling when gestures take place\n\tthis.lastTouchTime = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.GESTURE, 'event', evt, 'cell', cell));\n};\n\n/**\n * Function: destroy\n * \n * Destroys the graph and all its resources.\n */\nmxGraph.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\t\t\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.selectionCellsHandler != null)\n\t\t{\n\t\t\tthis.selectionCellsHandler.destroy();\n\t\t}\n\n\t\tif (this.panningHandler != null)\n\t\t{\n\t\t\tthis.panningHandler.destroy();\n\t\t}\n\n\t\tif (this.popupMenuHandler != null)\n\t\t{\n\t\t\tthis.popupMenuHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.connectionHandler != null)\n\t\t{\n\t\t\tthis.connectionHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.graphHandler != null)\n\t\t{\n\t\t\tthis.graphHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.cellEditor != null)\n\t\t{\n\t\t\tthis.cellEditor.destroy();\n\t\t}\n\t\t\n\t\tif (this.view != null)\n\t\t{\n\t\t\tthis.view.destroy();\n\t\t}\n\n\t\tif (this.model != null && this.graphModelChangeListener != null)\n\t\t{\n\t\t\tthis.model.removeListener(this.graphModelChangeListener);\n\t\t\tthis.graphModelChangeListener = null;\n\t\t}\n\n\t\tthis.container = null;\n\t}\n};\n\n__mxOutput.mxGraph = typeof mxGraph !== 'undefined' ? mxGraph : undefined;\n"]}