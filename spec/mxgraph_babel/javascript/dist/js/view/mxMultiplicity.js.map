{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/view/mxMultiplicity.js"],"names":["mxMultiplicity","source","type","attr","value","min","max","validNeighbors","countError","typeError","validNeighborsAllowed","mxResources","get","prototype","check","graph","edge","target","sourceOut","targetIn","error","checkTerminal","length","isValid","checkNeighbors","sourceValue","model","getValue","targetValue","valid","j","checkType","terminal","attrValue","isNaN","nodeType","mxUtils","isNode","__mxOutput","undefined"],"mappings":";;;;;AAAA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA,WAASA,cAAT,CAAwBC,MAAxB,EAAgCC,IAAhC,EAAsCC,IAAtC,EAA4CC,KAA5C,EAAmDC,GAAnD,EAAwDC,GAAxD,EACCC,cADD,EACiBC,UADjB,EAC6BC,SAD7B,EACwCC,qBADxC,EAEA;AACC,SAAKT,MAAL,GAAcA,MAAd;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,GAAL,GAAYA,OAAO,IAAR,GAAgBA,GAAhB,GAAsB,CAAjC;AACA,SAAKC,GAAL,GAAYA,OAAO,IAAR,GAAgBA,GAAhB,GAAsB,GAAjC;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,UAAL,GAAkBG,YAAYC,GAAZ,CAAgBJ,UAAhB,KAA+BA,UAAjD;AACA,SAAKC,SAAL,GAAiBE,YAAYC,GAAZ,CAAgBH,SAAhB,KAA8BA,SAA/C;AACA,SAAKC,qBAAL,GAA8BA,yBAAyB,IAA1B,GAC5BA,qBAD4B,GACJ,IADzB;AAEA,G;;;AAAA;;AAED;;;;;;;AAOAV,qBAAea,SAAf,CAAyBX,IAAzB,GAAgC,IAAhC;;AAEA;;;;;;AAMAF,qBAAea,SAAf,CAAyBV,IAAzB,GAAgC,IAAhC;;AAEA;;;;;;AAMAH,qBAAea,SAAf,CAAyBT,KAAzB,GAAiC,IAAjC;;AAEA;;;;;;AAMAJ,qBAAea,SAAf,CAAyBZ,MAAzB,GAAkC,IAAlC;;AAEA;;;;;;AAMAD,qBAAea,SAAf,CAAyBR,GAAzB,GAA+B,IAA/B;;AAEA;;;;;;AAMAL,qBAAea,SAAf,CAAyBP,GAAzB,GAA+B,IAA/B;;AAEA;;;;;;;AAOAN,qBAAea,SAAf,CAAyBN,cAAzB,GAA0C,IAA1C;;AAEA;;;;;;AAMAP,qBAAea,SAAf,CAAyBH,qBAAzB,GAAiD,IAAjD;;AAEA;;;;;;;AAOAV,qBAAea,SAAf,CAAyBL,UAAzB,GAAsC,IAAtC;;AAEA;;;;;;AAMAR,qBAAea,SAAf,CAAyBJ,SAAzB,GAAqC,IAArC;;AAEA;;;;;;;;;;;;;;;AAeAT,qBAAea,SAAf,CAAyBC,KAAzB,GAAiC,UAASC,KAAT,EAAgBC,IAAhB,EAAsBf,MAAtB,EAA8BgB,MAA9B,EAAsCC,SAAtC,EAAiDC,QAAjD,EACjC;AACC,YAAIC,QAAQ,EAAZ;;AAEA,YAAK,KAAKnB,MAAL,IAAe,KAAKoB,aAAL,CAAmBN,KAAnB,EAA0Bd,MAA1B,EAAkCe,IAAlC,CAAhB,IACF,CAAC,KAAKf,MAAN,IAAgB,KAAKoB,aAAL,CAAmBN,KAAnB,EAA0BE,MAA1B,EAAkCD,IAAlC,CADlB,EAEA;AACC,cAAI,KAAKR,UAAL,IAAmB,IAAnB,KACD,KAAKP,MAAL,KAAgB,KAAKK,GAAL,IAAY,CAAZ,IAAkBY,aAAa,KAAKZ,GAApD,CAAD,IACA,CAAC,KAAKL,MAAN,KAAiB,KAAKK,GAAL,IAAY,CAAZ,IAAkBa,YAAY,KAAKb,GAApD,CAFE,CAAJ,EAGA;AACCc,qBAAS,KAAKZ,UAAL,GAAkB,IAA3B;AACA;;AAED,cAAI,KAAKD,cAAL,IAAuB,IAAvB,IAA+B,KAAKE,SAAL,IAAkB,IAAjD,IAAyD,KAAKF,cAAL,CAAoBe,MAApB,GAA6B,CAA1F,EACA;AACC,gBAAIC,UAAU,KAAKC,cAAL,CAAoBT,KAApB,EAA2BC,IAA3B,EAAiCf,MAAjC,EAAyCgB,MAAzC,CAAd;;AAEA,gBAAI,CAACM,OAAL,EACA;AACCH,uBAAS,KAAKX,SAAL,GAAiB,IAA1B;AACA;AACD;AACD;;AAED,eAAQW,MAAME,MAAN,GAAe,CAAhB,GAAqBF,KAArB,GAA6B,IAApC;AACA,OA1BD;;AA4BA;;;;;;AAMApB,qBAAea,SAAf,CAAyBW,cAAzB,GAA0C,UAAST,KAAT,EAAgBC,IAAhB,EAAsBf,MAAtB,EAA8BgB,MAA9B,EAC1C;AACC,YAAIQ,cAAcV,MAAMW,KAAN,CAAYC,QAAZ,CAAqB1B,MAArB,CAAlB;AACA,YAAI2B,cAAcb,MAAMW,KAAN,CAAYC,QAAZ,CAAqBV,MAArB,CAAlB;AACA,YAAIM,UAAU,CAAC,KAAKb,qBAApB;AACA,YAAImB,QAAQ,KAAKtB,cAAjB;;AAEA,aAAK,IAAIuB,IAAI,CAAb,EAAgBA,IAAID,MAAMP,MAA1B,EAAkCQ,GAAlC,EACA;AACC,cAAI,KAAK7B,MAAL,IACH,KAAK8B,SAAL,CAAehB,KAAf,EAAsBa,WAAtB,EAAmCC,MAAMC,CAAN,CAAnC,CADD,EAEA;AACCP,sBAAU,KAAKb,qBAAf;AACA;AACA,WALD,MAMK,IAAI,CAAC,KAAKT,MAAN,IACR,KAAK8B,SAAL,CAAehB,KAAf,EAAsBU,WAAtB,EAAmCI,MAAMC,CAAN,CAAnC,CADI,EAEL;AACCP,sBAAU,KAAKb,qBAAf;AACA;AACA;AACD;;AAED,eAAOa,OAAP;AACA,OAxBD;;AA0BA;;;;;;;AAOAvB,qBAAea,SAAf,CAAyBQ,aAAzB,GAAyC,UAASN,KAAT,EAAgBiB,QAAhB,EAA0BhB,IAA1B,EACzC;AACC,YAAIZ,QAAQW,MAAMW,KAAN,CAAYC,QAAZ,CAAqBK,QAArB,CAAZ;;AAEA,eAAO,KAAKD,SAAL,CAAehB,KAAf,EAAsBX,KAAtB,EAA6B,KAAKF,IAAlC,EAAwC,KAAKC,IAA7C,EAAmD,KAAKC,KAAxD,CAAP;AACA,OALD;;AAOA;;;;;AAKAJ,qBAAea,SAAf,CAAyBkB,SAAzB,GAAqC,UAAShB,KAAT,EAAgBX,KAAhB,EAAuBF,IAAvB,EAA6BC,IAA7B,EAAmC8B,SAAnC,EACrC;AACC,YAAI7B,SAAS,IAAb,EACA;AACC,cAAI,CAAC8B,MAAM9B,MAAM+B,QAAZ,CAAL,EAA4B;AAC5B;AACC,qBAAOC,QAAQC,MAAR,CAAejC,KAAf,EAAsBF,IAAtB,EAA4BC,IAA5B,EAAkC8B,SAAlC,CAAP;AACA,aAHD,MAKA;AACC,mBAAO7B,SAASF,IAAhB;AACA;AACD;;AAED,eAAO,KAAP;AACA,OAfD;;AAiBAoC,iBAAWtC,cAAX,GAA4B,OAAOA,cAAP,KAA0B,WAA1B,GAAwCA,cAAxC,GAAyDuC,SAArF","file":"mxMultiplicity.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMultiplicity\n * \n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to <mxGraph.multiplicities>.\n * \n * Example:\n * \n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * (end)\n * \n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n * \n * Constructor: mxMultiplicity\n * \n * Instantiate class mxMultiplicity in order to describe allowed\n * connections in a graph. Not all constraints can be enforced while\n * editing, some must be checked at validation time. The <countError> and\n * <typeError> are treated as resource keys in <mxResources>.\n * \n * Parameters:\n * \n * source - Boolean indicating if this rule applies to the source or target\n * terminal.\n * type - Type of the source or target terminal that this rule applies to.\n * See <type> for more information.\n * attr - Optional attribute name to match the source or target terminal.\n * value - Optional attribute value to match the source or target terminal.\n * min - Minimum number of edges for this rule. Default is 1.\n * max - Maximum number of edges for this rule. n means infinite. Default\n * is n.\n * validNeighbors - Array of types of the opposite terminal for which this\n * rule applies.\n * countError - Error to be displayed for invalid number of edges.\n * typeError - Error to be displayed for invalid opposite terminals.\n * validNeighborsAllowed - Optional boolean indicating if the array of\n * opposite types should be valid or invalid.\n */\nfunction mxMultiplicity(source, type, attr, value, min, max,\n\tvalidNeighbors, countError, typeError, validNeighborsAllowed)\n{\n\tthis.source = source;\n\tthis.type = type;\n\tthis.attr = attr;\n\tthis.value = value;\n\tthis.min = (min != null) ? min : 0;\n\tthis.max = (max != null) ? max : 'n';\n\tthis.validNeighbors = validNeighbors;\n\tthis.countError = mxResources.get(countError) || countError;\n\tthis.typeError = mxResources.get(typeError) || typeError;\n\tthis.validNeighborsAllowed = (validNeighborsAllowed != null) ?\n\t\tvalidNeighborsAllowed : true;\n};\n\n/**\n * Variable: type\n * \n * Defines the type of the source or target terminal. The type is a string\n * passed to <mxUtils.isNode> together with the source or target vertex\n * value as the first argument.\n */\nmxMultiplicity.prototype.type = null;\n\n/**\n * Variable: attr\n * \n * Optional string that specifies the attributename to be passed to\n * <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.attr = null;\n\n/**\n * Variable: value\n * \n * Optional string that specifies the value of the attribute to be passed\n * to <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.value = null;\n\n/**\n * Variable: source\n * \n * Boolean that specifies if the rule is applied to the source or target\n * terminal of an edge.\n */\nmxMultiplicity.prototype.source = null;\n\n/**\n * Variable: min\n * \n * Defines the minimum number of connections for which this rule applies.\n * Default is 0.\n */\nmxMultiplicity.prototype.min = null;\n\n/**\n * Variable: max\n * \n * Defines the maximum number of connections for which this rule applies.\n * A value of 'n' means unlimited times. Default is 'n'. \n */\nmxMultiplicity.prototype.max = null;\n\n/**\n * Variable: validNeighbors\n * \n * Holds an array of strings that specify the type of neighbor for which\n * this rule applies. The strings are used in <mxCell.is> on the opposite\n * terminal to check if the rule applies to the connection.\n */\nmxMultiplicity.prototype.validNeighbors = null;\n\n/**\n * Variable: validNeighborsAllowed\n * \n * Boolean indicating if the list of validNeighbors are those that are allowed\n * for this rule or those that are not allowed for this rule.\n */\nmxMultiplicity.prototype.validNeighborsAllowed = true;\n\n/**\n * Variable: countError\n * \n * Holds the localized error message to be displayed if the number of\n * connections for which the rule applies is smaller than <min> or greater\n * than <max>.\n */\nmxMultiplicity.prototype.countError = null;\n\n/**\n * Variable: typeError\n * \n * Holds the localized error message to be displayed if the type of the\n * neighbor for a connection does not match the rule.\n */\nmxMultiplicity.prototype.typeError = null;\n\n/**\n * Function: check\n * \n * Checks the multiplicity for the given arguments and returns the error\n * for the given connection or null if the multiplicity does not apply.\n *  \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph> instance.\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * sourceOut - Number of outgoing edges from the source terminal.\n * targetIn - Number of incoming edges for the target terminal.\n */\nmxMultiplicity.prototype.check = function(graph, edge, source, target, sourceOut, targetIn)\n{\n\tvar error = '';\n\n\tif ((this.source && this.checkTerminal(graph, source, edge)) ||\n\t\t(!this.source && this.checkTerminal(graph, target, edge)))\n\t{\n\t\tif (this.countError != null && \n\t\t\t((this.source && (this.max == 0 || (sourceOut >= this.max))) ||\n\t\t\t(!this.source && (this.max == 0 || (targetIn >= this.max)))))\n\t\t{\n\t\t\terror += this.countError + '\\n';\n\t\t}\n\n\t\tif (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0)\n\t\t{\n\t\t\tvar isValid = this.checkNeighbors(graph, edge, source, target);\n\n\t\t\tif (!isValid)\n\t\t\t{\n\t\t\t\terror += this.typeError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: checkNeighbors\n * \n * Checks if there are any valid neighbours in <validNeighbors>. This is only\n * called if <validNeighbors> is a non-empty array.\n */\nmxMultiplicity.prototype.checkNeighbors = function(graph, edge, source, target)\n{\n\tvar sourceValue = graph.model.getValue(source);\n\tvar targetValue = graph.model.getValue(target);\n\tvar isValid = !this.validNeighborsAllowed;\n\tvar valid = this.validNeighbors;\n\t\n\tfor (var j = 0; j < valid.length; j++)\n\t{\n\t\tif (this.source &&\n\t\t\tthis.checkType(graph, targetValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t\telse if (!this.source && \n\t\t\tthis.checkType(graph, sourceValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn isValid;\n};\n\n/**\n * Function: checkTerminal\n * \n * Checks the given terminal cell and returns true if this rule applies. The\n * given cell is the source or target of the given edge, depending on\n * <source>. This implementation uses <checkType> on the terminal's value.\n */\nmxMultiplicity.prototype.checkTerminal = function(graph, terminal, edge)\n{\n\tvar value = graph.model.getValue(terminal);\n\t\n\treturn this.checkType(graph, value, this.type, this.attr, this.value);\n};\n\n/**\n * Function: checkType\n * \n * Checks the type of the given value.\n */\nmxMultiplicity.prototype.checkType = function(graph, value, type, attr, attrValue)\n{\n\tif (value != null)\n\t{\n\t\tif (!isNaN(value.nodeType)) // Checks if value is a DOM node\n\t\t{\n\t\t\treturn mxUtils.isNode(value, type, attr, attrValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn value == type;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n__mxOutput.mxMultiplicity = typeof mxMultiplicity !== 'undefined' ? mxMultiplicity : undefined;\n"]}