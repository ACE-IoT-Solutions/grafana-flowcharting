{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/shape/mxConnector.js"],"names":["mxConnector","points","stroke","strokewidth","mxPolyline","call","mxUtils","extend","prototype","updateBoundingBox","useSvgBoundingBox","style","mxConstants","STYLE_CURVED","mxShape","apply","arguments","paintEdgeShape","c","pts","sourceMarker","createMarker","targetMarker","setFillColor","setShadow","setDashed","source","result","n","length","type","getValue","STYLE_STARTARROW","STYLE_ENDARROW","p0","pe","count","Math","round","x","y","dx","dy","dist","max","sqrt","unitX","unitY","size","getNumber","STYLE_STARTSIZE","STYLE_ENDSIZE","DEFAULT_MARKERSIZE","filled","STYLE_STARTFILL","STYLE_ENDFILL","mxMarker","augmentBoundingBox","bbox","NONE","grow","scale","__mxOutput","undefined"],"mappings":"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","file":"mxConnector.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConnector\n * \n * Extends <mxShape> to implement a connector shape. The connector\n * shape allows for arrow heads on either side.\n * \n * This shape is registered under <mxConstants.SHAPE_CONNECTOR> in\n * <mxCellRenderer>.\n * \n * Constructor: mxConnector\n * \n * Constructs a new connector shape.\n * \n * Parameters:\n * \n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * Default is 'black'.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxConnector(points, stroke, strokewidth)\n{\n\tmxPolyline.call(this, points, stroke, strokewidth);\n};\n\n/**\n * Extends mxPolyline.\n */\nmxUtils.extend(mxConnector, mxPolyline);\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\n * <augmentBoundingBox> and stores the result in <boundingBox>.\n */\nmxConnector.prototype.updateBoundingBox = function()\n{\n\tthis.useSvgBoundingBox = this.style != null && this.style[mxConstants.STYLE_CURVED] == 1;\n\tmxShape.prototype.updateBoundingBox.apply(this, arguments);\n};\n\n/**\n * Function: paintEdgeShape\n * \n * Paints the line shape.\n */\nmxConnector.prototype.paintEdgeShape = function(c, pts)\n{\n\t// The indirection via functions for markers is needed in\n\t// order to apply the offsets before painting the line and\n\t// paint the markers after painting the line.\n\tvar sourceMarker = this.createMarker(c, pts, true);\n\tvar targetMarker = this.createMarker(c, pts, false);\n\n\tmxPolyline.prototype.paintEdgeShape.apply(this, arguments);\n\t\n\t// Disables shadows, dashed styles and fixes fill color for markers\n\tc.setFillColor(this.stroke);\n\tc.setShadow(false);\n\tc.setDashed(false);\n\t\n\tif (sourceMarker != null)\n\t{\n\t\tsourceMarker();\n\t}\n\t\n\tif (targetMarker != null)\n\t{\n\t\ttargetMarker();\n\t}\n};\n\n/**\n * Function: createMarker\n * \n * Prepares the marker by adding offsets in pts and returning a function to\n * paint the marker.\n */\nmxConnector.prototype.createMarker = function(c, pts, source)\n{\n\tvar result = null;\n\tvar n = pts.length;\n\tvar type = mxUtils.getValue(this.style, (source) ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);\n\tvar p0 = (source) ? pts[1] : pts[n - 2];\n\tvar pe = (source) ? pts[0] : pts[n - 1];\n\t\n\tif (type != null && p0 != null && pe != null)\n\t{\n\t\tvar count = 1;\n\t\t\n\t\t// Uses next non-overlapping point\n\t\twhile (count < n - 1 && Math.round(p0.x - pe.x) == 0 && Math.round(p0.y - pe.y) == 0)\n\t\t{\n\t\t\tp0 = (source) ? pts[1 + count] : pts[n - 2 - count];\n\t\t\tcount++;\n\t\t}\n\t\n\t\t// Computes the norm and the inverse norm\n\t\tvar dx = pe.x - p0.x;\n\t\tvar dy = pe.y - p0.y;\n\t\n\t\tvar dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n\t\t\n\t\tvar unitX = dx / dist;\n\t\tvar unitY = dy / dist;\n\t\n\t\tvar size = mxUtils.getNumber(this.style, (source) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);\n\t\t\n\t\t// Allow for stroke width in the end point used and the \n\t\t// orthogonal vectors describing the direction of the marker\n\t\tvar filled = this.style[(source) ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL] != 0;\n\t\t\n\t\tresult = mxMarker.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokewidth, filled);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the strokewidth and shadow offsets.\n */\nmxConnector.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\t\n\t// Adds marker sizes\n\tvar size = 0;\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;\n\t}\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = Math.max(size, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;\n\t}\n\t\n\tbbox.grow(size * this.scale);\n};\n\n__mxOutput.mxConnector = typeof mxConnector !== 'undefined' ? mxConnector : undefined;\n"]}