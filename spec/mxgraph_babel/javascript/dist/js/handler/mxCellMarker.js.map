{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/handler/mxCellMarker.js"],"names":["mxCellMarker","graph","validColor","invalidColor","hotspot","mxEventSource","call","mxConstants","DEFAULT_VALID_COLOR","DEFAULT_INVALID_COLOR","DEFAULT_HOTSPOT","highlight","mxCellHighlight","mxUtils","extend","prototype","enabled","hotspotEnabled","currentColor","validState","markedState","setEnabled","isEnabled","setHotspot","getHotspot","setHotspotEnabled","isHotspotEnabled","hasValidState","getValidState","getMarkedState","reset","unmark","process","me","state","getState","setCurrentState","color","isValid","isValidState","getMarkerColor","getEvent","mark","markCell","cell","getView","setHighlightColor","fireEvent","mxEventObject","mxEvent","MARK","evt","view","getCell","getStateToMark","intersects","intersectsHotspot","getGraphX","getGraphY","MIN_HOTSPOT_SIZE","MAX_HOTSPOT_SIZE","destroy","removeListener","resetHandler","getModel","__mxOutput","undefined"],"mappings":"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","file":"mxCellMarker.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellMarker\n * \n * A helper class to process mouse locations and highlight cells.\n * \n * Helper class to highlight cells. To add a cell marker to an existing graph\n * for highlighting all cells, the following code is used:\n * \n * (code)\n * var marker = new mxCellMarker(graph);\n * graph.addMouseListener({\n *   mouseDown: function() {},\n *   mouseMove: function(sender, me)\n *   {\n *     marker.process(me);\n *   },\n *   mouseUp: function() {}\n * });\n * (end)\n *\n * Event: mxEvent.MARK\n * \n * Fires after a cell has been marked or unmarked. The <code>state</code>\n * property contains the marked <mxCellState> or null if no state is marked.\n * \n * Constructor: mxCellMarker\n * \n * Constructs a new cell marker.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * validColor - Optional marker color for valid states. Default is\n * <mxConstants.DEFAULT_VALID_COLOR>.\n * invalidColor - Optional marker color for invalid states. Default is\n * <mxConstants.DEFAULT_INVALID_COLOR>.\n * hotspot - Portion of the width and hight where a state intersects a\n * given coordinate pair. A value of 0 means always highlight. Default is\n * <mxConstants.DEFAULT_HOTSPOT>.\n */\nfunction mxCellMarker(graph, validColor, invalidColor, hotspot)\n{\n\tmxEventSource.call(this);\n\t\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.validColor = (validColor != null) ? validColor : mxConstants.DEFAULT_VALID_COLOR;\n\t\tthis.invalidColor = (invalidColor != null) ? invalidColor : mxConstants.DEFAULT_INVALID_COLOR;\n\t\tthis.hotspot = (hotspot != null) ? hotspot : mxConstants.DEFAULT_HOTSPOT;\n\t\t\n\t\tthis.highlight = new mxCellHighlight(graph);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxCellMarker, mxEventSource);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellMarker.prototype.graph = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if the marker is enabled. Default is true.\n */\nmxCellMarker.prototype.enabled = true;\n\n/**\n * Variable: hotspot\n * \n * Specifies the portion of the width and height that should trigger\n * a highlight. The area around the center of the cell to be marked is used\n * as the hotspot. Possible values are between 0 and 1. Default is\n * mxConstants.DEFAULT_HOTSPOT.\n */\nmxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT; \n\n/**\n * Variable: hotspotEnabled\n * \n * Specifies if the hotspot is enabled. Default is false.\n */\nmxCellMarker.prototype.hotspotEnabled = false;\n\n/**\n * Variable: validColor\n * \n * Holds the valid marker color.\n */\nmxCellMarker.prototype.validColor = null;\n\n/**\n * Variable: invalidColor\n * \n * Holds the invalid marker color.\n */\nmxCellMarker.prototype.invalidColor = null;\n\n/**\n * Variable: currentColor\n * \n * Holds the current marker color.\n */\nmxCellMarker.prototype.currentColor = null;\n\n/**\n * Variable: validState\n * \n * Holds the marked <mxCellState> if it is valid.\n */\nmxCellMarker.prototype.validState = null; \n\n/**\n * Variable: markedState\n * \n * Holds the marked <mxCellState>.\n */\nmxCellMarker.prototype.markedState = null;\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxCellMarker.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxCellMarker.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setHotspot\n * \n * Sets the <hotspot>.\n */\nmxCellMarker.prototype.setHotspot = function(hotspot)\n{\n\tthis.hotspot = hotspot;\n};\n\n/**\n * Function: getHotspot\n * \n * Returns the <hotspot>.\n */\nmxCellMarker.prototype.getHotspot = function()\n{\n\treturn this.hotspot;\n};\n\n/**\n * Function: setHotspotEnabled\n * \n * Specifies whether the hotspot should be used in <intersects>.\n */\nmxCellMarker.prototype.setHotspotEnabled = function(enabled)\n{\n\tthis.hotspotEnabled = enabled;\n};\n\n/**\n * Function: isHotspotEnabled\n * \n * Returns true if hotspot is used in <intersects>.\n */\nmxCellMarker.prototype.isHotspotEnabled = function()\n{\n\treturn this.hotspotEnabled;\n};\n\n/**\n * Function: hasValidState\n * \n * Returns true if <validState> is not null.\n */\nmxCellMarker.prototype.hasValidState = function()\n{\n\treturn this.validState != null;\n};\n\n/**\n * Function: getValidState\n * \n * Returns the <validState>.\n */\nmxCellMarker.prototype.getValidState = function()\n{\n\treturn this.validState;\n};\n\n/**\n * Function: getMarkedState\n * \n * Returns the <markedState>.\n */\nmxCellMarker.prototype.getMarkedState = function()\n{\n\treturn this.markedState;\n};\n\n/**\n * Function: reset\n * \n * Resets the state of the cell marker.\n */\nmxCellMarker.prototype.reset = function()\n{\n\tthis.validState = null;\n\t\n\tif (this.markedState != null)\n\t{\n\t\tthis.markedState = null;\n\t\tthis.unmark();\n\t}\n};\n\n/**\n * Function: process\n * \n * Processes the given event and cell and marks the state returned by\n * <getState> with the color returned by <getMarkerColor>. If the\n * markerColor is not null, then the state is stored in <markedState>. If\n * <isValidState> returns true, then the state is stored in <validState>\n * regardless of the marker color. The state is returned regardless of the\n * marker color and valid state. \n */\nmxCellMarker.prototype.process = function(me)\n{\n\tvar state = null;\n\t\n\tif (this.isEnabled())\n\t{\n\t\tstate = this.getState(me);\n\t\tthis.setCurrentState(state, me);\n\t}\n\t\n\treturn state;\n};\n\n/**\n * Function: setCurrentState\n * \n * Sets and marks the current valid state.\n */\nmxCellMarker.prototype.setCurrentState = function(state, me, color)\n{\n\tvar isValid = (state != null) ? this.isValidState(state) : false;\n\tcolor = (color != null) ? color : this.getMarkerColor(me.getEvent(), state, isValid);\n\t\n\tif (isValid)\n\t{\n\t\tthis.validState = state;\n\t}\n\telse\n\t{\n\t\tthis.validState = null;\n\t}\n\t\n\tif (state != this.markedState || color != this.currentColor)\n\t{\n\t\tthis.currentColor = color;\n\t\t\n\t\tif (state != null && this.currentColor != null)\n\t\t{\n\t\t\tthis.markedState = state;\n\t\t\tthis.mark();\t\t\n\t\t}\n\t\telse if (this.markedState != null)\n\t\t{\n\t\t\tthis.markedState = null;\n\t\t\tthis.unmark();\n\t\t}\n\t}\n};\n\n/**\n * Function: markCell\n * \n * Marks the given cell using the given color, or <validColor> if no color is specified.\n */\nmxCellMarker.prototype.markCell = function(cell, color)\n{\n\tvar state = this.graph.getView().getState(cell);\n\t\n\tif (state != null)\n\t{\n\t\tthis.currentColor = (color != null) ? color : this.validColor;\n\t\tthis.markedState = state;\n\t\tthis.mark();\n\t}\n};\n\n/**\n * Function: mark\n * \n * Marks the <markedState> and fires a <mark> event.\n */\nmxCellMarker.prototype.mark = function()\n{\n\tthis.highlight.setHighlightColor(this.currentColor);\n\tthis.highlight.highlight(this.markedState);\n\tthis.fireEvent(new mxEventObject(mxEvent.MARK, 'state', this.markedState));\n};\n\n/**\n * Function: unmark\n * \n * Hides the marker and fires a <mark> event.\n */\nmxCellMarker.prototype.unmark = function()\n{\n\tthis.mark();\n};\n\n/**\n * Function: isValidState\n * \n * Returns true if the given <mxCellState> is a valid state. If this\n * returns true, then the state is stored in <validState>. The return value\n * of this method is used as the argument for <getMarkerColor>.\n */\nmxCellMarker.prototype.isValidState = function(state)\n{\n\treturn true;\n};\n\n/**\n * Function: getMarkerColor\n * \n * Returns the valid- or invalidColor depending on the value of isValid.\n * The given <mxCellState> is ignored by this implementation.\n */\nmxCellMarker.prototype.getMarkerColor = function(evt, state, isValid)\n{\n\treturn (isValid) ? this.validColor : this.invalidColor;\n};\n\n/**\n * Function: getState\n * \n * Uses <getCell>, <getStateToMark> and <intersects> to return the\n * <mxCellState> for the given <mxMouseEvent>.\n */\nmxCellMarker.prototype.getState = function(me)\n{\n\tvar view = this.graph.getView();\n\tvar cell = this.getCell(me);\n\tvar state = this.getStateToMark(view.getState(cell));\n\n\treturn (state != null && this.intersects(state, me)) ? state : null;\n};\n\n/**\n * Function: getCell\n * \n * Returns the <mxCell> for the given event and cell. This returns the\n * given cell.\n */\nmxCellMarker.prototype.getCell = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: getStateToMark\n * \n * Returns the <mxCellState> to be marked for the given <mxCellState> under\n * the mouse. This returns the given state.\n */\nmxCellMarker.prototype.getStateToMark = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: intersects\n * \n * Returns true if the given coordinate pair intersects the given state.\n * This returns true if the <hotspot> is 0 or the coordinates are inside\n * the hotspot for the given cell state.\n */\nmxCellMarker.prototype.intersects = function(state, me)\n{\n\tif (this.hotspotEnabled)\n\t{\n\t\treturn mxUtils.intersectsHotspot(state, me.getGraphX(), me.getGraphY(),\n\t\t\tthis.hotspot, mxConstants.MIN_HOTSPOT_SIZE,\n\t\t\tmxConstants.MAX_HOTSPOT_SIZE);\n\t}\n\t\n\treturn true;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxCellMarker.prototype.destroy = function()\n{\n\tthis.graph.getView().removeListener(this.resetHandler);\n\tthis.graph.getModel().removeListener(this.resetHandler);\n\tthis.highlight.destroy();\n};\n\n__mxOutput.mxCellMarker = typeof mxCellMarker !== 'undefined' ? mxCellMarker : undefined;\n"]}