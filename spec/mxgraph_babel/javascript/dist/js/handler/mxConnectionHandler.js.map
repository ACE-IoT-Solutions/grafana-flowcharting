{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/handler/mxConnectionHandler.js"],"names":["mxConnectionHandler","graph","factoryMethod","mxEventSource","call","init","escapeHandler","mxUtils","bind","sender","evt","reset","addListener","mxEvent","ESCAPE","extend","prototype","moveIconFront","moveIconBack","connectImage","targetConnectImage","enabled","select","createTarget","marker","constraintHandler","error","waypointsEnabled","ignoreMouseDown","first","connectIconOffset","mxPoint","mxConstants","TOOLTIP_VERTICAL_OFFSET","edgeState","changeHandler","drillHandler","mouseDownCounter","movePreviewAway","mxClient","IS_VML","outlineConnect","livePreview","cursor","insertBeforeSource","isEnabled","setEnabled","isInsertBefore","edge","source","target","dropTarget","isCreateTarget","setCreateTarget","value","createShape","shape","cellRenderer","mxPolyline","INVALID_COLOR","dialect","DIALECT_SVG","DIALECT_VML","scale","view","pointerEvents","isDashed","getView","getOverlayPane","redirectMouseEvents","node","addMouseListener","createMarker","mxConstraintHandler","iconState","getState","cell","redrawIcons","icons","previous","getModel","CHANGE","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","START_EDITING","DOWN","UP","isConnectableCell","mxCellMarker","hotspotEnabled","getCell","me","apply","arguments","currentPoint","getCellAt","x","y","isCellConnectable","parent","getParent","isVertex","isSwimlane","hitsSwimlaneContent","isConnecting","validateConnection","length","getEvent","isValidSource","allowDanglingEdges","isValidState","state","getMarkerColor","isValid","intersects","start","createEdgeState","currentColor","validColor","markedState","mark","fireEvent","mxEventObject","START","isValidTarget","getEdgeValidationError","getConnectImage","isMoveIconToFrontForState","text","parentNode","container","createIcons","image","bounds","mxRectangle","width","height","icon","mxImageShape","src","preserveImageAspect","DIALECT_STRICTHTML","previousSibling","insertBefore","firstChild","style","CURSOR_CONNECT","currentState","mouseDown","isConsumed","fireMouseEvent","MOUSE_DOWN","mxMouseEvent","push","pos","getIconPosition","redraw","cx","getCenterX","cy","getCenterY","size","getStartSize","alpha","toRadians","getValue","STYLE_ROTATION","cos","Math","sin","ct","pt","getRotatedPoint","destroyIcons","i","destroy","selectedIcon","isStartEvent","currentFocus","currentConstraint","sourceConstraint","clone","getGraphX","getGraphY","waypoints","getPointForEvent","geometry","setTerminalPoint","consume","isImmediateConnectSource","isCellMovable","isOutlineConnectEvent","offset","getOffset","clientX","getClientX","clientY","getClientY","doc","document","documentElement","left","window","pageXOffset","scrollLeft","clientLeft","top","pageYOffset","scrollTop","clientTop","gridX","gridY","isShiftDown","isSource","highlight","isAltDown","isHighlightAt","updateCurrentState","point","update","stroke","repaint","markCell","isIgnoreTerminalEvent","process","getValidState","isCellEnabled","outline","constraint","getOutlineConstraint","setFocus","s","OUTLINE_HIGHLIGHT_COLOR","strokewidth","OUTLINE_HIGHLIGHT_STROKEWIDTH","hasValidState","DEFAULT_VALID_COLOR","HIGHLIGHT_STROKEWIDTH","convertWaypoint","getScale","tr","getTranslate","snapToPreview","tol","gridSize","tmp","abs","mouseMove","isMouseDown","translate","isGridEnabledEvent","snap","tolerance","current","pt2","w","h","updateEdgeState","absolutePoints","getTargetPerimeterPoint","next","getSourcePerimeterPoint","tmp2","dx","dy","len","sqrt","originalPoint","points","pts","concat","drawPreview","setCursor","hitsIcon","getSource","updateIcons","STYLE_EXIT_X","STYLE_EXIT_Y","STYLE_ENTRY_X","STYLE_ENTRY_Y","updateFixedTerminalPoint","getConnectionConstraint","setAbsoluteTerminalPoint","realPoints","updatePoints","updateFloatingTerminalPoints","result","targetPerimeter","getPerimeterFunction","getPerimeterBounds","sourcePerimeter","c","theta","rad","PI","isStopEvent","addWaypointForEvent","convertPoint","getX","getY","addPoint","checkConstraints","c1","c2","equals","perimeter","mouseUp","connect","validState","selectCellForEvent","validationAlert","RESET","updatePreview","valid","getEdgeWidth","getEdgeColor","VALID_COLOR","model","terminalInserted","beginUpdate","createTargetVertex","getDropTarget","isEdge","pstate","getGeometry","origin","getDefaultParent","addCell","getRoot","relative","insertEdge","setConnectionConstraint","setGeometry","index","add","getIndex","geo","mxGeometry","t","panDx","panDy","CONNECT","e","mxLog","show","debug","message","endUpdate","selectCells","setSelectionCell","id","createEdge","addEdge","getCellGeometry","cloneCell","round","getAlignmentTolerance","sourceState","isGridEnabled","mxCell","setEdge","setStyle","removeMouseListener","removeListener","__mxOutput","undefined"],"mappings":"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","file":"mxConnectionHandler.js","sourcesContent":["/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\n/**\n * Class: mxConnectionHandler\n *\n * Graph event handler that creates new connections. Uses <mxTerminalMarker>\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * <mxGraph.connectionHandler> and enabled using <mxGraph.setConnectable>.\n *\n * Example:\n * \n * (code)\n * new mxConnectionHandler(graph, function(source, target, style)\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * (end)\n * \n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * (code)\n * mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;\n * mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n * {\n *   value = 'Test';\n * \n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * (end)\n * \n * Using images to trigger connections:\n * \n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n * \n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * <mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * <mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the\n * width and height of the hotspot.\n * \n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n * \n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * <mxImageShape> for creating new connections, but the default implementation\n * supports one image and is used as follows:\n * \n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n * \n * (code)\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * (end)\n * \n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n * \n * (code)\n * mxConstants.HIGHLIGHT_COLOR = null;\n * (end)\n * \n * To install the image, the connectImage field of the mxConnectionHandler must\n * be assigned a new <mxImage> instance:\n * \n * (code)\n * mxConnectionHandler.prototype.connectImage = new mxImage('images/green-dot.gif', 14, 14);\n * (end)\n * \n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n * \n * Event: mxEvent.START\n * \n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n * \n * Event: mxEvent.CONNECT\n * \n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code> \n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n * \n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, <mxGraph.getConnectionConstraint> can be used. To resolve\n * the port IDs, use <mxGraphModel.getCell>.\n * \n * (code)\n * graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt)\n * {\n *   var edge = evt.getProperty('cell');\n *   var source = graph.getModel().getTerminal(edge, true);\n *   var target = graph.getModel().getTerminal(edge, false);\n *   \n *   var style = graph.getCellStyle(edge);\n *   var sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   var targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *   \n *   mxLog.show();\n *   mxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * (end)\n *\n * Event: mxEvent.RESET\n * \n * Fires when the <reset> method is invoked.\n *\n * Constructor: mxConnectionHandler\n *\n * Constructs an event handler that connects vertices using the specified\n * factory method to create the new edges. Modify\n * <mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers\n * the creation of a new connection or use connect icons as explained\n * above.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * factoryMethod - Optional function to create the edge. The function takes\n * the source and target <mxCell> as the first and second argument and an\n * optional cell style from the preview as the third argument. It returns\n * the <mxCell> that represents the new edge.\n */\nfunction mxConnectionHandler(graph, factoryMethod)\n{\n\tmxEventSource.call(this);\n\t\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.factoryMethod = factoryMethod;\n\t\tthis.init();\n\t\t\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tthis.reset();\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxConnectionHandler, mxEventSource);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxConnectionHandler.prototype.graph = null;\n\n/**\n * Variable: factoryMethod\n * \n * Function that is used for creating new edges. The function takes the\n * source and target <mxCell> as the first and second argument and returns\n * a new <mxCell> that represents the edge. This is used in <createEdge>.\n */\nmxConnectionHandler.prototype.factoryMethod = true;\n\n/**\n * Variable: moveIconFront\n * \n * Specifies if icons should be displayed inside the graph container instead\n * of the overlay pane. This is used for HTML labels on vertices which hide\n * the connect icon. This has precendence over <moveIconBack> when set\n * to true. Default is false.\n */\nmxConnectionHandler.prototype.moveIconFront = false;\n\n/**\n * Variable: moveIconBack\n * \n * Specifies if icons should be moved to the back of the overlay pane. This can\n * be set to true if the icons of the connection handler conflict with other\n * handles, such as the vertex label move handle. Default is false.\n */\nmxConnectionHandler.prototype.moveIconBack = false;\n\n/**\n * Variable: connectImage\n * \n * <mxImage> that is used to trigger the creation of a new connection. This\n * is used in <createIcons>. Default is null.\n */\nmxConnectionHandler.prototype.connectImage = null;\n\n/**\n * Variable: targetConnectImage\n * \n * Specifies if the connect icon should be centered on the target state\n * while connections are being previewed. Default is false.\n */\nmxConnectionHandler.prototype.targetConnectImage = false;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxConnectionHandler.prototype.enabled = true;\n\n/**\n * Variable: select\n * \n * Specifies if new edges should be selected. Default is true.\n */\nmxConnectionHandler.prototype.select = true;\n\n/**\n * Variable: createTarget\n * \n * Specifies if <createTargetVertex> should be called if no target was under the\n * mouse for the new connection. Setting this to true means the connection\n * will be drawn as valid if no target is under the mouse, and\n * <createTargetVertex> will be called before the connection is created between\n * the source cell and the newly created vertex in <createTargetVertex>, which\n * can be overridden to create a new target. Default is false.\n */\nmxConnectionHandler.prototype.createTarget = false;\n\n/**\n * Variable: marker\n * \n * Holds the <mxTerminalMarker> used for finding source and target cells.\n */\nmxConnectionHandler.prototype.marker = null;\n\n/**\n * Variable: constraintHandler\n * \n * Holds the <mxConstraintHandler> used for drawing and highlighting\n * constraints.\n */\nmxConnectionHandler.prototype.constraintHandler = null;\n\n/**\n * Variable: error\n * \n * Holds the current validation error while connections are being created.\n */\nmxConnectionHandler.prototype.error = null;\n\n/**\n * Variable: waypointsEnabled\n * \n * Specifies if single clicks should add waypoints on the new edge. Default is\n * false.\n */\nmxConnectionHandler.prototype.waypointsEnabled = false;\n\n/**\n * Variable: ignoreMouseDown\n * \n * Specifies if the connection handler should ignore the state of the mouse\n * button when highlighting the source. Default is false, that is, the\n * handler only highlights the source if no button is being pressed.\n */\nmxConnectionHandler.prototype.ignoreMouseDown = false;\n\n/**\n * Variable: first\n * \n * Holds the <mxPoint> where the mouseDown took place while the handler is\n * active.\n */\nmxConnectionHandler.prototype.first = null;\n\n/**\n * Variable: connectIconOffset\n * \n * Holds the offset for connect icons during connection preview.\n * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).\n * Note that placing the icon under the mouse pointer with an\n * offset of (0,0) will affect hit detection.\n */\nmxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);\n\n/**\n * Variable: edgeState\n * \n * Optional <mxCellState> that represents the preview edge while the\n * handler is active. This is created in <createEdgeState>.\n */\nmxConnectionHandler.prototype.edgeState = null;\n\n/**\n * Variable: changeHandler\n * \n * Holds the change event listener for later removal.\n */\nmxConnectionHandler.prototype.changeHandler = null;\n\n/**\n * Variable: drillHandler\n * \n * Holds the drill event listener for later removal.\n */\nmxConnectionHandler.prototype.drillHandler = null;\n\n/**\n * Variable: mouseDownCounter\n * \n * Counts the number of mouseDown events since the start. The initial mouse\n * down event counts as 1.\n */\nmxConnectionHandler.prototype.mouseDownCounter = 0;\n\n/**\n * Variable: movePreviewAway\n * \n * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n * where the preview cannot be made transparent to events and if the built-in hit detection on\n * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.\n */\nmxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML;\n\n/**\n * Variable: outlineConnect\n * \n * Specifies if connections to the outline of a highlighted target should be\n * enabled. This will allow to place the connection point along the outline of\n * the highlighted target. Default is false.\n */\nmxConnectionHandler.prototype.outlineConnect = false;\n\n/**\n * Variable: livePreview\n * \n * Specifies if the actual shape of the edge state should be used for the preview.\n * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n */\nmxConnectionHandler.prototype.livePreview = false;\n\n/**\n * Variable: cursor\n * \n * Specifies the cursor to be used while the handler is active. Default is null.\n */\nmxConnectionHandler.prototype.cursor = null;\n\n/**\n * Variable: insertBeforeSource\n * \n * Specifies if new edges should be inserted before the source vertex in the\n * cell hierarchy. Default is false for backwards compatibility.\n */\nmxConnectionHandler.prototype.insertBeforeSource = false;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxConnectionHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\t\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxConnectionHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isInsertBefore\n * \n * Returns <insertBeforeSource> for non-loops and false for loops.\n *\n * Parameters:\n * \n * edge - <mxCell> that represents the edge to be inserted.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, dropTarget)\n{\n\treturn this.insertBeforeSource && source != target;\n};\n\n/**\n * Function: isCreateTarget\n * \n * Returns <createTarget>.\n *\n * Parameters:\n *\n * evt - Current active native pointer event.\n */\nmxConnectionHandler.prototype.isCreateTarget = function(evt)\n{\n\treturn this.createTarget;\n};\n\n/**\n * Function: setCreateTarget\n * \n * Sets <createTarget>.\n */\nmxConnectionHandler.prototype.setCreateTarget = function(value)\n{\n\tthis.createTarget = value;\n};\n\n/**\n * Function: createShape\n * \n * Creates the preview shape for new connections.\n */\nmxConnectionHandler.prototype.createShape = function()\n{\n\t// Creates the edge preview\n\tvar shape = (this.livePreview && this.edgeState != null) ?\n\t\tthis.graph.cellRenderer.createShape(this.edgeState) :\n\t\tnew mxPolyline([], mxConstants.INVALID_COLOR);\n\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tshape.scale = this.graph.view.scale;\n\tshape.pointerEvents = false;\n\tshape.isDashed = true;\n\tshape.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(shape.node, this.graph, null);\n\n\treturn shape;\n};\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this connection handler. This should\n * be invoked if <mxGraph.container> is assigned after the connection\n * handler has been created.\n */\nmxConnectionHandler.prototype.init = function()\n{\n\tthis.graph.addMouseListener(this);\n\tthis.marker = this.createMarker();\n\tthis.constraintHandler = new mxConstraintHandler(this.graph);\n\n\t// Redraws the icons if the graph changes\n\tthis.changeHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.iconState = this.graph.getView().getState(this.iconState.cell);\n\t\t}\n\t\t\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.redrawIcons(this.icons, this.iconState);\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != null && this.graph.view.getState(this.previous.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t});\n\t\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n\t\n\t// Removes the icon if we step into/up or start editing\n\tthis.drillHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.reset();\n\t});\n\t\n\tthis.graph.addListener(mxEvent.START_EDITING, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.UP, this.drillHandler);\n};\n\n/**\n * Function: isConnectableCell\n * \n * Returns true if the given cell is connectable. This is a hook to\n * disable floating connections. This implementation returns true.\n */\nmxConnectionHandler.prototype.isConnectableCell = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: createMarker\n * \n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxConnectionHandler.prototype.createMarker = function()\n{\n\tvar marker = new mxCellMarker(this.graph);\n\tmarker.hotspotEnabled = true;\n\n\t// Overrides to return cell at location only if valid (so that\n\t// there is no highlight for invalid cells)\n\tmarker.getCell = mxUtils.bind(this, function(me)\n\t{\n\t\tvar cell = mxCellMarker.prototype.getCell.apply(marker, arguments);\n\t\tthis.error = null;\n\t\t\n\t\t// Checks for cell at preview point (with grid)\n\t\tif (cell == null && this.currentPoint != null)\n\t\t{\n\t\t\tcell = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);\n\t\t}\n\t\t\n\t\t// Uses connectable parent vertex if one exists\n\t\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\t\t\n\t\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t\t{\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ((this.graph.isSwimlane(cell) && this.currentPoint != null &&\n\t\t\tthis.graph.hitsSwimlaneContent(cell, this.currentPoint.x, this.currentPoint.y)) ||\n\t\t\t!this.isConnectableCell(cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isConnecting())\n\t\t\t{\n\t\t\t\tif (this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tthis.error = this.validateConnection(this.previous.cell, cell);\n\t\t\t\t\t\n\t\t\t\t\tif (this.error != null && this.error.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Enables create target inside groups\n\t\t\t\t\t\tif (this.isCreateTarget(me.getEvent()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.error = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!this.isValidSource(cell, me))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\t\telse if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) &&\n\t\t\t\t!this.graph.allowDanglingEdges)\n\t\t{\n\t\t\tthis.error = '';\n\t\t}\n\n\t\treturn cell;\n\t});\n\n\t// Sets the highlight color according to validateConnection\n\tmarker.isValidState = mxUtils.bind(this, function(state)\n\t{\n\t\tif (this.isConnecting())\n\t\t{\n\t\t\treturn this.error == null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn mxCellMarker.prototype.isValidState.apply(marker, arguments);\n\t\t}\n\t});\n\n\t// Overrides to use marker color only in highlight mode or for\n\t// target selection\n\tmarker.getMarkerColor = mxUtils.bind(this, function(evt, state, isValid)\n\t{\n\t\treturn (this.connectImage == null || this.isConnecting()) ?\n\t\t\tmxCellMarker.prototype.getMarkerColor.apply(marker, arguments) :\n\t\t\tnull;\n\t});\n\n\t// Overrides to use hotspot only for source selection otherwise\n\t// intersects always returns true when over a cell\n\tmarker.intersects = mxUtils.bind(this, function(state, evt)\n\t{\n\t\tif (this.connectImage != null || this.isConnecting())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn mxCellMarker.prototype.intersects.apply(marker, arguments);\n\t});\n\n\treturn marker;\n};\n\n/**\n * Function: start\n * \n * Starts a new connection for the given state and coordinates.\n */\nmxConnectionHandler.prototype.start = function(state, x, y, edgeState)\n{\n\tthis.previous = state;\n\tthis.first = new mxPoint(x, y);\n\tthis.edgeState = (edgeState != null) ? edgeState : this.createEdgeState(null);\n\t\n\t// Marks the source state\n\tthis.marker.currentColor = this.marker.validColor;\n\tthis.marker.markedState = state;\n\tthis.marker.mark();\n\n\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n};\n\n/**\n * Function: isConnecting\n * \n * Returns true if the source terminal has been clicked and a new\n * connection is currently being previewed.\n */\nmxConnectionHandler.prototype.isConnecting = function()\n{\n\treturn this.first != null && this.shape != null;\n};\n\n/**\n * Function: isValidSource\n * \n * Returns <mxGraph.isValidSource> for the given source terminal.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the source terminal.\n * me - <mxMouseEvent> that is associated with this call.\n */\nmxConnectionHandler.prototype.isValidSource = function(cell, me)\n{\n\treturn this.graph.isValidSource(cell);\n};\n\n/**\n * Function: isValidTarget\n * \n * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling\n * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an\n * additional hook for disabling certain targets in this specific handler.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.isValidTarget = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: validateConnection\n * \n * Returns the error message or an empty string if the connection for the\n * given source target pair is not valid. Otherwise it returns null. This\n * implementation uses <mxGraph.getEdgeValidationError>.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.validateConnection = function(source, target)\n{\n\tif (!this.isValidTarget(target))\n\t{\n\t\treturn '';\n\t}\n\t\n\treturn this.graph.getEdgeValidationError(null, source, target);\n};\n\n/**\n * Function: getConnectImage\n * \n * Hook to return the <mxImage> used for the connection icon of the given\n * <mxCellState>. This implementation returns <connectImage>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect image should be returned.\n */\nmxConnectionHandler.prototype.getConnectImage = function(state)\n{\n\treturn this.connectImage;\n};\n\n/**\n * Function: isMoveIconToFrontForState\n * \n * Returns true if the state has a HTML label in the graph's container, otherwise\n * it returns <moveIconFront>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.isMoveIconToFrontForState = function(state)\n{\n\tif (state.text != null && state.text.node.parentNode == this.graph.container)\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn this.moveIconFront;\n};\n\n/**\n * Function: createIcons\n * \n * Creates the array <mxImageShapes> that represent the connect icons for\n * the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.createIcons = function(state)\n{\n\tvar image = this.getConnectImage(state);\n\t\n\tif (image != null && state != null)\n\t{\n\t\tthis.iconState = state;\n\t\tvar icons = [];\n\n\t\t// Cannot use HTML for the connect icons because the icon receives all\n\t\t// mouse move events in IE, must use VML and SVG instead even if the\n\t\t// connect-icon appears behind the selection border and the selection\n\t\t// border consumes the events before the icon gets a chance\n\t\tvar bounds = new mxRectangle(0, 0, image.width, image.height);\n\t\tvar icon = new mxImageShape(bounds, image.src, null, null, 0);\n\t\ticon.preserveImageAspect = false;\n\t\t\n\t\tif (this.isMoveIconToFrontForState(state))\n\t\t{\n\t\t\ticon.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\t\ticon.init(this.graph.container);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ticon.dialect = (this.graph.dialect == mxConstants.DIALECT_SVG) ?\n\t\t\t\tmxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;\n\t\t\ticon.init(this.graph.getView().getOverlayPane());\n\n\t\t\t// Move the icon back in the overlay pane\n\t\t\tif (this.moveIconBack && icon.node.previousSibling != null)\n\t\t\t{\n\t\t\t\ticon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n\t\t\t}\n\t\t}\n\n\t\ticon.node.style.cursor = mxConstants.CURSOR_CONNECT;\n\n\t\t// Events transparency\n\t\tvar getState = mxUtils.bind(this, function()\n\t\t{\n\t\t\treturn (this.currentState != null) ? this.currentState : state;\n\t\t});\n\t\t\n\t\t// Updates the local icon before firing the mouse down event.\n\t\tvar mouseDown = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tthis.icon = icon;\n\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN,\n\t\t\t\t\tnew mxMouseEvent(evt, getState()));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n\t\t\n\t\ticons.push(icon);\n\t\tthis.redrawIcons(icons, this.iconState);\n\t\t\n\t\treturn icons;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: redrawIcons\n * \n * Redraws the given array of <mxImageShapes>.\n * \n * Parameters:\n * \n * icons - Optional array of <mxImageShapes> to be redrawn.\n */\nmxConnectionHandler.prototype.redrawIcons = function(icons, state)\n{\n\tif (icons != null && icons[0] != null && state != null)\n\t{\n\t\tvar pos = this.getIconPosition(icons[0], state);\n\t\ticons[0].bounds.x = pos.x;\n\t\ticons[0].bounds.y = pos.y;\n\t\ticons[0].redraw();\n\t}\n};\n\n/**\n * Function: redrawIcons\n * \n * Redraws the given array of <mxImageShapes>.\n * \n * Parameters:\n * \n * icons - Optional array of <mxImageShapes> to be redrawn.\n */\nmxConnectionHandler.prototype.getIconPosition = function(icon, state)\n{\n\tvar scale = this.graph.getView().scale;\n\tvar cx = state.getCenterX();\n\tvar cy = state.getCenterY();\n\t\n\tif (this.graph.isSwimlane(state.cell))\n\t{\n\t\tvar size = this.graph.getStartSize(state.cell);\n\t\t\n\t\tcx = (size.width != 0) ? state.x + size.width * scale / 2 : cx;\n\t\tcy = (size.height != 0) ? state.y + size.height * scale / 2 : cy;\n\t\t\n\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\t\t\tvar ct = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin, ct);\n\t\t\tcx = pt.x;\n\t\t\tcy = pt.y;\n\t\t}\n\t}\n\n\treturn new mxPoint(cx - icon.bounds.width / 2,\n\t\t\tcy - icon.bounds.height / 2);\n};\n\n/**\n * Function: destroyIcons\n * \n * Destroys the connect icons and resets the respective state.\n */\nmxConnectionHandler.prototype.destroyIcons = function()\n{\n\tif (this.icons != null)\n\t{\n\t\tfor (var i = 0; i < this.icons.length; i++)\n\t\t{\n\t\t\tthis.icons[i].destroy();\n\t\t}\n\t\t\n\t\tthis.icons = null;\n\t\tthis.icon = null;\n\t\tthis.selectedIcon = null;\n\t\tthis.iconState = null;\n\t}\n};\n\n/**\n * Function: isStartEvent\n * \n * Returns true if the given mouse down event should start this handler. The\n * This implementation returns true if the event does not force marquee\n * selection, and the currentConstraint and currentFocus of the\n * <constraintHandler> are not null, or <previous> and <error> are not null and\n * <icons> is null or <icons> and <icon> are not null.\n */\nmxConnectionHandler.prototype.isStartEvent = function(me)\n{\n\treturn ((this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) ||\n\t\t(this.previous != null && this.error == null && (this.icons == null || (this.icons != null &&\n\t\tthis.icon != null))));\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating a new connection.\n */\nmxConnectionHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.mouseDownCounter++;\n\t\n\tif (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() &&\n\t\t!this.isConnecting() && this.isStartEvent(me))\n\t{\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t{\n\t\t\tthis.sourceConstraint = this.constraintHandler.currentConstraint;\n\t\t\tthis.previous = this.constraintHandler.currentFocus;\n\t\t\tthis.first = this.constraintHandler.currentPoint.clone();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Stores the location of the initial mousedown\n\t\t\tthis.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t}\n\t\n\t\tthis.edgeState = this.createEdgeState(me);\n\t\tthis.mouseDownCounter = 1;\n\t\t\n\t\tif (this.waypointsEnabled && this.shape == null)\n\t\t{\n\t\t\tthis.waypoints = null;\n\t\t\tthis.shape = this.createShape();\n\t\t\t\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t}\n\t\t}\n\n\t\t// Stores the starting point in the geometry of the preview\n\t\tif (this.previous == null && this.edgeState != null)\n\t\t{\n\t\t\tvar pt = this.graph.getPointForEvent(me.getEvent());\n\t\t\tthis.edgeState.cell.geometry.setTerminalPoint(pt, true);\n\t\t}\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n\n\t\tme.consume();\n\t}\n\n\tthis.selectedIcon = this.icon;\n\tthis.icon = null;\n};\n\n/**\n * Function: isImmediateConnectSource\n * \n * Returns true if a tap on the given source state should immediately start\n * connecting. This implementation returns true if the state is not movable\n * in the graph. \n */\nmxConnectionHandler.prototype.isImmediateConnectSource = function(state)\n{\n\treturn !this.graph.isCellMovable(state.cell);\n};\n\n/**\n * Function: createEdgeState\n * \n * Hook to return an <mxCellState> which may be used during the preview.\n * This implementation returns null.\n * \n * Use the following code to create a preview for an existing edge style:\n * \n * (code)\n * graph.connectionHandler.createEdgeState = function(me)\n * {\n *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n *   \n *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n * };\n * (end)\n */\nmxConnectionHandler.prototype.createEdgeState = function(me)\n{\n\treturn null;\n};\n\n/**\n * Function: isOutlineConnectEvent\n * \n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n * or shift is pressed.\n */\nmxConnectionHandler.prototype.isOutlineConnectEvent = function(me)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar evt = me.getEvent();\n\t\n\tvar clientX = mxEvent.getClientX(evt);\n\tvar clientY = mxEvent.getClientY(evt);\n\t\n\tvar doc = document.documentElement;\n\tvar left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n\tvar top = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n\t\n\tvar gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n\tvar gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n\n\treturn this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) &&\n\t\t(me.isSource(this.marker.highlight.shape) ||\n\t\t(mxEvent.isAltDown(me.getEvent()) && me.getState() != null) ||\n\t\tthis.marker.highlight.isHighlightAt(clientX, clientY) ||\n\t\t((gridX != clientX || gridY != clientY) && me.getState() == null &&\n\t\tthis.marker.highlight.isHighlightAt(gridX, gridY)));\n};\n\n/**\n * Function: updateCurrentState\n * \n * Updates the current state for a given mouse move event by using\n * the <marker>.\n */\nmxConnectionHandler.prototype.updateCurrentState = function(me, point)\n{\n\tthis.constraintHandler.update(me, this.first == null, false, (this.first == null ||\n\t\tme.isSource(this.marker.highlight.shape)) ? null : point);\n\t\n\tif (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null)\n\t{\n\t\t// Handles special case where grid is large and connection point is at actual point in which\n\t\t// case the outline is not followed as long as we're < gridSize / 2 away from that point\n\t\tif (this.marker.highlight != null && this.marker.highlight.state != null &&\n\t\t\tthis.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)\n\t\t{\n\t\t\t// Direct repaint needed if cell already highlighted\n\t\t\tif (this.marker.highlight.shape.stroke != 'transparent')\n\t\t\t{\n\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n\t\t}\n\n\t\t// Updates validation state\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n\t\t\t\n\t\t\tif (this.error == null)\n\t\t\t{\n\t\t\t\tthis.currentState = this.constraintHandler.currentFocus;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.constraintHandler.reset();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this.graph.isIgnoreTerminalEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.marker.reset();\n\t\t\tthis.currentState = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.process(me);\n\t\t\tthis.currentState = this.marker.getValidState();\n\t\t\t\n\t\t\tif (this.currentState != null && !this.isCellEnabled(this.currentState.cell))\n\t\t\t{\n\t\t\t\tthis.currentState = null;\n\t\t\t}\n\t\t}\n\n\t\tvar outline = this.isOutlineConnectEvent(me);\n\t\t\n\t\tif (this.currentState != null && outline)\n\t\t{\n\t\t\t// Handles special case where mouse is on outline away from actual end point\n\t\t\t// in which case the grid is ignored and mouse point is used instead\n\t\t\tif (me.isSource(this.marker.highlight.shape))\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\t\t\t\n\t\t\tvar constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n\t\t\tthis.constraintHandler.setFocus(me, this.currentState, false);\n\t\t\tthis.constraintHandler.currentConstraint = constraint;\n\t\t\tthis.constraintHandler.currentPoint = point;\n\t\t}\n\n\t\tif (this.outlineConnect)\n\t\t{\n\t\t\tif (this.marker.highlight != null && this.marker.highlight.shape != null)\n\t\t\t{\n\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\n\t\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t\t\t{\n\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t} \n\t\t\t\telse if (this.marker.hasValidState())\n\t\t\t\t{\n\t\t\t\t\t// Handles special case where actual end point of edge and current mouse point\n\t\t\t\t\t// are not equal (due to grid snapping) and there is no hit on shape or highlight\n\t\t\t\t\tif (this.marker.getValidState() != me.getState())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\t\t\tthis.currentState = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellEnabled\n * \n * Returns true if the given cell does not allow new connections to be created.\n */\nmxConnectionHandler.prototype.isCellEnabled = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: convertWaypoint\n * \n * Converts the given point from screen coordinates to model coordinates.\n */\nmxConnectionHandler.prototype.convertWaypoint = function(point)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\t\n\tpoint.x = point.x / scale - tr.x;\n\tpoint.y = point.y / scale - tr.y;\n};\n\n/**\n * Function: snapToPreview\n * \n * Called to snap the given point to the current preview. This snaps to the\n * first point of the preview if alt is not pressed.\n */\nmxConnectionHandler.prototype.snapToPreview = function(me, point)\n{\n\tif (!mxEvent.isAltDown(me.getEvent()) && this.previous != null)\n\t{\n\t\tvar tol = this.graph.gridSize * this.graph.view.scale / 2;\t\n\t\tvar tmp = (this.sourceConstraint != null) ? this.first :\n\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\n\t\tif (Math.abs(tmp.x - me.getGraphX()) < tol)\n\t\t{\n\t\t\tpoint.x = tmp.x;\n\t\t}\n\t\t\n\t\tif (Math.abs(tmp.y - me.getGraphY()) < tol)\n\t\t{\n\t\t\tpoint.y = tmp.y;\n\t\t}\n\t}\t\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the preview edge or by highlighting\n * a possible source or target terminal.\n */\nmxConnectionHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown))\n\t{\n\t\t// Handles special case when handler is disabled during highlight\n\t\tif (!this.isEnabled() && this.currentState != null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\t\t\tthis.currentState = null;\n\t\t}\n\n\t\tvar view = this.graph.getView();\n\t\tvar scale = view.scale;\n\t\tvar tr = view.translate;\n\t\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\tthis.error = null;\n\n\t\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t\t{\n\t\t\tpoint = new mxPoint((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale,\n\t\t\t\t(this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n\t\t}\n\t\t\n\t\tthis.snapToPreview(me, point);\n\t\tthis.currentPoint = point;\n\t\t\n\t\tif ((this.first != null || (this.isEnabled() && this.graph.isEnabled())) &&\n\t\t\t(this.shape != null || this.first == null ||\n\t\t\tMath.abs(me.getGraphX() - this.first.x) > this.graph.tolerance ||\n\t\t\tMath.abs(me.getGraphY() - this.first.y) > this.graph.tolerance))\n\t\t{\n\t\t\tthis.updateCurrentState(me, point);\n\t\t}\n\n\t\tif (this.first != null)\n\t\t{\n\t\t\tvar constraint = null;\n\t\t\tvar current = point;\n\t\t\t\n\t\t\t// Uses the current point from the constraint handler if available\n\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t\t{\n\t\t\t\tconstraint = this.constraintHandler.currentConstraint;\n\t\t\t\tcurrent = this.constraintHandler.currentPoint.clone();\n\t\t\t}\n\t\t\telse if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n\t\t\t\tmxEvent.isShiftDown(me.getEvent()))\n\t\t\t{\n\t\t\t\tif (Math.abs(this.previous.getCenterX() - point.x) <\n\t\t\t\t\tMath.abs(this.previous.getCenterY() - point.y))\n\t\t\t\t{\n\t\t\t\t\tpoint.x = this.previous.getCenterX();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpoint.y = this.previous.getCenterY();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar pt2 = this.first;\n\t\t\t\n\t\t\t// Moves the connect icon with the mouse\n\t\t\tif (this.selectedIcon != null)\n\t\t\t{\n\t\t\t\tvar w = this.selectedIcon.bounds.width;\n\t\t\t\tvar h = this.selectedIcon.bounds.height;\n\t\t\t\t\n\t\t\t\tif (this.currentState != null && this.targetConnectImage)\n\t\t\t\t{\n\t\t\t\t\tvar pos = this.getIconPosition(this.selectedIcon, this.currentState);\n\t\t\t\t\tthis.selectedIcon.bounds.x = pos.x;\n\t\t\t\t\tthis.selectedIcon.bounds.y = pos.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar bounds = new mxRectangle(me.getGraphX() + this.connectIconOffset.x,\n\t\t\t\t\t\tme.getGraphY() + this.connectIconOffset.y, w, h);\n\t\t\t\t\tthis.selectedIcon.bounds = bounds;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.selectedIcon.redraw();\n\t\t\t}\n\n\t\t\t// Uses edge state to compute the terminal points\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.updateEdgeState(current, constraint);\n\t\t\t\tcurrent = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n\t\t\t\tpt2 = this.edgeState.absolutePoints[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.currentState != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.constraintHandler.currentConstraint == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = this.getTargetPerimeterPoint(this.currentState, me);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Computes the source perimeter point\n\t\t\t\tif (this.sourceConstraint == null && this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\t\t\t\tthis.waypoints[0] : current;\n\t\t\t\t\tvar tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n\t\t\t\t\t\n\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt2 = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Makes sure the cell under the mousepointer can be detected\n\t\t\t// by moving the preview shape away from the mouse. This\n\t\t\t// makes sure the preview shape does not prevent the detection\n\t\t\t// of the cell under the mousepointer even for slow gestures.\n\t\t\tif (this.currentState == null && this.movePreviewAway)\n\t\t\t{\n\t\t\t\tvar tmp = pt2; \n\t\t\t\t\n\t\t\t\tif (this.edgeState != null && this.edgeState.absolutePoints.length >= 2)\n\t\t\t\t{\n\t\t\t\t\tvar tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n\t\t\t\t\t\n\t\t\t\t\tif (tmp2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar dx = current.x - tmp.x;\n\t\t\t\tvar dy = current.y - tmp.y;\n\t\t\t\t\n\t\t\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\t\n\t\t\t\tif (len == 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores old point to reuse when creating edge\n\t\t\t\tthis.originalPoint = current.clone();\n\t\t\t\tcurrent.x -= dx * 4 / len;\n\t\t\t\tcurrent.y -= dy * 4 / len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.originalPoint = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Creates the preview shape (lazy)\n\t\t\tif (this.shape == null)\n\t\t\t{\n\t\t\t\tvar dx = Math.abs(me.getGraphX() - this.first.x);\n\t\t\t\tvar dy = Math.abs(me.getGraphY() - this.first.y);\n\n\t\t\t\tif (dx > this.graph.tolerance || dy > this.graph.tolerance)\n\t\t\t\t{\n\t\t\t\t\tthis.shape = this.createShape();\n\n\t\t\t\t\tif (this.edgeState != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Revalidates current connection\n\t\t\t\t\tthis.updateCurrentState(me, point);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Updates the points in the preview edge\n\t\t\tif (this.shape != null)\n\t\t\t{\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tthis.shape.points = this.edgeState.absolutePoints;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pts = [pt2];\n\t\t\t\t\t\n\t\t\t\t\tif (this.waypoints != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpts = pts.concat(this.waypoints);\n\t\t\t\t\t}\n\n\t\t\t\t\tpts.push(current);\n\t\t\t\t\tthis.shape.points = pts;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.drawPreview();\n\t\t\t}\n\t\t\t\n\t\t\t// Makes sure endpoint of edge is visible during connect\n\t\t\tif (this.cursor != null)\n\t\t\t{\n\t\t\t\tthis.graph.container.style.cursor = this.cursor;\n\t\t\t}\n\t\t\t\n\t\t\tmxEvent.consume(me.getEvent());\n\t\t\tme.consume();\n\t\t}\n\t\telse if (!this.isEnabled() || !this.graph.isEnabled())\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != this.currentState && this.edgeState == null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\t\t\t\n\t\t\t// Sets the cursor on the current shape\t\t\t\t\n\t\t\tif (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null)\n\t\t\t{\n\t\t\t\tthis.icons = this.createIcons(this.currentState);\n\n\t\t\t\tif (this.icons == null)\n\t\t\t\t{\n\t\t\t\t\tthis.currentState.setCursor(mxConstants.CURSOR_CONNECT);\n\t\t\t\t\tme.consume();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.previous = this.currentState;\n\t\t}\n\t\telse if (this.previous == this.currentState && this.currentState != null && this.icons == null &&\n\t\t\t!this.graph.isMouseDown)\n\t\t{\n\t\t\t// Makes sure that no cursors are changed\n\t\t\tme.consume();\n\t\t}\n\n\t\tif (!this.graph.isMouseDown && this.currentState != null && this.icons != null)\n\t\t{\n\t\t\tvar hitsIcon = false;\n\t\t\tvar target = me.getSource();\n\t\t\t\n\t\t\tfor (var i = 0; i < this.icons.length && !hitsIcon; i++)\n\t\t\t{\n\t\t\t\thitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;\n\t\t\t}\n\n\t\t\tif (!hitsIcon)\n\t\t\t{\n\t\t\t\tthis.updateIcons(this.currentState, this.icons, me);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.constraintHandler.reset();\n\t}\n};\n\n/**\n * Function: updateEdgeState\n * \n * Updates <edgeState>.\n */\nmxConnectionHandler.prototype.updateEdgeState = function(current, constraint)\n{\n\t// TODO: Use generic method for writing constraint to style\n\tif (this.sourceConstraint != null && this.sourceConstraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;\n\t}\n\n\tif (constraint != null && constraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_X] = constraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_Y] = constraint.point.y;\n\t}\n\telse\n\t{\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_X];\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];\n\t}\n\t\n\tthis.edgeState.absolutePoints = [null, (this.currentState != null) ? null : current];\n\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n\t\n\tif (this.currentState != null)\n\t{\n\t\tif (constraint == null)\n\t\t{\n\t\t\tconstraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n\t\t}\n\t\t\n\t\tthis.edgeState.setAbsoluteTerminalPoint(null, false);\n\t\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n\t}\n\t\n\t// Scales and translates the waypoints to the model\n\tvar realPoints = null;\n\t\n\tif (this.waypoints != null)\n\t{\n\t\trealPoints = [];\n\t\t\n\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t{\n\t\t\tvar pt = this.waypoints[i].clone();\n\t\t\tthis.convertWaypoint(pt);\n\t\t\trealPoints[i] = pt;\n\t\t}\n\t}\n\t\n\tthis.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n\tthis.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n};\n\n/**\n * Function: getTargetPerimeterPoint\n * \n * Returns the perimeter point for the given target state.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the target cell state.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getTargetPerimeterPoint = function(state, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar targetPerimeter = view.getPerimeterFunction(state);\n\t\n\tif (targetPerimeter != null)\n\t{\n\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\tthis.waypoints[this.waypoints.length - 1] :\n\t\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\t\tvar tmp = targetPerimeter(view.getPerimeterBounds(state),\n\t\t\tthis.edgeState, next, false);\n\t\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint(state.getCenterX(), state.getCenterY());\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getSourcePerimeterPoint\n * \n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the target cell state.\n * next - <mxPoint> that represents the next point along the previewed edge.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getSourcePerimeterPoint = function(state, next, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar sourcePerimeter = view.getPerimeterFunction(state);\n\tvar c = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\n\tif (sourcePerimeter != null)\n\t{\n\t\tvar theta = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);\n\t\tvar rad = -theta * (Math.PI / 180);\n\t\t\n\t\tif (theta != 0)\n\t\t{\n\t\t\tnext = mxUtils.getRotatedPoint(new mxPoint(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n\t\t}\n\t\t\n\t\tvar tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n\t\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tif (theta != 0)\n\t\t\t{\n\t\t\t\ttmp = mxUtils.getRotatedPoint(new mxPoint(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n\t\t\t}\n\t\t\t\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = c;\n\t}\n\t\n\treturn result;\n};\n\n\n/**\n * Function: updateIcons\n * \n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n * \n * Parameters:\n * \n * state - <mxCellState> under the mouse.\n * icons - Array of currently displayed icons.\n * me - <mxMouseEvent> that contains the mouse event.\n */\nmxConnectionHandler.prototype.updateIcons = function(state, icons, me)\n{\n\t// empty\n};\n\n/**\n * Function: isStopEvent\n * \n * Returns true if the given mouse up event should stop this handler. The\n * connection will be created if <error> is null. Note that this is only\n * called if <waypointsEnabled> is true. This implemtation returns true\n * if there is a cell state in the given event.\n */\nmxConnectionHandler.prototype.isStopEvent = function(me)\n{\n\treturn me.getState() != null;\n};\n\n/**\n * Function: addWaypoint\n * \n * Adds the waypoint for the given event to <waypoints>.\n */\nmxConnectionHandler.prototype.addWaypointForEvent = function(me)\n{\n\tvar point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n\tvar dx = Math.abs(point.x - this.first.x);\n\tvar dy = Math.abs(point.y - this.first.y);\n\tvar addPoint = this.waypoints != null || (this.mouseDownCounter > 1 &&\n\t\t\t(dx > this.graph.tolerance || dy > this.graph.tolerance));\n\n\tif (addPoint)\n\t{\n\t\tif (this.waypoints == null)\n\t\t{\n\t\t\tthis.waypoints = [];\n\t\t}\n\t\t\n\t\tvar scale = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.graph.snap(me.getGraphX() / scale) * scale,\n\t\t\t\tthis.graph.snap(me.getGraphY() / scale) * scale);\n\t\tthis.waypoints.push(point);\n\t}\n};\n\n/**\n * Function: checkConstraints\n * \n * Returns true if the connection for the given constraints is valid. This\n * implementation returns true if the constraints are not pointing to the\n * same fixed connection point.\n */\nmxConnectionHandler.prototype.checkConstraints = function(c1, c2)\n{\n\treturn (c1 == null || c2 == null || c1.point == null || c2.point == null ||\n\t\t!c1.point.equals(c2.point) || c1.perimeter != c2.perimeter);\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by inserting the new connection.\n */\nmxConnectionHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isConnecting())\n\t{\n\t\tif (this.waypointsEnabled && !this.isStopEvent(me))\n\t\t{\n\t\t\tthis.addWaypointForEvent(me);\n\t\t\tme.consume();\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar c1 = this.sourceConstraint;\n\t\tvar c2 = this.constraintHandler.currentConstraint;\n\n\t\tvar source = (this.previous != null) ? this.previous.cell : null;\n\t\tvar target = null;\n\t\t\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t{\n\t\t\ttarget = this.constraintHandler.currentFocus.cell;\n\t\t}\n\t\t\n\t\tif (target == null && this.currentState != null)\n\t\t{\n\t\t\ttarget = this.currentState.cell;\n\t\t}\n\t\t\n\t\t// Inserts the edge if no validation error exists and if constraints differ\n\t\tif (this.error == null && (source == null || target == null ||\n\t\t\tsource != target || this.checkConstraints(c1, c2)))\n\t\t{\n\t\t\tthis.connect(source, target, me.getEvent(), me.getCell());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Selects the source terminal for self-references\n\t\t\tif (this.previous != null && this.marker.validState != null &&\n\t\t\t\tthis.previous.cell == this.marker.validState.cell)\n\t\t\t{\n\t\t\t\tthis.graph.selectCellForEvent(this.marker.source, me.getEvent());\n\t\t\t}\n\t\t\t\n\t\t\t// Displays the error message if it is not an empty string,\n\t\t\t// for empty error messages, the event is silently dropped\n\t\t\tif (this.error != null && this.error.length > 0)\n\t\t\t{\n\t\t\t\tthis.graph.validationAlert(this.error);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Redraws the connect icons and resets the handler state\n\t\tthis.destroyIcons();\n\t\tme.consume();\n\t}\n\n\tif (this.first != null)\n\t{\n\t\tthis.reset();\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxConnectionHandler.prototype.reset = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\t// Resets the cursor on the container\n\tif (this.cursor != null && this.graph.container != null)\n\t{\n\t\tthis.graph.container.style.cursor = '';\n\t}\n\t\n\tthis.destroyIcons();\n\tthis.marker.reset();\n\tthis.constraintHandler.reset();\n\tthis.originalPoint = null;\n\tthis.currentPoint = null;\n\tthis.edgeState = null;\n\tthis.previous = null;\n\tthis.error = null;\n\tthis.sourceConstraint = null;\n\tthis.mouseDownCounter = 0;\n\tthis.first = null;\n\n\tthis.fireEvent(new mxEventObject(mxEvent.RESET));\n};\n\n/**\n * Function: drawPreview\n * \n * Redraws the preview edge using the color and width returned by\n * <getEdgeColor> and <getEdgeWidth>.\n */\nmxConnectionHandler.prototype.drawPreview = function()\n{\n\tthis.updatePreview(this.error == null);\n\tthis.shape.redraw();\n};\n\n/**\n * Function: getEdgeColor\n * \n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.updatePreview = function(valid)\n{\n\tthis.shape.strokewidth = this.getEdgeWidth(valid);\n\tthis.shape.stroke = this.getEdgeColor(valid);\n};\n\n/**\n * Function: getEdgeColor\n * \n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeColor = function(valid)\n{\n\treturn (valid) ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;\n};\n\t\n/**\n * Function: getEdgeWidth\n * \n * Returns the width used to draw the preview edge. This returns 3 if\n * there is no edge validation error and 1 otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the width for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeWidth = function(valid)\n{\n\treturn (valid) ? 3 : 1;\n};\n\n/**\n * Function: connect\n * \n * Connects the given source and target using a new edge. This\n * implementation uses <createEdge> to create the edge.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.connect = function(source, target, evt, dropTarget)\n{\n\tif (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges)\n\t{\n\t\t// Uses the common parent of source and target or\n\t\t// the default parent to insert the edge\n\t\tvar model = this.graph.getModel();\n\t\tvar terminalInserted = false;\n\t\tvar edge = null;\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt))\n\t\t\t{\n\t\t\t\ttarget = this.createTargetVertex(evt, source);\n\t\t\t\t\n\t\t\t\tif (target != null)\n\t\t\t\t{\n\t\t\t\t\tdropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n\t\t\t\t\tterminalInserted = true;\n\t\t\t\t\t\n\t\t\t\t\t// Disables edges as drop targets if the target cell was created\n\t\t\t\t\t// FIXME: Should not shift if vertex was aligned (same in Java)\n\t\t\t\t\tif (dropTarget == null || !this.graph.getModel().isEdge(dropTarget))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pstate = this.graph.getView().getState(dropTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = model.getGeometry(target);\n\t\t\t\t\t\t\ttmp.x -= pstate.origin.x;\n\t\t\t\t\t\t\ttmp.y -= pstate.origin.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdropTarget = this.graph.getDefaultParent();\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tthis.graph.addCell(target, dropTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parent = this.graph.getDefaultParent();\n\n\t\t\tif (source != null && target != null &&\n\t\t\t\tmodel.getParent(source) == model.getParent(target) &&\n\t\t\t\tmodel.getParent(model.getParent(source)) != model.getRoot())\n\t\t\t{\n\t\t\t\tparent = model.getParent(source);\n\n\t\t\t\tif ((source.geometry != null && source.geometry.relative) &&\n\t\t\t\t\t(target.geometry != null && target.geometry.relative))\n\t\t\t\t{\n\t\t\t\t\tparent = model.getParent(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Uses the value of the preview edge state for inserting\n\t\t\t// the new edge into the graph\n\t\t\tvar value = null;\n\t\t\tvar style = null;\n\t\t\t\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tvalue = this.edgeState.cell.value;\n\t\t\t\tstyle = this.edgeState.cell.style;\n\t\t\t}\n\n\t\t\tedge = this.insertEdge(parent, null, value, source, target, style);\n\t\t\t\n\t\t\tif (edge != null)\n\t\t\t{\n\t\t\t\t// Updates the connection constraints\n\t\t\t\tthis.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n\t\t\t\tthis.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n\t\t\t\t\n\t\t\t\t// Uses geometry of the preview edge state\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tmodel.setGeometry(edge, this.edgeState.cell.geometry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar parent = model.getParent(source);\n\t\t\t\t\n\t\t\t\t// Inserts edge before source\n\t\t\t\tif (this.isInsertBefore(edge, source, target, evt, dropTarget))\n\t\t\t\t{\n\t\t\t\t\tvar index = null;\n\t\t\t\t\tvar tmp = source;\n\n\t\t\t\t\twhile (tmp.parent != null && tmp.geometry != null &&\n\t\t\t\t\t\ttmp.geometry.relative && tmp.parent != edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = this.graph.model.getParent(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp != null && tmp.parent != null && tmp.parent == edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.add(parent, edge, tmp.parent.getIndex(tmp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Makes sure the edge has a non-null, relative geometry\n\t\t\t\tvar geo = model.getGeometry(edge);\n\n\t\t\t\tif (geo == null)\n\t\t\t\t{\n\t\t\t\t\tgeo = new mxGeometry();\n\t\t\t\t\tgeo.relative = true;\n\t\t\t\t\t\n\t\t\t\t\tmodel.setGeometry(edge, geo);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Uses scaled waypoints in geometry\n\t\t\t\tif (this.waypoints != null && this.waypoints.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar tr = this.graph.view.translate;\n\t\t\t\t\tgeo.points = [];\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pt = this.waypoints[i];\n\t\t\t\t\t\tgeo.points.push(new mxPoint(pt.x / s - tr.x, pt.y / s - tr.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar t = this.graph.view.translate;\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar pt = (this.originalPoint != null) ?\n\t\t\t\t\t\t\tnew mxPoint(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) :\n\t\t\t\t\t\tnew mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\t\t\t\tpt.x -= this.graph.panDx / this.graph.view.scale;\n\t\t\t\t\tpt.y -= this.graph.panDy / this.graph.view.scale;\n\t\t\t\t\tgeo.setTerminalPoint(pt, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT, 'cell', edge, 'terminal', target,\n\t\t\t\t\t'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxLog.show();\n\t\t\tmxLog.debug(e.message);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t\t\n\t\tif (this.select)\n\t\t{\n\t\t\tthis.selectCells(edge, (terminalInserted) ? target : null);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectCells\n * \n * Selects the given edge after adding a new connection. The target argument\n * contains the target vertex if one has been inserted.\n */\nmxConnectionHandler.prototype.selectCells = function(edge, target)\n{\n\tthis.graph.setSelectionCell(edge);\n};\n\n/**\n * Function: insertEdge\n * \n * Creates, inserts and returns the new edge for the given parameters. This\n * implementation does only use <createEdge> if <factoryMethod> is defined,\n * otherwise <mxGraph.insertEdge> will be used.\n */\nmxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tif (this.factoryMethod == null)\n\t{\n\t\treturn this.graph.insertEdge(parent, id, value, source, target, style);\n\t}\n\telse\n\t{\n\t\tvar edge = this.createEdge(value, source, target, style);\n\t\tedge = this.graph.addEdge(edge, parent, source, target);\n\t\t\n\t\treturn edge;\n\t}\n};\n\n/**\n * Function: createTargetVertex\n * \n * Hook method for creating new vertices on the fly if no target was\n * under the mouse. This is only called if <createTarget> is true and\n * returns null.\n * \n * Parameters:\n * \n * evt - Mousedown event of the connect gesture.\n * source - <mxCell> that represents the source terminal.\n */\nmxConnectionHandler.prototype.createTargetVertex = function(evt, source)\n{\n\t// Uses the first non-relative source\n\tvar geo = this.graph.getCellGeometry(source);\n\t\n\twhile (geo != null && geo.relative)\n\t{\n\t\tsource = this.graph.getModel().getParent(source);\n\t\tgeo = this.graph.getCellGeometry(source);\n\t}\n\t\n\tvar clone = this.graph.cloneCell(source);\n\tvar geo = this.graph.getModel().getGeometry(clone);\n\t\n\tif (geo != null)\n\t{\n\t\tvar t = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\tgeo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);\n\t\tgeo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);\n\n\t\t// Aligns with source if within certain tolerance\n\t\tvar tol = this.getAlignmentTolerance();\n\t\t\n\t\tif (tol > 0)\n\t\t{\n\t\t\tvar sourceState = this.graph.view.getState(source);\n\t\t\t\n\t\t\tif (sourceState != null)\n\t\t\t{\n\t\t\t\tvar x = sourceState.x / s - t.x;\n\t\t\t\tvar y = sourceState.y / s - t.y;\n\t\t\t\t\n\t\t\t\tif (Math.abs(x - geo.x) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.x = Math.round(x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs(y - geo.y) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.y = Math.round(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn clone;\t\t\n};\n\n/**\n * Function: getAlignmentTolerance\n * \n * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n */\nmxConnectionHandler.prototype.getAlignmentTolerance = function(evt)\n{\n\treturn (this.graph.isGridEnabled()) ? this.graph.gridSize / 2 : this.graph.tolerance;\n};\n\n/**\n * Function: createEdge\n * \n * Creates and returns a new edge using <factoryMethod> if one exists. If\n * no factory method is defined, then a new default edge is returned. The\n * source and target arguments are informal, the actual connection is\n * setup later by the caller of this function.\n * \n * Parameters:\n * \n * value - Value to be used for creating the edge.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * style - Optional style from the preview edge.\n */\nmxConnectionHandler.prototype.createEdge = function(value, source, target, style)\n{\n\tvar edge = null;\n\t\n\t// Creates a new edge using the factoryMethod\n\tif (this.factoryMethod != null)\n\t{\n\t\tedge = this.factoryMethod(source, target, style);\n\t}\n\t\n\tif (edge == null)\n\t{\n\t\tedge = new mxCell(value || '');\n\t\tedge.setEdge(true);\n\t\tedge.setStyle(style);\n\t\t\n\t\tvar geo = new mxGeometry();\n\t\tgeo.relative = true;\n\t\tedge.setGeometry(geo);\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes. This should be\n * called on all instances. It is called automatically for the built-in\n * instance created for each <mxGraph>.\n */\nmxConnectionHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\t\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.destroy();\n\t\tthis.marker = null;\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.destroy();\n\t\tthis.constraintHandler = null;\n\t}\n\n\tif (this.changeHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t\tthis.graph.getView().removeListener(this.changeHandler);\n\t\tthis.changeHandler = null;\n\t}\n\t\n\tif (this.drillHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.drillHandler);\n\t\tthis.graph.getView().removeListener(this.drillHandler);\n\t\tthis.drillHandler = null;\n\t}\n\t\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n};\n\n__mxOutput.mxConnectionHandler = typeof mxConnectionHandler !== 'undefined' ? mxConnectionHandler : undefined;\n"]}