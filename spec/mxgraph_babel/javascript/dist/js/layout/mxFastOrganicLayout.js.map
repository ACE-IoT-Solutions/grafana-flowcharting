{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/layout/mxFastOrganicLayout.js"],"names":["mxFastOrganicLayout","graph","mxGraphLayout","call","prototype","constructor","useInputOrigin","resetEdges","disableEdgeStyle","forceConstant","forceConstantSquared","minDistanceLimit","maxDistanceLimit","minDistanceLimitSquared","initialTemp","temperature","maxIterations","iteration","vertexArray","dispX","dispY","cellLocation","radius","radiusSquared","isMoveable","neighbours","indices","allowedToRun","isVertexIgnored","vertex","apply","arguments","getConnections","length","execute","parent","model","getModel","cells","getChildVertices","i","push","initialBounds","getBoundingBoxFromGeometry","n","id","mxObjectIdentity","get","bounds","getVertexBounds","width","height","x","y","Math","min","beginUpdate","isVertexMovable","edges","getOpposites","j","resetEdge","setEdgeStyleEnabled","index","sqrt","calcRepulsion","calcAttraction","calcPositions","reduceTemperature","minx","miny","snap","round","setVertexLocation","dx","dy","moveCells","endUpdate","deltaLength","newXDisp","newYDisp","k","xDelta","yDelta","deltaLengthSquared","force","displacementX","displacementY","vertexCount","random","deltaLengthWithRadius","__mxOutput","undefined"],"mappings":"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","file":"mxFastOrganicLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxFastOrganicLayout\n * \n * Extends <mxGraphLayout> to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n * \n * Example:\n * \n * (code)\n * var layout = new mxFastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxCompactTreeLayout\n * \n * Constructs a new fast organic layout for the specified graph.\n */\nfunction mxFastOrganicLayout(graph)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxFastOrganicLayout.prototype = new mxGraphLayout();\nmxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;\n\n/**\n * Variable: useInputOrigin\n * \n * Specifies if the top left corner of the input cells should be the origin\n * of the layout result. Default is true.\n */\nmxFastOrganicLayout.prototype.useInputOrigin = true;\n\n/**\n * Variable: resetEdges\n * \n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxFastOrganicLayout.prototype.resetEdges = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxFastOrganicLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: forceConstant\n * \n * The force constant by which the attractive forces are divided and the\n * replusive forces are multiple by the square of. The value equates to the\n * average radius there is of free space around each node. Default is 50.\n */\nmxFastOrganicLayout.prototype.forceConstant = 50;\n\n/**\n * Variable: forceConstantSquared\n * \n * Cache of <forceConstant>^2 for performance.\n */\nmxFastOrganicLayout.prototype.forceConstantSquared = 0;\n\n/**\n * Variable: minDistanceLimit\n * \n * Minimal distance limit. Default is 2. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.minDistanceLimit = 2;\n\n/**\n * Variable: minDistanceLimit\n * \n * Minimal distance limit. Default is 2. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.maxDistanceLimit = 500;\n\n/**\n * Variable: minDistanceLimitSquared\n * \n * Cached version of <minDistanceLimit> squared.\n */\nmxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;\n\n/**\n * Variable: initialTemp\n * \n * Start value of temperature. Default is 200.\n */\nmxFastOrganicLayout.prototype.initialTemp = 200;\n\n/**\n * Variable: temperature\n * \n * Temperature to limit displacement at later stages of layout.\n */\nmxFastOrganicLayout.prototype.temperature = 0;\n\n/**\n * Variable: maxIterations\n * \n * Total number of iterations to run the layout though.\n */\nmxFastOrganicLayout.prototype.maxIterations = 0;\n\n/**\n * Variable: iteration\n * \n * Current iteration count.\n */\nmxFastOrganicLayout.prototype.iteration = 0;\n\n/**\n * Variable: vertexArray\n * \n * An array of all vertices to be laid out.\n */\nmxFastOrganicLayout.prototype.vertexArray;\n\n/**\n * Variable: dispX\n * \n * An array of locally stored X co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispX;\n\n/**\n * Variable: dispY\n * \n * An array of locally stored Y co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispY;\n\n/**\n * Variable: cellLocation\n * \n * An array of locally stored co-ordinate positions for the vertices.\n */\nmxFastOrganicLayout.prototype.cellLocation;\n\n/**\n * Variable: radius\n * \n * The approximate radius of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radius;\n\n/**\n * Variable: radiusSquared\n * \n * The approximate radius squared of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radiusSquared;\n\n/**\n * Variable: isMoveable\n * \n * Array of booleans representing the movable states of the vertices.\n */\nmxFastOrganicLayout.prototype.isMoveable;\n\n/**\n * Variable: neighbours\n * \n * Local copy of cell neighbours.\n */\nmxFastOrganicLayout.prototype.neighbours;\n\n/**\n * Variable: indices\n * \n * Hashtable from cells to local indices.\n */\nmxFastOrganicLayout.prototype.indices;\n\n/**\n * Variable: allowedToRun\n * \n * Boolean flag that specifies if the layout is allowed to run. If this is\n * set to false, then the layout exits in the following iteration.\n */\nmxFastOrganicLayout.prototype.allowedToRun = true;\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxFastOrganicLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>. This operates on all children of the\n * given parent where <isVertexIgnored> returns false.\n */\nmxFastOrganicLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tthis.vertexArray = [];\n\tvar cells = this.graph.getChildVertices(parent);\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (!this.isVertexIgnored(cells[i]))\n\t\t{\n\t\t\tthis.vertexArray.push(cells[i]);\n\t\t}\n\t}\n\t\n\tvar initialBounds = (this.useInputOrigin) ?\n\t\t\tthis.graph.getBoundingBoxFromGeometry(this.vertexArray) :\n\t\t\t\tnull;\n\tvar n = this.vertexArray.length;\n\n\tthis.indices = [];\n\tthis.dispX = [];\n\tthis.dispY = [];\n\tthis.cellLocation = [];\n\tthis.isMoveable = [];\n\tthis.neighbours = [];\n\tthis.radius = [];\n\tthis.radiusSquared = [];\n\n\tif (this.forceConstant < 0.001)\n\t{\n\t\tthis.forceConstant = 0.001;\n\t}\n\n\tthis.forceConstantSquared = this.forceConstant * this.forceConstant;\n\n\t// Create a map of vertices first. This is required for the array of\n\t// arrays called neighbours which holds, for each vertex, a list of\n\t// ints which represents the neighbours cells to that vertex as\n\t// the indices into vertexArray\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tvar vertex = this.vertexArray[i];\n\t\tthis.cellLocation[i] = [];\n\t\t\n\t\t// Set up the mapping from array indices to cells\n\t\tvar id = mxObjectIdentity.get(vertex);\n\t\tthis.indices[id] = i;\n\t\tvar bounds = this.getVertexBounds(vertex);\n\n\t\t// Set the X,Y value of the internal version of the cell to\n\t\t// the center point of the vertex for better positioning\n\t\tvar width = bounds.width;\n\t\tvar height = bounds.height;\n\t\t\n\t\t// Randomize (0, 0) locations\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\t\n\t\tthis.cellLocation[i][0] = x + width / 2.0;\n\t\tthis.cellLocation[i][1] = y + height / 2.0;\n\t\tthis.radius[i] = Math.min(width, height);\n\t\tthis.radiusSquared[i] = this.radius[i] * this.radius[i];\n\t}\n\n\t// Moves cell location back to top-left from center locations used in\n\t// algorithm, resetting the edge points is part of the transaction\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < n; i++)\n\t\t{\n\t\t\tthis.dispX[i] = 0;\n\t\t\tthis.dispY[i] = 0;\n\t\t\tthis.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n\n\t\t\t// Get lists of neighbours to all vertices, translate the cells\n\t\t\t// obtained in indices into vertexArray and store as an array\n\t\t\t// against the orginial cell index\n\t\t\tvar edges = this.graph.getConnections(this.vertexArray[i], parent);\n\t\t\tvar cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n\t\t\tthis.neighbours[i] = [];\n\n\t\t\tfor (var j = 0; j < cells.length; j++)\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.resetEdge(edges[j]);\n\t\t\t\t}\n\n\t\t\t    if (this.disableEdgeStyle)\n\t\t\t    {\n\t\t\t    \tthis.setEdgeStyleEnabled(edges[j], false);\n\t\t\t    }\n\n\t\t\t\t// Looks the cell up in the indices dictionary\n\t\t\t\tvar id = mxObjectIdentity.get(cells[j]);\n\t\t\t\tvar index = this.indices[id];\n\n\t\t\t\t// Check the connected cell in part of the vertex list to be\n\t\t\t\t// acted on by this layout\n\t\t\t\tif (index != null)\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = index;\n\t\t\t\t}\n\n\t\t\t\t// Else if index of the other cell doesn't correspond to\n\t\t\t\t// any cell listed to be acted upon in this layout. Set\n\t\t\t\t// the index to the value of this vertex (a dummy self-loop)\n\t\t\t\t// so the attraction force of the edge is not calculated\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.temperature = this.initialTemp;\n\n\t\t// If max number of iterations has not been set, guess it\n\t\tif (this.maxIterations == 0)\n\t\t{\n\t\t\tthis.maxIterations = 20 * Math.sqrt(n);\n\t\t}\n\t\t\n\t\t// Main iteration loop\n\t\tfor (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++)\n\t\t{\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Calculate repulsive forces on all vertices\n\t\t\tthis.calcRepulsion();\n\n\t\t\t// Calculate attractive forces through edges\n\t\t\tthis.calcAttraction();\n\n\t\t\tthis.calcPositions();\n\t\t\tthis.reduceTemperature();\n\t\t}\n\n\t\tvar minx = null;\n\t\tvar miny = null;\n\t\t\n\t\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t\t{\n\t\t\tvar vertex = this.vertexArray[i];\n\t\t\t\n\t\t\tif (this.isVertexMovable(vertex))\n\t\t\t{\n\t\t\t\tvar bounds = this.getVertexBounds(vertex);\n\t\t\t\t\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tthis.cellLocation[i][0] -= bounds.width / 2.0;\n\t\t\t\t\tthis.cellLocation[i][1] -= bounds.height / 2.0;\n\t\t\t\t\t\n\t\t\t\t\tvar x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n\t\t\t\t\tvar y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n\t\t\t\t\t\n\t\t\t\t\tthis.setVertexLocation(vertex, x, y);\n\t\t\t\t\t\n\t\t\t\t\tif (minx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (miny == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Modifies the cloned geometries in-place. Not needed\n\t\t// to clone the geometries again as we're in the same\n\t\t// undoable change.\n\t\tvar dx = -(minx || 0) + 1;\n\t\tvar dy = -(miny || 0) + 1;\n\t\t\n\t\tif (initialBounds != null)\n\t\t{\n\t\t\tdx += initialBounds.x;\n\t\t\tdy += initialBounds.y;\n\t\t}\n\t\t\n\t\tthis.graph.moveCells(this.vertexArray, dx, dy);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: calcPositions\n * \n * Takes the displacements calculated for each cell and applies them to the\n * local cache of cell positions. Limits the displacement to the current\n * temperature.\n */\nmxFastOrganicLayout.prototype.calcPositions = function()\n{\n\tfor (var index = 0; index < this.vertexArray.length; index++)\n\t{\n\t\tif (this.isMoveable[index])\n\t\t{\n\t\t\t// Get the distance of displacement for this node for this\n\t\t\t// iteration\n\t\t\tvar deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] +\n\t\t\t\tthis.dispY[index] * this.dispY[index]);\n\n\t\t\tif (deltaLength < 0.001)\n\t\t\t{\n\t\t\t\tdeltaLength = 0.001;\n\t\t\t}\n\n\t\t\t// Scale down by the current temperature if less than the\n\t\t\t// displacement distance\n\t\t\tvar newXDisp = this.dispX[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\tvar newYDisp = this.dispY[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\t// reset displacements\n\t\t\tthis.dispX[index] = 0;\n\t\t\tthis.dispY[index] = 0;\n\n\t\t\t// Update the cached cell locations\n\t\t\tthis.cellLocation[index][0] += newXDisp;\n\t\t\tthis.cellLocation[index][1] += newYDisp;\n\t\t}\n\t}\n};\n\n/**\n * Function: calcAttraction\n * \n * Calculates the attractive forces between all laid out nodes linked by\n * edges\n */\nmxFastOrganicLayout.prototype.calcAttraction = function()\n{\n\t// Check the neighbours of each vertex and calculate the attractive\n\t// force of the edge connecting them\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tfor (var k = 0; k < this.neighbours[i].length; k++)\n\t\t{\n\t\t\t// Get the index of the othe cell in the vertex array\n\t\t\tvar j = this.neighbours[i][k];\n\t\t\t\n\t\t\t// Do not proceed self-loops\n\t\t\tif (i != j &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\t// The distance between the nodes\n\t\t\t\tvar deltaLengthSquared = xDelta * xDelta + yDelta\n\t\t\t\t\t\t* yDelta - this.radiusSquared[i] - this.radiusSquared[j];\n\n\t\t\t\tif (deltaLengthSquared < this.minDistanceLimitSquared)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthSquared = this.minDistanceLimitSquared;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar deltaLength = Math.sqrt(deltaLengthSquared);\n\t\t\t\tvar force = (deltaLengthSquared) / this.forceConstant;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\t\t\t\t\n\t\t\t\tthis.dispX[i] -= displacementX;\n\t\t\t\tthis.dispY[i] -= displacementY;\n\t\t\t\t\n\t\t\t\tthis.dispX[j] += displacementX;\n\t\t\t\tthis.dispY[j] += displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRepulsion\n * \n * Calculates the repulsive forces between all laid out nodes\n */\nmxFastOrganicLayout.prototype.calcRepulsion = function()\n{\n\tvar vertexCount = this.vertexArray.length;\n\n\tfor (var i = 0; i < vertexCount; i++)\n\t{\n\t\tfor (var j = i; j < vertexCount; j++)\n\t\t{\n\t\t\t// Exits if the layout is no longer allowed to run\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (j != i &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\tif (xDelta == 0)\n\t\t\t\t{\n\t\t\t\t\txDelta = 0.01 + Math.random();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yDelta == 0)\n\t\t\t\t{\n\t\t\t\t\tyDelta = 0.01 + Math.random();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Distance between nodes\n\t\t\t\tvar deltaLength = Math.sqrt((xDelta * xDelta)\n\t\t\t\t\t\t+ (yDelta * yDelta));\n\t\t\t\tvar deltaLengthWithRadius = deltaLength - this.radius[i]\n\t\t\t\t\t\t- this.radius[j];\n\n\t\t\t\tif (deltaLengthWithRadius > this.maxDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\t// Ignore vertices too far apart\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (deltaLengthWithRadius < this.minDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthWithRadius = this.minDistanceLimit;\n\t\t\t\t}\n\n\t\t\t\tvar force = this.forceConstantSquared / deltaLengthWithRadius;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\t\t\t\t\n\t\t\t\tthis.dispX[i] += displacementX;\n\t\t\t\tthis.dispY[i] += displacementY;\n\n\t\t\t\tthis.dispX[j] -= displacementX;\n\t\t\t\tthis.dispY[j] -= displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: reduceTemperature\n * \n * Reduces the temperature of the layout from an initial setting in a linear\n * fashion to zero.\n */\nmxFastOrganicLayout.prototype.reduceTemperature = function()\n{\n\tthis.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n};\n\n__mxOutput.mxFastOrganicLayout = typeof mxFastOrganicLayout !== 'undefined' ? mxFastOrganicLayout : undefined;\n"]}