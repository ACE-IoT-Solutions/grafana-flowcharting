{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/layout/mxGraphLayout.js"],"names":["mxGraphLayout","graph","WeightedCellSorter","cell","weightedValue","prototype","useBoundingBox","parent","moveCell","x","y","execute","getGraph","getConstraint","key","edge","source","state","view","getState","style","getCellStyle","traverse","vertex","directed","func","visited","mxDictionary","get","put","result","edgeCount","model","getEdgeCount","i","e","getEdgeAt","isSource","getTerminal","next","getVisibleTerminal","isAncestor","child","traverseAncestors","getParent","isVertexMovable","isCellMovable","isVertexIgnored","getModel","isVertex","isCellVisible","isEdgeIgnored","isEdge","setEdgeStyleEnabled","value","setCellStyles","mxConstants","STYLE_NOEDGESTYLE","setOrthogonalEdge","STYLE_ORTHOGONAL","getParentOffset","mxPoint","parentGeo","getGeometry","setEdgePoints","points","geometry","mxGeometry","setRelative","clone","parentOffset","length","setGeometry","setVertexLocation","mxRectangle","width","height","getView","text","boundingBox","scale","box","getVertexBounds","geo","tmp","dx0","Math","max","dy0","dx1","dy1","arrangeGroups","cells","border","topBorder","rightBorder","bottomBorder","leftBorder","updateGroupBounds","nudge","rankIndex","compare","a","b","__mxOutput","undefined"],"mappings":"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","file":"mxGraphLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphLayout\n * \n * Base class for all layout algorithms in mxGraph. Main public functions are\n * <move> for handling a moved cell within a layouted parent, and <execute> for\n * running the layout on a given parent cell.\n *\n * Known Subclasses:\n *\n * <mxCircleLayout>, <mxCompactTreeLayout>, <mxCompositeLayout>,\n * <mxFastOrganicLayout>, <mxParallelEdgeLayout>, <mxPartitionLayout>,\n * <mxStackLayout>\n * \n * Constructor: mxGraphLayout\n *\n * Constructs a new layout using the given layouts.\n *\n * Arguments:\n * \n * graph - Enclosing \n */\nfunction mxGraphLayout(graph)\n{\n\tthis.graph = graph;\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxGraphLayout.prototype.graph = null;\n\n/**\n * Variable: useBoundingBox\n *\n * Boolean indicating if the bounding box of the label should be used if\n * its available. Default is true.\n */\nmxGraphLayout.prototype.useBoundingBox = true;\n\n/**\n * Variable: parent\n *\n * The parent cell of the layout, if any\n */\nmxGraphLayout.prototype.parent = null;\n\n/**\n * Function: moveCell\n * \n * Notified when a cell is being moved in a parent that has automatic\n * layout to update the cell state (eg. index) so that the outcome of the\n * layout will position the vertex as close to the point (x, y) as\n * possible.\n * \n * Empty implementation.\n * \n * Parameters:\n * \n * cell - <mxCell> which has been moved.\n * x - X-coordinate of the new cell location.\n * y - Y-coordinate of the new cell location.\n */\nmxGraphLayout.prototype.moveCell = function(cell, x, y) { };\n\n/**\n * Function: execute\n * \n * Executes the layout algorithm for the children of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be layed out.\n */\nmxGraphLayout.prototype.execute = function(parent) { };\n\n/**\n * Function: getGraph\n * \n * Returns the graph that this layout operates on.\n */\nmxGraphLayout.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: getConstraint\n * \n * Returns the constraint for the given key and cell. The optional edge and\n * source arguments are used to return inbound and outgoing routing-\n * constraints for the given edge and vertex. This implementation always\n * returns the value for the given key in the style of the given cell.\n * \n * Parameters:\n * \n * key - Key of the constraint to be returned.\n * cell - <mxCell> whose constraint should be returned.\n * edge - Optional <mxCell> that represents the connection whose constraint\n * should be returned. Default is null.\n * source - Optional boolean that specifies if the connection is incoming\n * or outgoing. Default is null.\n */\nmxGraphLayout.prototype.getConstraint = function(key, cell, edge, source)\n{\n\tvar state = this.graph.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.graph.getCellStyle(cell);\n\t\n\treturn (style != null) ? style[key] : null;\n};\n\n/**\n * Function: traverse\n * \n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Example:\n * \n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> of cell paths for the visited cells.\n */\nmxGraphLayout.traverse = function(vertex, directed, func, edge, visited)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tvisited = visited || new mxDictionary();\n\t\t\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\t\t\t\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.graph.model.getEdgeCount(vertex);\n\t\t\t\t\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.graph.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.graph.model.getTerminal(e, true) == vertex;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (!directed || isSource)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.graph.view.getVisibleTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isAncestor\n * \n * Returns true if the given parent is an ancestor of the given child.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n * traverseAncestors - boolean whether to \n */\nmxGraphLayout.prototype.isAncestor = function(parent, child, traverseAncestors)\n{\n\tif (!traverseAncestors)\n\t{\n\t\treturn (this.graph.model.getParent(child) == parent);\n\t}\t\n\t\n\tif (child == parent)\n\t{\n\t\treturn false;\n\t}\n\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.graph.model.getParent(child);\n\t}\n\t\n\treturn child == parent;\n};\n\n/**\n * Function: isVertexMovable\n * \n * Returns a boolean indicating if the given <mxCell> is movable or\n * bendable by the algorithm. This implementation returns true if the given\n * cell is movable in the graph.\n * \n * Parameters:\n * \n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraphLayout.prototype.isVertexMovable = function(cell)\n{\n\treturn this.graph.isCellMovable(cell);\n};\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn !this.graph.getModel().isVertex(vertex) ||\n\t\t!this.graph.isCellVisible(vertex);\n};\n\n/**\n * Function: isEdgeIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n * \n * Parameters:\n * \n * cell - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isEdgeIgnored = function(edge)\n{\n\tvar model = this.graph.getModel();\n\t\n\treturn !model.isEdge(edge) ||\n\t\t!this.graph.isCellVisible(edge) ||\n\t\tmodel.getTerminal(edge, true) == null ||\n\t\tmodel.getTerminal(edge, false) == null;\n};\n\n/**\n * Function: setEdgeStyleEnabled\n * \n * Disables or enables the edge style of the given edge.\n */\nmxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE,\n\t\t\t(value) ? '0' : '1', [edge]);\n};\n\n/**\n * Function: setOrthogonalEdge\n * \n * Disables or enables orthogonal end segments of the given edge.\n */\nmxGraphLayout.prototype.setOrthogonalEdge = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL,\n\t\t\t(value) ? '1' : '0', [edge]);\n};\n\n/**\n * Function: getParentOffset\n * \n * Determines the offset of the given parent to the parent\n * of the layout\n */\nmxGraphLayout.prototype.getParentOffset = function(parent)\n{\n\tvar result = new mxPoint();\n\n\tif (parent != null && parent != this.parent)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isAncestor(this.parent, parent))\n\t\t{\n\t\t\tvar parentGeo = model.getGeometry(parent);\n\n\t\t\twhile (parent != this.parent)\n\t\t\t{\n\t\t\t\tresult.x = result.x + parentGeo.x;\n\t\t\t\tresult.y = result.y + parentGeo.y;\n\n\t\t\t\tparent = model.getParent(parent);;\n\t\t\t\tparentGeo = model.getGeometry(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: setEdgePoints\n * \n * Replaces the array of mxPoints in the geometry of the given edge\n * with the given array of mxPoints.\n */\nmxGraphLayout.prototype.setEdgePoints = function(edge, points)\n{\n\tif (edge != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar geometry = model.getGeometry(edge);\n\n\t\tif (geometry == null)\n\t\t{\n\t\t\tgeometry = new mxGeometry();\n\t\t\tgeometry.setRelative(true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t}\n\n\t\tif (this.parent != null && points != null)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tpoints[i].x = points[i].x - parentOffset.x;\n\t\t\t\tpoints[i].y = points[i].y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tgeometry.points = points;\n\t\tmodel.setGeometry(edge, geometry);\n\t}\n};\n\n/**\n * Function: setVertexLocation\n * \n * Sets the new position of the given cell taking into account the size of\n * the bounding box if <useBoundingBox> is true. The change is only carried\n * out if the new location is not equal to the existing location, otherwise\n * the geometry is not replaced with an updated instance. The new or old\n * bounds are returned (including overlapping labels).\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry is to be set.\n * x - Integer that defines the x-coordinate of the new location.\n * y - Integer that defines the y-coordinate of the new location.\n */\nmxGraphLayout.prototype.setVertexLocation = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(cell);\n\tvar result = null;\n\t\n\tif (geometry != null)\n\t{\n\t\tresult = new mxRectangle(x, y, geometry.width, geometry.height);\n\t\t\n\t\t// Checks for oversize labels and shifts the result\n\t\t// TODO: Use mxUtils.getStringSize for label bounds\n\t\tif (this.useBoundingBox)\n\t\t{\n\t\t\tvar state = this.graph.getView().getState(cell);\n\t\t\t\n\t\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tvar scale = this.graph.getView().scale;\n\t\t\t\tvar box = state.text.boundingBox;\n\t\t\t\t\n\t\t\t\tif (state.text.boundingBox.x < state.x)\n\t\t\t\t{\n\t\t\t\t\tx += (state.x - box.x) / scale;\n\t\t\t\t\tresult.width = box.width;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (state.text.boundingBox.y < state.y)\n\t\t\t\t{\n\t\t\t\t\ty += (state.y - box.y) / scale;\n\t\t\t\t\tresult.height = box.height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.parent != null)\n\t\t{\n\t\t\tvar parent = model.getParent(cell);\n\n\t\t\tif (parent != null && parent != this.parent)\n\t\t\t{\n\t\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\t\tx = x - parentOffset.x;\n\t\t\t\ty = y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tif (geometry.x != x || geometry.y != y)\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t\tgeometry.x = x;\n\t\t\tgeometry.y = y;\n\t\t\t\n\t\t\tmodel.setGeometry(cell, geometry);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getVertexBounds\n * \n * Returns an <mxRectangle> that defines the bounds of the given cell or\n * the bounding box if <useBoundingBox> is true.\n */\nmxGraphLayout.prototype.getVertexBounds = function(cell)\n{\n\tvar geo = this.graph.getModel().getGeometry(cell);\n\n\t// Checks for oversize label bounding box and corrects\n\t// the return value accordingly\n\t// TODO: Use mxUtils.getStringSize for label bounds\n\tif (this.useBoundingBox)\n\t{\n\t\tvar state = this.graph.getView().getState(cell);\n\n\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tvar scale = this.graph.getView().scale;\n\t\t\tvar tmp = state.text.boundingBox;\n\n\t\t\tvar dx0 = Math.max(state.x - tmp.x, 0) / scale;\n\t\t\tvar dy0 = Math.max(state.y - tmp.y, 0) / scale;\n\t\t\tvar dx1 = Math.max((tmp.x + tmp.width) - (state.x + state.width), 0) / scale;\n  \t\t\tvar dy1 = Math.max((tmp.y + tmp.height) - (state.y + state.height), 0) / scale;\n\n\t\t\tgeo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);\n\t\t}\n\t}\n\n\tif (this.parent != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tgeo = geo.clone();\n\n\t\tif (parent != null && parent != this.parent)\n\t\t{\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\t\t\tgeo.x = geo.x + parentOffset.x;\n\t\t\tgeo.y = geo.y + parentOffset.y;\n\t\t}\n\t}\n\n\treturn new mxRectangle(geo.x, geo.y, geo.width, geo.height);\n};\n\n/**\n * Function: arrangeGroups\n * \n * Shortcut to <mxGraph.updateGroupBounds> with moveGroup set to true.\n */\nmxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\treturn this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);\n};\n\n/**\n * Class: WeightedCellSorter\n * \n * A utility class used to track cells whilst sorting occurs on the weighted\n * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\n * (x.equals(y))\n *\n * Constructor: WeightedCellSorter\n * \n * Constructs a new weighted cell sorted for the given cell and weight.\n */\nfunction WeightedCellSorter(cell, weightedValue)\n{\n\tthis.cell = cell;\n\tthis.weightedValue = weightedValue;\n};\n\n/**\n * Variable: weightedValue\n * \n * The weighted value of the cell stored.\n */\nWeightedCellSorter.prototype.weightedValue = 0;\n\n/**\n * Variable: nudge\n * \n * Whether or not to flip equal weight values.\n */\nWeightedCellSorter.prototype.nudge = false;\n\n/**\n * Variable: visited\n * \n * Whether or not this cell has been visited in the current assignment.\n */\nWeightedCellSorter.prototype.visited = false;\n\n/**\n * Variable: rankIndex\n * \n * The index this cell is in the model rank.\n */\nWeightedCellSorter.prototype.rankIndex = null;\n\n/**\n * Variable: cell\n * \n * The cell whose median value is being calculated.\n */\nWeightedCellSorter.prototype.cell = null;\n\n/**\n * Function: compare\n * \n * Compares two WeightedCellSorters.\n */\nWeightedCellSorter.prototype.compare = function(a, b)\n{\n\tif (a != null && b != null)\n\t{\n\t\tif (b.weightedValue > a.weightedValue)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse if (b.weightedValue < a.weightedValue)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b.nudge)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n__mxOutput.mxGraphLayout = typeof mxGraphLayout !== 'undefined' ? mxGraphLayout : undefined;\n"]}