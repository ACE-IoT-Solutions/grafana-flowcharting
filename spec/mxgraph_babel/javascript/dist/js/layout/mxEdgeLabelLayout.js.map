{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/layout/mxEdgeLabelLayout.js"],"names":["mxEdgeLabelLayout","graph","radius","mxGraphLayout","call","prototype","constructor","execute","parent","view","model","getModel","edges","vertices","childCount","getChildCount","i","cell","getChildAt","state","getState","isVertexIgnored","push","isEdgeIgnored","placeLabels","v","e","beginUpdate","length","edge","text","boundingBox","j","vertex","avoid","endUpdate","labRect","mxUtils","intersects","dy1","y","height","dy2","dy","Math","abs","dx1","x","width","dx2","dx","g","getGeometry","clone","offset","mxPoint","setGeometry","__mxOutput","undefined"],"mappings":"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","file":"mxEdgeLabelLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEdgeLabelLayout\n * \n * Extends <mxGraphLayout> to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n * \n * Example:\n * \n * (code)\n * var layout = new mxEdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxEdgeLabelLayout\n *\n * Constructs a new edge label layout.\n *\n * Arguments:\n * \n * graph - <mxGraph> that contains the cells.\n */\nfunction mxEdgeLabelLayout(graph, radius)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxEdgeLabelLayout.prototype = new mxGraphLayout();\nmxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n */\nmxEdgeLabelLayout.prototype.execute = function(parent)\n{\n\tvar view = this.graph.view;\n\tvar model = this.graph.getModel();\n\t\n\t// Gets all vertices and edges inside the parent\n\tvar edges = [];\n\tvar vertices = [];\n\tvar childCount = model.getChildCount(parent);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar cell = model.getChildAt(parent, i);\n\t\tvar state = view.getState(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tif (!this.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\tvertices.push(state);\n\t\t\t}\n\t\t\telse if (!this.isEdgeIgnored(cell))\n\t\t\t{\n\t\t\t\tedges.push(state);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.placeLabels(vertices, edges);\n};\n\n/**\n * Function: placeLabels\n * \n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.placeLabels = function(v, e)\n{\n\tvar model = this.graph.getModel();\n\t\n\t// Moves the vertices to build a circle. Makes sure the\n\t// radius is large enough for the vertices to not\n\t// overlap\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < e.length; i++)\n\t\t{\n\t\t\tvar edge = e[i];\n\t\t\t\n\t\t\tif (edge != null && edge.text != null &&\n\t\t\t\tedge.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < v.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar vertex = v[j];\n\t\t\t\t\t\n\t\t\t\t\tif (vertex != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.avoid(edge, vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: avoid\n * \n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.avoid = function(edge, vertex)\n{\n\tvar model = this.graph.getModel();\n\tvar labRect = edge.text.boundingBox;\n\t\n\tif (mxUtils.intersects(labRect, vertex))\n\t{\n\t\tvar dy1 = -labRect.y - labRect.height + vertex.y;\n\t\tvar dy2 = -labRect.y + vertex.y + vertex.height;\n\t\t\n\t\tvar dy = (Math.abs(dy1) < Math.abs(dy2)) ? dy1 : dy2;\n\t\t\n\t\tvar dx1 = -labRect.x - labRect.width + vertex.x;\n\t\tvar dx2 = -labRect.x + vertex.x + vertex.width;\n\t\n\t\tvar dx = (Math.abs(dx1) < Math.abs(dx2)) ? dx1 : dx2;\n\t\t\n\t\tif (Math.abs(dx) < Math.abs(dy))\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t\n\t\tvar g = model.getGeometry(edge.cell);\n\t\t\n\t\tif (g != null)\n\t\t{\n\t\t\tg = g.clone();\n\t\t\t\n\t\t\tif (g.offset != null)\n\t\t\t{\n\t\t\t\tg.offset.x += dx;\n\t\t\t\tg.offset.y += dy;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\t\n\t\t\tmodel.setGeometry(edge.cell, g);\n\t\t}\n\t}\n};\n\n__mxOutput.mxEdgeLabelLayout = typeof mxEdgeLabelLayout !== 'undefined' ? mxEdgeLabelLayout : undefined;\n"]}