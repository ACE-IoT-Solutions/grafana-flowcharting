{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/layout/mxRadialTreeLayout.js"],"names":["mxRadialTreeLayout","graph","mxCompactTreeLayout","call","mxUtils","extend","prototype","angleOffset","rootx","rooty","levelDistance","nodeDistance","autoRadius","sortEdges","rowMinX","rowMaxX","rowMinCenX","rowMaxCenX","rowRadi","row","isVertexIgnored","vertex","mxGraphLayout","apply","arguments","getConnections","length","execute","parent","root","useBoundingBox","edgeRouting","bounds","rootBounds","getVertexBounds","centerX","x","width","centerY","y","height","visited","vertexBounds","clone","add","calcRowDims","node","maxLeftGrad","maxRightGrad","i","leftGrad","rightGrad","Math","max","xLeftLimit","xRightLimit","fullWidth","j","cell","xProportion","theta","PI","child","counter","totalTheta","next","averTheta","nextTheta","min","lastTheta","setVertexLocation","cos","sin","rowNum","rowHasChildren","push","__mxOutput","undefined"],"mappings":"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","file":"mxRadialTreeLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRadialTreeLayout\n * \n * Extends <mxGraphLayout> to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n * \n * Example:\n * \n * (code)\n * var layout = new mxRadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxRadialTreeLayout\n * \n * Constructs a new radial tree layout for the specified graph\n */\nfunction mxRadialTreeLayout(graph)\n{\n\tmxCompactTreeLayout.call(this, graph , false);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);\n\n/**\n * Variable: angleOffset\n *\n * The initial offset to compute the angle position.\n */\nmxRadialTreeLayout.prototype.angleOffset = 0.5;\n\n/**\n * Variable: rootx\n *\n * The X co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rootx = 0;\n\n/**\n * Variable: rooty\n *\n * The Y co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rooty = 0;\n\n/**\n * Variable: levelDistance\n *\n * Holds the levelDistance. Default is 120.\n */\nmxRadialTreeLayout.prototype.levelDistance = 120;\n\n/**\n * Variable: nodeDistance\n *\n * Holds the nodeDistance. Default is 10.\n */\nmxRadialTreeLayout.prototype.nodeDistance = 10;\n\n/**\n * Variable: autoRadius\n * \n * Specifies if the radios should be computed automatically\n */\nmxRadialTreeLayout.prototype.autoRadius = false;\n\n/**\n * Variable: sortEdges\n * \n * Specifies if edges should be sorted according to the order of their\n * opposite terminal cell in the model.\n */\nmxRadialTreeLayout.prototype.sortEdges = false;\n\n/**\n * Variable: rowMinX\n * \n * Array of leftmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMinX = [];\n\n/**\n * Variable: rowMaxX\n * \n * Array of rightmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMaxX = [];\n\n/**\n * Variable: rowMinCenX\n * \n * Array of x coordinate of leftmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMinCenX = [];\n\n/**\n * Variable: rowMaxCenX\n * \n * Array of x coordinate of rightmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMaxCenX = [];\n\n/**\n * Variable: rowRadi\n * \n * Array of y deltas of each row behind root vertex, also the radius in the tree\n */\nmxRadialTreeLayout.prototype.rowRadi = [];\n\n/**\n * Variable: row\n * \n * Array of vertices on each row\n */\nmxRadialTreeLayout.prototype.row = [];\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxRadialTreeLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n * \n * If the parent has any connected edges, then it is used as the root of\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\n * root node within the set of children of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be laid out.\n * root - Optional <mxCell> that will be used as the root of the tree.\n */\nmxRadialTreeLayout.prototype.execute = function(parent, root)\n{\n\tthis.parent = parent;\n\t\n\tthis.useBoundingBox = false;\n\tthis.edgeRouting = false;\n\t//this.horizontal = false;\n\n\tmxCompactTreeLayout.prototype.execute.apply(this, arguments);\n\t\n\tvar bounds = null;\n\tvar rootBounds = this.getVertexBounds(this.root);\n\tthis.centerX = rootBounds.x + rootBounds.width / 2;\n\tthis.centerY = rootBounds.y + rootBounds.height / 2;\n\n\t// Calculate the bounds of the involved vertices directly from the values set in the compact tree\n\tfor (var vertex in this.visited)\n\t{\n\t\tvar vertexBounds = this.getVertexBounds(this.visited[vertex]);\n\t\tbounds = (bounds != null) ? bounds : vertexBounds.clone();\n\t\tbounds.add(vertexBounds);\n\t}\n\t\n\tthis.calcRowDims([this.node], 0);\n\t\n\tvar maxLeftGrad = 0;\n\tvar maxRightGrad = 0;\n\n\t// Find the steepest left and right gradients\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n\t\tvar rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n\t\t\n\t\tmaxLeftGrad = Math.max (maxLeftGrad, leftGrad);\n\t\tmaxRightGrad = Math.max (maxRightGrad, rightGrad);\n\t}\n\t\n\t// Extend out row so they meet the maximum gradient and convert to polar co-ords\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n\t\tvar xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n\t\tvar fullWidth = xRightLimit - xLeftLimit;\n\t\t\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tvar xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / (fullWidth);\n\t\t\tvar theta =  2 * Math.PI * xProportion;\n\t\t\tnode.theta = theta;\n\t\t}\n\t}\n\n\t// Post-process from outside inwards to try to align parents with children\n\tfor (var i = this.row.length - 2; i >= 0; i--)\n\t{\n\t\tvar row = this.row[i];\n\t\t\n\t\tfor (var j = 0; j < row.length; j++)\n\t\t{\n\t\t\tvar node = row[j];\n\t\t\tvar child = node.child;\n\t\t\tvar counter = 0;\n\t\t\tvar totalTheta = 0;\n\t\t\t\n\t\t\twhile (child != null)\n\t\t\t{\n\t\t\t\ttotalTheta += child.theta;\n\t\t\t\tcounter++;\n\t\t\t\tchild = child.next;\n\t\t\t}\n\t\t\t\n\t\t\tif (counter > 0)\n\t\t\t{\n\t\t\t\tvar averTheta = totalTheta / counter;\n\t\t\t\t\n\t\t\t\tif (averTheta > node.theta && j < row.length - 1)\n\t\t\t\t{\n\t\t\t\t\tvar nextTheta = row[j+1].theta;\n\t\t\t\t\tnode.theta = Math.min (averTheta, nextTheta - Math.PI/10);\n\t\t\t\t}\n\t\t\t\telse if (averTheta < node.theta && j > 0 )\n\t\t\t\t{\n\t\t\t\t\tvar lastTheta = row[j-1].theta;\n\t\t\t\t\tnode.theta = Math.max (averTheta, lastTheta + Math.PI/10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Set locations\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tthis.setVertexLocation(node.cell,\n\t\t\t\t\t\t\t\t\tthis.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta),\n\t\t\t\t\t\t\t\t\tthis.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRowDims\n * \n * Recursive function to calculate the dimensions of each row\n * \n * Parameters:\n * \n * row - Array of internal nodes, the children of which are to be processed.\n * rowNum - Integer indicating which row is being processed.\n */\nmxRadialTreeLayout.prototype.calcRowDims = function(row, rowNum)\n{\n\tif (row == null || row.length == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Place root's children proportionally around the first level\n\tthis.rowMinX[rowNum] = this.centerX;\n\tthis.rowMaxX[rowNum] = this.centerX;\n\tthis.rowMinCenX[rowNum] = this.centerX;\n\tthis.rowMaxCenX[rowNum] = this.centerX;\n\tthis.row[rowNum] = [];\n\n\tvar rowHasChildren = false;\n\n\tfor (var i = 0; i < row.length; i++)\n\t{\n\t\tvar child = row[i] != null ? row[i].child : null;\n\n\t\twhile (child != null)\n\t\t{\n\t\t\tvar cell = child.cell;\n\t\t\tvar vertexBounds = this.getVertexBounds(cell);\n\t\t\t\n\t\t\tthis.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n\t\t\tthis.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n\t\t\tthis.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n\t\t\tthis.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n\t\t\tthis.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n\t\n\t\t\tif (child.child != null)\n\t\t\t{\n\t\t\t\trowHasChildren = true;\n\t\t\t}\n\t\t\t\n\t\t\tthis.row[rowNum].push(child);\n\t\t\tchild = child.next;\n\t\t}\n\t}\n\t\n\tif (rowHasChildren)\n\t{\n\t\tthis.calcRowDims(this.row[rowNum], rowNum + 1);\n\t}\n};\n\n__mxOutput.mxRadialTreeLayout = typeof mxRadialTreeLayout !== 'undefined' ? mxRadialTreeLayout : undefined;\n"]}