{"version":3,"sources":["../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/mxHierarchicalLayout.js"],"names":["mxHierarchicalLayout","graph","orientation","deterministic","mxGraphLayout","call","mxConstants","DIRECTION_NORTH","mxHierarchicalEdgeStyle","ORTHOGONAL","POLYLINE","STRAIGHT","CURVE","prototype","constructor","roots","resizeParent","maintainParentLocation","moveParent","parentBorder","intraCellSpacing","interRankCellSpacing","interHierarchySpacing","parallelEdgeSpacing","fineTuning","tightenToSource","disableEdgeStyle","traverseAncestors","model","edgesCache","edgeSourceTermCache","edgesTargetTermCache","edgeStyle","getModel","execute","parent","mxDictionary","Array","parentX","parentY","root","isVertex","geo","getCellGeometry","x","y","rootsCopy","i","length","ancestor","isAncestor","push","beginUpdate","run","isCellCollapsed","updateGroupBounds","clone","setGeometry","endUpdate","findRoots","vertices","best","maxDiff","cell","isCellVisible","conns","getEdges","fanOut","fanIn","k","src","getVisibleTerminal","diff","cachedEdges","get","edges","isCollapsed","childCount","getChildCount","child","getChildAt","isPort","concat","result","source","target","put","edge","terminalCache","term","state","view","getState","terminal","getParent","hierarchyVertices","allVertexSet","filledVertexSet","Object","filterDescendants","filledVertexSetEmpty","key","candidateRoots","vertexSet","traverse","initialX","tmp","mxGraphHierarchyModel","cycleStage","layeringStage","crossingStage","placementStage","mxObjectIdentity","geometry","relative","getEdgesBetween","directed","trg","vertex","allVertices","currentComp","vertexID","edgeIsSource","next","netCount","j","isSource2","otherTerm","comp","splice","mxMinimumCycleRemover","initialRank","fixRanks","mxMedianHybridCrossingReduction","mxCoordinateAssignment","limitX","__mxOutput","undefined"],"mappings":"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","file":"mxHierarchicalLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxHierarchicalLayout\n * \n * A hierarchical layout algorithm.\n * \n * Constructor: mxHierarchicalLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxHierarchicalLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\nvar mxHierarchicalEdgeStyle =\n{\n\tORTHOGONAL: 1,\n\tPOLYLINE: 2,\n\tSTRAIGHT: 3,\n\tCURVE: 4\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxHierarchicalLayout.prototype = new mxGraphLayout();\nmxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;\n\n/**\n * Variable: roots\n * \n * Holds the array of <mxCell> that this layout contains.\n */\nmxHierarchicalLayout.prototype.roots = null;\n\n/**\n * Variable: resizeParent\n * \n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxHierarchicalLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n * \n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxHierarchicalLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n * \n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxHierarchicalLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n * \n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 0.\n */\nmxHierarchicalLayout.prototype.parentBorder = 0;\n\n/**\n * Variable: intraCellSpacing\n * \n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxHierarchicalLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The spacing buffer added between cell on adjacent layers. Default is 50.\n */\nmxHierarchicalLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n * \n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxHierarchicalLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges\n */\nmxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n * \n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxHierarchicalLayout.prototype.fineTuning = true;\n\n/**\n * \n * Variable: tightenToSource\n * \n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxHierarchicalLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxHierarchicalLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n * \n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose \n * terminal vertices have different parents but are in the same \n * ancestry chain\n */\nmxHierarchicalLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n * \n * The internal <mxGraphHierarchyModel> formed of the layout.\n */\nmxHierarchicalLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n * \n * The style to apply between cell layers to edge segments\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n * \n * Returns the internal <mxGraphHierarchyModel> for this layout algorithm.\n */\nmxHierarchicalLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n * \n * Executes the layout for the children of the specified parent.\n * \n * Parameters:\n * \n * parent - Parent <mxCell> that contains the children to be laid out.\n * roots - Optional starting roots of the layout.\n */\nmxHierarchicalLayout.prototype.execute = function(parent, roots)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\tif (roots != null && !(roots instanceof Array))\n\t{\n\t\troots = [roots];\n\t}\n\t\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (roots == null && parent == null)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\t\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\t\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\t\n\tif (roots != null)\n\t{\n\t\tvar rootsCopy = [];\n\n\t\tfor (var i = 0; i < roots.length; i++)\n\t\t{\n\t\t\tvar ancestor = parent != null ? model.isAncestor(parent, roots[i]) : true;\n\t\t\t\n\t\t\tif (ancestor && model.isVertex(roots[i]))\n\t\t\t{\n\t\t\t\trootsCopy.push(roots[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.roots = rootsCopy;\n\t}\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\t\t\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\t\t\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: findRoots\n * \n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxHierarchicalLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\t\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\t\t\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (model.isVertex(cell) && this.graph.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n * \n * Returns the connected edges for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n */\nmxHierarchicalLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\t\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\t\t\n\t\tif ((source == target) ||\n\t\t\t\t((source != target) &&\n\t\t\t\t\t\t((target == cell && (this.parent == null || this.isAncestor(this.parent, source, this.traverseAncestors))) ||\n\t\t\t\t\t\t \t(source == cell && (this.parent == null || this.isAncestor(this.parent, target, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n * \n * Helper function to return visible terminal for edge allowing for ports\n * \n * Parameters:\n * \n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxHierarchicalLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\t\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\t\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\t\t\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n * \n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxHierarchicalLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = [];\n\n\tif (this.roots == null && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\t\tthis.filterDescendants(parent, filledVertexSet);\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (!filledVertexSetEmpty)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(parent, filledVertexSet);\n\t\t\t\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\t\t\t\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfilledVertexSetEmpty = true;\n\t\t\t\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\t// Iterate through the result removing parents who have children in this layout\n\t\n\t// Perform a layout for each seperate hierarchy\n\t// Track initial coordinate x-positioning\n\tvar initialX = 0;\n\n\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t{\n\t\tvar vertexSet = hierarchyVertices[i];\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var key in vertexSet)\n\t\t{\n\t\t\ttmp.push(vertexSet[key]);\n\t\t}\n\t\t\n\t\tthis.model = new mxGraphHierarchyModel(this, tmp, this.roots,\n\t\t\tparent, this.tightenToSource);\n\n\t\tthis.cycleStage(parent);\n\t\tthis.layeringStage();\n\t\t\n\t\tthis.crossingStage(parent);\n\t\tinitialX = this.placementStage(initialX, parent);\n\t}\n};\n\n/**\n * Function: filterDescendants\n * \n * Creates an array of descendant cells\n */\nmxHierarchicalLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxHierarchicalLayout.prototype.isPort = function(cell)\n{\n\tif (cell != null && cell.geometry != null)\n\t{\n\t\treturn cell.geometry.relative;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxHierarchicalLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n */\nmxHierarchicalLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only \n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\t\t\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar edgeIsSource = [];\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tedgeIsSource[i] = (this.getVisibleTerminal(edges[i], true) == vertex);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tif (!directed || edgeIsSource[i])\n\t\t\t\t{\n\t\t\t\t\tvar next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n\t\t\t\t\t\n\t\t\t\t\t// Check whether there are more edges incoming from the target vertex than outgoing\n\t\t\t\t\t// The hierarchical model treats bi-directional parallel edges as being sourced\n\t\t\t\t\t// from the more \"sourced\" terminal. If the directions are equal in number, the direction\n\t\t\t\t\t// is that of the natural direction from the roots of the layout.\n\t\t\t\t\t// The checks below are slightly more verbose than need be for performance reasons\n\t\t\t\t\tvar netCount = 1;\n\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j == i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar isSource2 = edgeIsSource[j];\n\t\t\t\t\t\t\tvar otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (otherTerm == next)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isSource2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (netCount >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentComp = this.traverse(next, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n * \n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxHierarchicalLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxMinimumCycleRemover(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n * \n * Implements first stage of a Sugiyama layout.\n */\nmxHierarchicalLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n * \n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxHierarchicalLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n * \n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxHierarchicalLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\t\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxHierarchicalLayout = typeof mxHierarchicalLayout !== 'undefined' ? mxHierarchicalLayout : undefined;\n"]}