{"version":3,"sources":["../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/mxSwimlaneLayout.js"],"names":["mxSwimlaneLayout","graph","orientation","deterministic","mxGraphLayout","call","mxConstants","DIRECTION_NORTH","prototype","constructor","roots","swimlanes","dummyVertices","dummyVertexWidth","resizeParent","maintainParentLocation","moveParent","parentBorder","intraCellSpacing","interRankCellSpacing","interHierarchySpacing","parallelEdgeSpacing","fineTuning","tightenToSource","disableEdgeStyle","traverseAncestors","model","edgesCache","mxHierarchicalLayout","edgeSourceTermCache","edgesTargetTermCache","edgeStyle","mxHierarchicalEdgeStyle","POLYLINE","getModel","execute","parent","mxDictionary","length","getParent","parentX","parentY","root","isVertex","geo","getCellGeometry","x","y","i","children","getChildCells","vertex","insertVertex","push","beginUpdate","run","isCellCollapsed","updateGroupBounds","clone","setGeometry","removeCells","endUpdate","cells","key","edgeMapper","edge","edges","layoutBounds","getBoundingBoxFromGeometry","childBounds","lane","size","isSwimlane","getStartSize","mxRectangle","bounds","childrenY","height","maxChildrenY","Math","min","maxY","max","newGeo","leftGroupBorder","width","moveCells","findRoots","vertices","best","maxDiff","cell","isCellVisible","isAncestor","conns","getEdges","fanOut","fanIn","k","src","getVisibleTerminal","other","diff","cachedEdges","get","isCollapsed","childCount","getChildCount","child","getChildAt","isPort","concat","result","source","target","isValidAncestor","put","terminalCache","term","state","view","getState","terminal","hierarchyVertices","allVertexSet","filledVertexSet","Object","filterDescendants","filledVertexSetEmpty","laneCounter","candidateRoots","vertexSet","traverse","tmp","mxSwimlaneModel","cycleStage","layeringStage","crossingStage","initialX","placementStage","mxObjectIdentity","geometry","relative","getEdgesBetween","directed","trg","allVertices","currentComp","swimlaneIndex","vertexID","otherVertex","isSource","otherIndex","comp","splice","mxSwimlaneOrdering","initialRank","fixRanks","mxMedianHybridCrossingReduction","mxCoordinateAssignment","limitX","__mxOutput","undefined"],"mappings":"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","file":"mxSwimlaneLayout.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneLayout\n * \n * A hierarchical layout algorithm.\n * \n * Constructor: mxSwimlaneLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxSwimlaneLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxSwimlaneLayout.prototype = new mxGraphLayout();\nmxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;\n\n/**\n * Variable: roots\n * \n * Holds the array of <mxCell> that this layout contains.\n */\nmxSwimlaneLayout.prototype.roots = null;\n\n/**\n * Variable: swimlanes\n * \n * Holds the array of <mxCell> of the ordered swimlanes to lay out\n */\nmxSwimlaneLayout.prototype.swimlanes = null;\n\n/**\n * Variable: dummyVertices\n * \n * Holds an array of <mxCell> of dummy vertices inserted during the layout\n * to pad out empty swimlanes\n */\nmxSwimlaneLayout.prototype.dummyVertices = null;\n\n/**\n * Variable: dummyVertexWidth\n * \n * The cell width of any dummy vertices inserted\n */\nmxSwimlaneLayout.prototype.dummyVertexWidth = 50;\n\n/**\n * Variable: resizeParent\n * \n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxSwimlaneLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n * \n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxSwimlaneLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n * \n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxSwimlaneLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n * \n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 0.\n */\nmxSwimlaneLayout.prototype.parentBorder = 30;\n\n/**\n * Variable: intraCellSpacing\n * \n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxSwimlaneLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The spacing buffer added between cell on adjacent layers. Default is 50.\n */\nmxSwimlaneLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n * \n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxSwimlaneLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges\n */\nmxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n * \n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxSwimlaneLayout.prototype.fineTuning = true;\n\n/**\n * \n * Variable: tightenToSource\n * \n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxSwimlaneLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxSwimlaneLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n * \n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose \n * terminal vertices  * have different parents but are in the same \n * ancestry chain\n */\nmxSwimlaneLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n * \n * The internal <mxSwimlaneModel> formed of the layout.\n */\nmxSwimlaneLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxSwimlaneLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n * \n * The style to apply between cell layers to edge segments\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n * \n * Returns the internal <mxSwimlaneModel> for this layout algorithm.\n */\nmxSwimlaneLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n * \n * Executes the layout for the children of the specified parent.\n * \n * Parameters:\n * \n * parent - Parent <mxCell> that contains the children to be laid out.\n * swimlanes - Ordered array of swimlanes to be laid out\n */\nmxSwimlaneLayout.prototype.execute = function(parent, swimlanes)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (swimlanes == null || swimlanes.length < 1)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\n\tif (parent == null)\n\t{\n\t\tparent = model.getParent(swimlanes[0]);\n\t}\n\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\t\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\n\tthis.swimlanes = swimlanes;\n\tthis.dummyVertices = [];\n\t// Check the swimlanes all have vertices\n\t// in them\n\tfor (var i = 0; i < swimlanes.length; i++)\n\t{\n\t\tvar children = this.graph.getChildCells(swimlanes[i]);\n\t\t\n\t\tif (children == null || children.length == 0)\n\t\t{\n\t\t\tvar vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);\n\t\t\tthis.dummyVertices.push(vertex);\n\t\t}\n\t}\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\t\t\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\t\t\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\n\t\tthis.graph.removeCells(this.dummyVertices);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: updateGroupBounds\n * \n * Updates the bounds of the given array of groups so that it includes\n * all child vertices.\n * \n */\nmxSwimlaneLayout.prototype.updateGroupBounds = function()\n{\n\t// Get all vertices and edge in the layout\n\tvar cells = [];\n\tvar model = this.model;\n\t\n\tfor (var key in model.edgeMapper)\n\t{\n\t\tvar edge = model.edgeMapper[key];\n\t\t\n\t\tfor (var i = 0; i < edge.edges.length; i++)\n\t\t{\n\t\t\tcells.push(edge.edges[i]);\n\t\t}\n\t}\n\t\n\tvar layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);\n\tvar childBounds = [];\n\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\t\t\t\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar bounds = this.graph.getBoundingBoxFromGeometry(children);\n\t\t\tchildBounds[i] = bounds;\n\t\t\tvar childrenY = bounds.y + geo.y - size.height - this.parentBorder;\n\t\t\tvar maxChildrenY = bounds.y + geo.y + bounds.height;\n\n\t\t\tif (layoutBounds == null)\n\t\t\t{\n\t\t\t\tlayoutBounds = new mxRectangle(0, childrenY, 0, maxChildrenY - childrenY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlayoutBounds.y = Math.min(layoutBounds.y, childrenY);\n\t\t\t\tvar maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);\n\t\t\t\tlayoutBounds.height = maxY - layoutBounds.y;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\t\t\t\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar newGeo = geo.clone();\n\t\t\t\n\t\t\tvar leftGroupBorder = (i == 0) ? this.parentBorder : this.interRankCellSpacing/2;\n\t\t\tnewGeo.x += childBounds[i].x - size.width - leftGroupBorder;\n\t\t\tnewGeo.y = newGeo.y + layoutBounds.y - geo.y - this.parentBorder;\n\t\t\t\n\t\t\tnewGeo.width = childBounds[i].width + size.width + this.interRankCellSpacing/2 + leftGroupBorder;\n\t\t\tnewGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;\n\t\t\t\n\t\t\tthis.graph.model.setGeometry(lane, newGeo);\n\t\t\tthis.graph.moveCells(children, -childBounds[i].x + size.width + leftGroupBorder, \n\t\t\t\t\tgeo.y - layoutBounds.y + this.parentBorder);\n\t\t}\n\t}\n};\n\n/**\n * Function: findRoots\n * \n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxSwimlaneLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\t\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\t\t\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (cell != null && model.isVertex(cell) && this.graph.isCellVisible(cell) && model.isAncestor(parent, cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Only count connection within this swimlane\n\t\t\t\t\t\tvar other = this.getVisibleTerminal(conns[k], false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (model.isAncestor(parent, other))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (model.isAncestor(parent, src))\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n * \n * Returns the connected edges for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n */\nmxSwimlaneLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\t\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\t\t\n\t\tif ((source == target) || ((source != target) && ((target == cell && (this.parent == null || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors))) ||\n\t\t\t(source == cell && (this.parent == null ||\n\t\t\t\t\tthis.graph.isValidAncestor(target, this.parent, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n * \n * Helper function to return visible terminal for edge allowing for ports\n * \n * Parameters:\n * \n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxSwimlaneLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\t\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\t\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\t\t\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n * \n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxSwimlaneLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = [];\n\n\tif (this.swimlanes != null && this.swimlanes.length > 0 && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\t\t\n\t\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t\t{\n\t\t\tthis.filterDescendants(this.swimlanes[i], filledVertexSet);\n\t\t}\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Only test for candidates in each swimlane in order\n\t\tvar laneCounter = 0;\n\n\t\twhile (!filledVertexSetEmpty && laneCounter < this.swimlanes.length)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);\n\t\t\t\n\t\t\tif (candidateRoots.length == 0)\n\t\t\t{\n\t\t\t\tlaneCounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet, laneCounter);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfilledVertexSetEmpty = true;\n\t\t\t\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\tvar tmp = [];\n\t\n\tfor (var key in allVertexSet)\n\t{\n\t\ttmp.push(allVertexSet[key]);\n\t}\n\t\n\tthis.model = new mxSwimlaneModel(this, tmp, this.roots,\n\t\tparent, this.tightenToSource);\n\n\tthis.cycleStage(parent);\n\tthis.layeringStage();\n\t\n\tthis.crossingStage(parent);\n\tinitialX = this.placementStage(0, parent);\n};\n\n/**\n * Function: filterDescendants\n * \n * Creates an array of descendant cells\n */\nmxSwimlaneLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && model.getParent(cell) != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxSwimlaneLayout.prototype.isPort = function(cell)\n{\n\tif (cell.geometry.relative)\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxSwimlaneLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n * swimlaneIndex - the laid out order index of the swimlane vertex is contained in\n */\nmxSwimlaneLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet, swimlaneIndex)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only \n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\t\t\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar model = this.graph.model;\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tvar otherVertex = this.getVisibleTerminal(edges[i], true);\n\t\t\t\tvar isSource = otherVertex == vertex;\n\t\t\t\t\n\t\t\t\tif (isSource)\n\t\t\t\t{\n\t\t\t\t\totherVertex = this.getVisibleTerminal(edges[i], false);\n\t\t\t\t}\n\n\t\t\t\tvar otherIndex = 0;\n\t\t\t\t// Get the swimlane index of the other terminal\n\t\t\t\tfor (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++)\n\t\t\t\t{\n\t\t\t\t\tif (model.isAncestor(this.swimlanes[otherIndex], otherVertex))\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (otherIndex >= this.swimlanes.length)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Traverse if the other vertex is within the same swimlane as\n\t\t\t\t// as the current vertex, or if the swimlane index of the other\n\t\t\t\t// vertex is greater than that of this vertex\n\t\t\t\tif ((otherIndex > swimlaneIndex) ||\n\t\t\t\t\t\t((!directed || isSource) && otherIndex == swimlaneIndex))\n\t\t\t\t{\n\t\t\t\t\tcurrentComp = this.traverse(otherVertex, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet, otherIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n * \n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxSwimlaneLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxSwimlaneOrdering(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n * \n * Implements first stage of a Sugiyama layout.\n */\nmxSwimlaneLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n * \n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxSwimlaneLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n * \n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxSwimlaneLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\t\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxSwimlaneLayout = typeof mxSwimlaneLayout !== 'undefined' ? mxSwimlaneLayout : undefined;\n"]}