{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/model/mxGraphHierarchyModel.js"],"names":["mxGraphHierarchyModel","layout","vertices","roots","parent","tightenToSource","graph","getGraph","vertexMapper","mxDictionary","edgeMapper","maxRank","internalVertices","getChildVertices","SOURCESCANSTARTRANK","createInternalCells","i","length","edges","connectsAsSource","j","internalEdge","realEdges","realEdge","targetCell","getVisibleTerminal","internalTargetCell","get","target","connectsAsTarget","mxUtils","indexOf","push","temp","prototype","ranks","dfsCount","mxGraphHierarchyNode","put","conns","getEdges","cell","model","isVertex","isVertexIgnored","undirectedEdges","getEdgesBetween","directedEdges","mxGraphHierarchyEdge","k","edge","resetEdge","disableEdgeStyle","setEdgeStyleEnabled","setOrthogonalEdge","source","initialRank","startNodes","internalNode","internalNodes","getValues","startNodesCopy","slice","layerDeterminingEdges","edgesToBeMarked","allEdgesScanned","minimumLayer","otherNode","Math","min","shift","removedCell","currentMaxLayer","max","fixRanks","rankList","rootsArray","oldRootsArray","visit","node","layer","seen","minRank","parentToCellRankDifference","x","y","setGeneralPurposeVariable","visitor","dfsRoots","trackAncestors","seenNodes","Object","hashCode","extendedDfs","dfs","root","connectingEdge","rootId","id","outgoingEdges","targetNode","ancestors","childHash","hashCodeLength","__mxOutput","undefined"],"mappings":"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","file":"mxGraphHierarchyModel.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxGraphHierarchyModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxGraphHierarchyModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxGraphHierarchyModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxGraphHierarchyModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxGraphHierarchyModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxGraphHierarchyModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxGraphHierarchyModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxGraphHierarchyModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxGraphHierarchyModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxGraphHierarchyModel.prototype.tightenToSource = false;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxGraphHierarchyModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the \n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to \n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\t\t\t\t\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxGraphHierarchyModel.prototype.initialRank = function()\n{\n\tvar startNodes = [];\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\t\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = this.SOURCESCANSTARTRANK;\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\t\t\tthis.maxRank = Math.min(this.maxRank, minimumLayer);\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] -= this.maxRank;\n\t}\n\t\n\t// Tighten the rank 0 nodes as far as possible\n\tfor ( var i = 0; i < startNodesCopy.length; i++)\n\t{\n\t\tvar internalNode = startNodesCopy[i];\n\t\tvar currentMaxLayer = 0;\n\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n\n\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[j];\n\t\t\tvar otherNode = internalEdge.target;\n\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n\t\t\t\t\totherNode.temp[0] + 1);\n\t\t\tcurrentMaxLayer = internalNode.temp[0];\n\t\t}\n\t}\n\t\n\t// Reset the maxRank to that which would be expected for a from-sink\n\t// scan\n\tthis.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxGraphHierarchyModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxGraphHierarchyModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\t\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxGraphHierarchyModel = typeof mxGraphHierarchyModel !== 'undefined' ? mxGraphHierarchyModel : undefined;\n"]}