{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/model/mxSwimlaneModel.js"],"names":["mxSwimlaneModel","layout","vertices","roots","parent","tightenToSource","graph","getGraph","vertexMapper","mxDictionary","edgeMapper","maxRank","internalVertices","getChildVertices","SOURCESCANSTARTRANK","createInternalCells","i","length","edges","connectsAsSource","j","internalEdge","realEdges","realEdge","targetCell","getVisibleTerminal","internalTargetCell","get","target","connectsAsTarget","mxUtils","indexOf","push","temp","prototype","ranks","dfsCount","ranksPerGroup","swimlanes","mxGraphHierarchyNode","put","swimlaneIndex","ii","model","getParent","conns","getEdges","cell","isVertex","isVertexIgnored","undirectedEdges","getEdgesBetween","directedEdges","mxGraphHierarchyEdge","k","edge","resetEdge","disableEdgeStyle","setEdgeStyleEnabled","setOrthogonalEdge","source","initialRank","startNodes","seen","Object","internalNode","maxChainDfs","lowerRank","upperRank","internalNodes","getValues","startNodesCopy","slice","layerDeterminingEdges","edgesToBeMarked","allEdgesScanned","minimumLayer","otherNode","Math","min","shift","removedCell","root","connectingEdge","chainCount","rootId","mxCellPath","create","slIndex","outgoingEdges","targetNode","clone","fixRanks","rankList","rootsArray","oldRootsArray","visit","node","layer","minRank","parentToCellRankDifference","x","y","setGeneralPurposeVariable","visitor","dfsRoots","trackAncestors","seenNodes","hashCode","extendedDfs","dfs","id","ancestors","childHash","hashCodeLength","incomingEdges","__mxOutput","undefined"],"mappings":"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","file":"mxSwimlaneModel.js","sourcesContent":["/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxSwimlaneModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxSwimlaneModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxSwimlaneModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxSwimlaneModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxSwimlaneModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxSwimlaneModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxSwimlaneModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxSwimlaneModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxSwimlaneModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxSwimlaneModel.prototype.tightenToSource = false;\n\n/**\n * Variable: ranksPerGroup\n *\n * An array of the number of ranks within each swimlane\n */\nmxSwimlaneModel.prototype.ranksPerGroup = null;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxSwimlaneModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\tvar swimlanes = layout.swimlanes;\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\t\tinternalVertices[i].swimlaneIndex = -1;\n\n\t\tfor (var ii = 0; ii < swimlanes.length; ii++)\n\t\t{\n\t\t\tif (graph.model.getParent(vertices[i]) == swimlanes[ii])\n\t\t\t{\n\t\t\t\tinternalVertices[i].swimlaneIndex = ii;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the \n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to \n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\t\t\t\t\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxSwimlaneModel.prototype.initialRank = function()\n{\n\tthis.ranksPerGroup = [];\n\t\n\tvar startNodes = [];\n\tvar seen = new Object();\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\t\t\tthis.maxChainDfs(null, internalNode, null, seen, 0);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the lower and upper rank bounds of each swimlane\n\tvar lowerRank = [];\n\tvar upperRank = [];\n\t\n\tfor (var i = this.ranksPerGroup.length - 1; i >= 0; i--)\n\t{\n\t\tif (i == this.ranksPerGroup.length - 1)\n\t\t{\n\t\t\tlowerRank[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlowerRank[i] = upperRank[i+1] + 1;\n\t\t}\n\t\t\n\t\tupperRank[i] = lowerRank[i] + this.ranksPerGroup[i];\n\t}\n\t\n\tthis.maxRank = upperRank[0];\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\t\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\t\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = upperRank[0];\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tif (minimumLayer > upperRank[internalNode.swimlaneIndex])\n\t\t\t{\n\t\t\t\tminimumLayer = upperRank[internalNode.swimlaneIndex];\n\t\t\t}\n\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n//\tfor (var key in this.vertexMapper)\n//\t{\n//\t\tvar internalNode = this.vertexMapper[key];\n//\t\t// Mark the node as not having had a layer assigned\n//\t\tinternalNode.temp[0] -= this.maxRank;\n//\t}\n\t\n\t// Tighten the rank 0 nodes as far as possible\n//\tfor ( var i = 0; i < startNodesCopy.length; i++)\n//\t{\n//\t\tvar internalNode = startNodesCopy[i];\n//\t\tvar currentMaxLayer = 0;\n//\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n//\n//\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n//\t\t{\n//\t\t\tvar internalEdge = layerDeterminingEdges[j];\n//\t\t\tvar otherNode = internalEdge.target;\n//\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n//\t\t\t\t\totherNode.temp[0] + 1);\n//\t\t\tcurrentMaxLayer = internalNode.temp[0];\n//\t\t}\n//\t}\n};\n\n/**\n * Function: maxChainDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of chains within groups.\n * Any cycles should be removed prior to running, but previously seen cells\n * are ignored.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * seen - a set of all nodes seen by this dfs\n * chainCount - the number of edges in the chain of vertices going through\n * the current swimlane\n */\nmxSwimlaneModel.prototype.maxChainDfs = function(parent, root, connectingEdge, seen, chainCount)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = mxCellPath.create(root.cell);\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvar slIndex = root.swimlaneIndex;\n\t\t\t\n\t\t\tif (this.ranksPerGroup[slIndex] == null || this.ranksPerGroup[slIndex] < chainCount)\n\t\t\t{\n\t\t\t\tthis.ranksPerGroup[slIndex] = chainCount;\n\t\t\t}\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), 0);\n\t\t\t\t}\n\t\t\t\telse if (root.swimlaneIndex == targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), chainCount + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxSwimlaneModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxSwimlaneModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\t\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\tvar incomingEdges = root.connectsAsTarget.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\t\t\t\t\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex <= targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < incomingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = incomingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.source;\n\n\t\t\t\t// Only navigate in target->source direction from a lower index \n\t\t\t\t// swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxSwimlaneModel = typeof mxSwimlaneModel !== 'undefined' ? mxSwimlaneModel : undefined;\n"]}