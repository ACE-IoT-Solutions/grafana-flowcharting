{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/model/mxGraphHierarchyEdge.js"],"names":["mxGraphHierarchyEdge","edges","mxGraphAbstractHierarchyCell","apply","arguments","ids","i","length","push","mxObjectIdentity","get","prototype","constructor","source","target","isReversed","invert","layer","temp","getNextLayerConnectedCells","nextLayerConnectedCells","minRank","getPreviousLayerConnectedCells","previousLayerConnectedCells","isEdge","getGeneralPurposeVariable","setGeneralPurposeVariable","value","getCoreCell","__mxOutput","undefined"],"mappings":"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","file":"mxGraphHierarchyEdge.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyEdge\n * \n * An abstraction of a hierarchical edge for the hierarchy layout\n * \n * Constructor: mxGraphHierarchyEdge\n *\n * Constructs a hierarchy edge\n *\n * Arguments:\n * \n * edges - a list of real graph edges this abstraction represents\n */\nfunction mxGraphHierarchyEdge(edges)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.edges = edges;\n\tthis.ids = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.ids.push(mxObjectIdentity.get(edges[i]));\n\t}\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;\n\n/**\n * Variable: edges\n * \n * The graph edge(s) this object represents. Parallel edges are all grouped\n * together within one hierarchy edge.\n */\nmxGraphHierarchyEdge.prototype.edges = null;\n\n/**\n * Variable: ids\n * \n * The object identities of the wrapped cells\n */\nmxGraphHierarchyEdge.prototype.ids = null;\n\n/**\n * Variable: source\n * \n * The node this edge is sourced at\n */\nmxGraphHierarchyEdge.prototype.source = null;\n\n/**\n * Variable: target\n * \n * The node this edge targets\n */\nmxGraphHierarchyEdge.prototype.target = null;\n\n/**\n * Variable: isReversed\n * \n * Whether or not the direction of this edge has been reversed\n * internally to create a DAG for the hierarchical layout\n */\nmxGraphHierarchyEdge.prototype.isReversed = false;\n\n/**\n * Function: invert\n * \n * Inverts the direction of this internal edge(s)\n */\nmxGraphHierarchyEdge.prototype.invert = function(layer)\n{\n\tvar temp = this.source;\n\tthis.source = this.target;\n\tthis.target = temp;\n\tthis.isReversed = !this.isReversed;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\t\t\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.nextLayerConnectedCells[i] = [];\n\t\t\t\n\t\t\tif (i == this.temp.length - 1)\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this.nextLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.previousLayerConnectedCells[i] = [];\n\t\t\t\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: isEdge\n * \n * Returns true.\n */\nmxGraphHierarchyEdge.prototype.isEdge = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n * \n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[layer - this.minRank - 1];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n * \n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[layer - this.minRank - 1] = value;\n};\n\n/**\n * Function: getCoreCell\n * \n * Gets the first core edge associated with this wrapper\n */\nmxGraphHierarchyEdge.prototype.getCoreCell = function()\n{\n\tif (this.edges != null && this.edges.length > 0)\n\t{\n\t\treturn this.edges[0];\n\t}\n\t\n\treturn null;\n};\n\n__mxOutput.mxGraphHierarchyEdge = typeof mxGraphHierarchyEdge !== 'undefined' ? mxGraphHierarchyEdge : undefined;\n"]}