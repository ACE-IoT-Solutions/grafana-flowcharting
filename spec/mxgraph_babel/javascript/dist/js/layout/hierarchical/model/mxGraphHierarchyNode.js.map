{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/model/mxGraphHierarchyNode.js"],"names":["mxGraphHierarchyNode","cell","mxGraphAbstractHierarchyCell","apply","arguments","id","mxObjectIdentity","get","connectsAsTarget","connectsAsSource","prototype","constructor","hashCode","getRankValue","layer","maxRank","getNextLayerConnectedCells","nextLayerConnectedCells","i","length","edge","push","source","getPreviousLayerConnectedCells","previousLayerConnectedCells","minRank","target","isVertex","getGeneralPurposeVariable","temp","setGeneralPurposeVariable","value","isAncestor","otherNode","getCoreCell","__mxOutput","undefined"],"mappings":"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","file":"mxGraphHierarchyNode.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyNode\n * \n * An abstraction of a hierarchical edge for the hierarchy layout\n * \n * Constructor: mxGraphHierarchyNode\n *\n * Constructs an internal node to represent the specified real graph cell\n *\n * Arguments:\n * \n * cell - the real graph cell this node represents\n */\nfunction mxGraphHierarchyNode(cell)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.cell = cell;\n\tthis.id = mxObjectIdentity.get(cell);\n\tthis.connectsAsTarget = [];\n\tthis.connectsAsSource = [];\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;\n\n/**\n * Variable: cell\n * \n * The graph cell this object represents.\n */\nmxGraphHierarchyNode.prototype.cell = null;\n\n/**\n * Variable: id\n * \n * The object identity of the wrapped cell\n */\nmxGraphHierarchyNode.prototype.id = null;\n\n/**\n * Variable: connectsAsTarget\n * \n * Collection of hierarchy edges that have this node as a target\n */\nmxGraphHierarchyNode.prototype.connectsAsTarget = null;\n\n/**\n * Variable: connectsAsSource\n * \n * Collection of hierarchy edges that have this node as a source\n */\nmxGraphHierarchyNode.prototype.connectsAsSource = null;\n\n/**\n * Variable: hashCode\n * \n * Assigns a unique hashcode for each node. Used by the model dfs instead\n * of copying HashSets\n */\nmxGraphHierarchyNode.prototype.hashCode = false;\n\n/**\n * Function: getRankValue\n * \n * Returns the integer value of the layer that this node resides in\n */\nmxGraphHierarchyNode.prototype.getRankValue = function(layer)\n{\n\treturn this.maxRank;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\t\tthis.nextLayerConnectedCells[0] = [];\n\t\t\n\t\tfor (var i = 0; i < this.connectsAsTarget.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsTarget[i];\n\n\t\t\tif (edge.maxRank == -1 || edge.maxRank == layer + 1)\n\t\t\t{\n\t\t\t\t// Either edge is not in any rank or\n\t\t\t\t// no dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.nextLayerConnectedCells[0];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\t\tthis.previousLayerConnectedCells[0] = [];\n\t\t\n\t\tfor (var i = 0; i < this.connectsAsSource.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsSource[i];\n\n\t\t\tif (edge.minRank == -1 || edge.minRank == layer - 1)\n\t\t\t{\n\t\t\t\t// No dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[0];\n};\n\n/**\n * Function: isVertex\n * \n * Returns true.\n */\nmxGraphHierarchyNode.prototype.isVertex = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n * \n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[0];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n * \n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[0] = value;\n};\n\n/**\n * Function: isAncestor\n */\nmxGraphHierarchyNode.prototype.isAncestor = function(otherNode)\n{\n\t// Firstly, the hash code of this node needs to be shorter than the\n\t// other node\n\tif (otherNode != null && this.hashCode != null && otherNode.hashCode != null\n\t\t\t&& this.hashCode.length < otherNode.hashCode.length)\n\t{\n\t\tif (this.hashCode == otherNode.hashCode)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (this.hashCode == null || this.hashCode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Secondly, this hash code must match the start of the other\n\t\t// node's hash code. Arrays.equals cannot be used here since\n\t\t// the arrays are different length, and we do not want to\n\t\t// perform another array copy.\n\t\tfor (var i = 0; i < this.hashCode.length; i++)\n\t\t{\n\t\t\tif (this.hashCode[i] != otherNode.hashCode[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getCoreCell\n * \n * Gets the core vertex associated with this wrapper\n */\nmxGraphHierarchyNode.prototype.getCoreCell = function()\n{\n\treturn this.cell;\n};\n\n__mxOutput.mxGraphHierarchyNode = typeof mxGraphHierarchyNode !== 'undefined' ? mxGraphHierarchyNode : undefined;\n"]}