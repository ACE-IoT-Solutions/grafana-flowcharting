{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/stage/mxCoordinateAssignment.js"],"names":["mxCoordinateAssignment","layout","intraCellSpacing","interRankCellSpacing","orientation","initialX","parallelEdgeSpacing","prototype","mxHierarchicalLayoutStage","constructor","maxIterations","prefHozEdgeSep","prefVertEdgeOff","minEdgeJetty","channelBuffer","jettyPositions","mxConstants","DIRECTION_NORTH","limitX","currentXDelta","widestRank","rankTopY","rankBottomY","widestRankValue","rankWidths","rankY","fineTuning","nextLayerConnectedCache","previousLayerConnectedCache","groupPadding","printStatus","model","getModel","mxLog","show","writeln","j","ranks","length","write","rank","k","cell","getGeneralPurposeVariable","execute","parent","Object","initialCoords","getGraph","minNode","bestXDelta","i","medianPos","setX","setGeneralPurposeVariable","getX","minPath","setCellLocations","nodeList","map","mxDictionary","maxRank","node","nodeWrapper","WeightedCellSorter","rankIndex","visited","push","put","maxTries","count","tolerance","cellWrapper","shift","rankValue","weightedValue","parseInt","nextLayerConnectedCells","getNextLayerConnectedCells","previousLayerConnectedCells","getPreviousLayerConnectedCells","numNextLayerConnected","numPreviousLayerConnected","medianNextLevel","medianXValue","medianPreviousLevel","numConnectedNeighbours","currentPosition","cellMedian","positionChanged","leftCell","leftLimit","width","rankSize","rightCell","rightLimit","connectedCell","connectedCellWrapper","get","downwardSweep","rankMedianPosition","nextRankValue","weightedValues","cellMap","currentCell","id","calculatedWeightedValue","sort","compare","numConnectionsNextLevel","slice","leftBuffer","rightBuffer","collection","totalWeight","isVertex","isEdge","connectedCells","medianValues","a","b","Math","floor","medianPoint","leftMedian","rightMedian","facade","calculateWidestRank","rankCoordinates","graph","maxY","localX","boundsWarning","bounds","getVertexBounds","DIRECTION_SOUTH","height","max","numEdges","edges","warn","y","lastRankMaxCellHeight","maxCellHeight","distanceToNextRank","DIRECTION_WEST","setY","edgeMapper","getValues","minRank","referenceX","edgeStraight","refSegCount","x","upSegCount","downSegCount","upXPositions","downXPositions","currentX","nextX","repositionValid","position","rankArray","Number","MAX_VALUE","vertices","vertexMapper","setVertexLocation","edgeStyle","mxHierarchicalEdgeStyle","ORTHOGONAL","POLYLINE","CURVE","localEdgeProcessing","setEdgePosition","cellIndex","currentCells","currentRank","sortedCells","sorter","connectedEdgeCount","connectedEdgeGroupCount","connectedEdges","innerCell","connections","connectsAsSource","connectsAsTarget","connIndex","source","target","requiredWidth","availableWidth","edgeSpacing","currentYOffset","maxYOffset","numActualEdges","pos","ids","m","offsetX","temp","parallelEdgeCount","jettys","isReversed","layoutReversed","DIRECTION_EAST","realEdge","realSource","getVisibleTerminal","newPoints","reversed","arrayOffset","jetty","modelSource","getTerminal","isPort","getParent","state","view","getState","geometry","mxPoint","loopStart","loopLimit","loopDelta","positionX","topChannelY","bottomChannelY","tmp","modelTarget","realTarget","processReversedEdge","setEdgePoints","realCell","positionY","min","__mxOutput","undefined"],"mappings":"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","file":"mxCoordinateAssignment.js","sourcesContent":["/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxCoordinateAssignment\n * \n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well as heuristics to straighten edges as\n * far as possible.\n * \n * Constructor: mxCoordinateAssignment\n *\n * Creates a coordinate assignment.\n * \n * Arguments:\n * \n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nfunction mxCoordinateAssignment(layout, intraCellSpacing, interRankCellSpacing,\n\torientation, initialX, parallelEdgeSpacing)\n{\n\tthis.layout = layout;\n\tthis.intraCellSpacing = intraCellSpacing;\n\tthis.interRankCellSpacing = interRankCellSpacing;\n\tthis.orientation = orientation;\n\tthis.initialX = initialX;\n\tthis.parallelEdgeSpacing = parallelEdgeSpacing;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage();\nmxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxCoordinateAssignment.prototype.layout = null;\n\n/**\n * Variable: intraCellSpacing\n * \n * The minimum buffer between cells on the same rank. Default is 30.\n */\nmxCoordinateAssignment.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The minimum distance between cells on adjacent ranks. Default is 10.\n */\nmxCoordinateAssignment.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges.\n * Default is 10.\n */\nmxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: maxIterations\n * \n * The number of heuristic iterations to run. Default is 8.\n */\nmxCoordinateAssignment.prototype.maxIterations = 8;\n\n/**\n * Variable: prefHozEdgeSep\n * \n * The preferred horizontal distance between edges exiting a vertex\n */\nmxCoordinateAssignment.prototype.prefHozEdgeSep = 5;\n\n/**\n * Variable: prefVertEdgeOff\n * \n * The preferred vertical offset between edges exiting a vertex\n */\nmxCoordinateAssignment.prototype.prefVertEdgeOff = 2;\n\n/**\n * Variable: minEdgeJetty\n * \n * The minimum distance for an edge jetty from a vertex\n */\nmxCoordinateAssignment.prototype.minEdgeJetty = 12;\n\n/**\n * Variable: channelBuffer\n * \n * The size of the vertical buffer in the center of inter-rank channels\n * where edge control points should not be placed\n */\nmxCoordinateAssignment.prototype.channelBuffer = 4;\n\n/**\n * Variable: jettyPositions\n * \n * Map of internal edges and (x,y) pair of positions of the start and end jetty\n * for that edge where it connects to the source and target vertices.\n * Note this should technically be a WeakHashMap, but since JS does not\n * have an equivalent, housekeeping must be performed before using.\n * i.e. check all edges are still in the model and clear the values.\n * Note that the y co-ord is the offset of the jetty, not the\n * absolute point\n */\nmxCoordinateAssignment.prototype.jettyPositions = null;\n\n/**\n * Variable: orientation\n * \n * The position of the root ( start ) node(s) relative to the rest of the\n * laid out graph. Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: initialX\n * \n * The minimum x position node placement starts at\n */\nmxCoordinateAssignment.prototype.initialX = null;\n\n/**\n * Variable: limitX\n * \n * The maximum x value this positioning lays up to\n */\nmxCoordinateAssignment.prototype.limitX = null;\n\n/**\n * Variable: currentXDelta\n * \n * The sum of x-displacements for the current iteration\n */\nmxCoordinateAssignment.prototype.currentXDelta = null;\n\n/**\n * Variable: widestRank\n * \n * The rank that has the widest x position\n */\nmxCoordinateAssignment.prototype.widestRank = null;\n\n/**\n * Variable: rankTopY\n * \n * Internal cache of top-most values of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankTopY = null;\n\n/**\n * Variable: rankBottomY\n * \n * Internal cache of bottom-most value of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankBottomY = null;\n\n/**\n * Variable: widestRankValue\n * \n * The X-coordinate of the edge of the widest rank\n */\nmxCoordinateAssignment.prototype.widestRankValue = null;\n\n/**\n * Variable: rankWidths\n * \n * The width of all the ranks\n */\nmxCoordinateAssignment.prototype.rankWidths = null;\n\n/**\n * Variable: rankY\n * \n * The Y-coordinate of all the ranks\n */\nmxCoordinateAssignment.prototype.rankY = null;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxCoordinateAssignment.prototype.fineTuning = true;\n\n/**\n * Variable: nextLayerConnectedCache\n * \n * A store of connections to the layer above for speed\n */\nmxCoordinateAssignment.prototype.nextLayerConnectedCache = null;\n\n/**\n * Variable: previousLayerConnectedCache\n * \n * A store of connections to the layer below for speed\n */\nmxCoordinateAssignment.prototype.previousLayerConnectedCache = null;\n\n/**\n * Variable: groupPadding\n * \n * Padding added to resized parents\n */\nmxCoordinateAssignment.prototype.groupPadding = 10;\n\n/**\n * Utility method to display current positions\n */\nmxCoordinateAssignment.prototype.printStatus = function()\n{\n\tvar model = this.layout.getModel();\n\tmxLog.show();\n\n\tmxLog.writeln('======Coord assignment debug=======');\n\n\tfor (var j = 0; j < model.ranks.length; j++)\n\t{\n\t\tmxLog.write('Rank ', j, ' : ' );\n\t\tvar rank = model.ranks[j];\n\t\t\n\t\tfor (var k = 0; k < rank.length; k++)\n\t\t{\n\t\t\tvar cell = rank[k];\n\t\t\t\n\t\t\tmxLog.write(cell.getGeneralPurposeVariable(j), '  ');\n\t\t}\n\t\tmxLog.writeln();\n\t}\n\t\n\tmxLog.writeln('====================================');\n};\n\n/**\n * Function: execute\n * \n * A basic horizontal coordinate assignment algorithm\n */\nmxCoordinateAssignment.prototype.execute = function(parent)\n{\n\tthis.jettyPositions = Object();\n\tvar model = this.layout.getModel();\n\tthis.currentXDelta = 0.0;\n\n\tthis.initialCoords(this.layout.getGraph(), model);\n\t\n//\tthis.printStatus();\n\t\n\tif (this.fineTuning)\n\t{\n\t\tthis.minNode(model);\n\t}\n\t\n\tvar bestXDelta = 100000000.0;\n\t\n\tif (this.fineTuning)\n\t{\n\t\tfor (var i = 0; i < this.maxIterations; i++)\n\t\t{\n//\t\t\tthis.printStatus();\n\t\t\n\t\t\t// Median Heuristic\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tthis.medianPos(i, model);\n\t\t\t\tthis.minNode(model);\n\t\t\t}\n\t\t\t\n\t\t\t// if the total offset is less for the current positioning,\n\t\t\t// there are less heavily angled edges and so the current\n\t\t\t// positioning is used\n\t\t\tif (this.currentXDelta < bestXDelta)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setX(j, cell.getGeneralPurposeVariable(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbestXDelta = this.currentXDelta;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Restore the best positions\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setGeneralPurposeVariable(j, cell.getX(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.minPath(this.layout.getGraph(), model);\n\t\t\t\n\t\t\tthis.currentXDelta = 0;\n\t\t}\n\t}\n\t\n\tthis.setCellLocations(this.layout.getGraph(), model);\n};\n\n/**\n * Function: minNode\n * \n * Performs one median positioning sweep in both directions\n */\nmxCoordinateAssignment.prototype.minNode = function(model)\n{\n\t// Queue all nodes\n\tvar nodeList = [];\n\t\n\t// Need to be able to map from cell to cellWrapper\n\tvar map = new mxDictionary();\n\tvar rank = [];\n\t\n\tfor (var i = 0; i <= model.maxRank; i++)\n\t{\n\t\trank[i] = model.ranks[i];\n\t\t\n\t\tfor (var j = 0; j < rank[i].length; j++)\n\t\t{\n\t\t\t// Use the weight to store the rank and visited to store whether\n\t\t\t// or not the cell is in the list\n\t\t\tvar node = rank[i][j];\n\t\t\tvar nodeWrapper = new WeightedCellSorter(node, i);\n\t\t\tnodeWrapper.rankIndex = j;\n\t\t\tnodeWrapper.visited = true;\n\t\t\tnodeList.push(nodeWrapper);\n\t\t\t\n\t\t\tmap.put(node, nodeWrapper);\n\t\t}\n\t}\n\t\n\t// Set a limit of the maximum number of times we will access the queue\n\t// in case a loop appears\n\tvar maxTries = nodeList.length * 10;\n\tvar count = 0;\n\t\n\t// Don't move cell within this value of their median\n\tvar tolerance = 1;\n\t\n\twhile (nodeList.length > 0 && count <= maxTries)\n\t{\n\t\tvar cellWrapper = nodeList.shift();\n\t\tvar cell = cellWrapper.cell;\n\t\t\n\t\tvar rankValue = cellWrapper.weightedValue;\n\t\tvar rankIndex = parseInt(cellWrapper.rankIndex);\n\t\t\n\t\tvar nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue);\n\t\tvar previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue);\n\t\t\n\t\tvar numNextLayerConnected = nextLayerConnectedCells.length;\n\t\tvar numPreviousLayerConnected = previousLayerConnectedCells.length;\n\n\t\tvar medianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\trankValue + 1);\n\t\tvar medianPreviousLevel = this.medianXValue(previousLayerConnectedCells,\n\t\t\t\trankValue - 1);\n\n\t\tvar numConnectedNeighbours = numNextLayerConnected\n\t\t\t\t+ numPreviousLayerConnected;\n\t\tvar currentPosition = cell.getGeneralPurposeVariable(rankValue);\n\t\tvar cellMedian = currentPosition;\n\t\t\n\t\tif (numConnectedNeighbours > 0)\n\t\t{\n\t\t\tcellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel\n\t\t\t\t\t* numPreviousLayerConnected)\n\t\t\t\t\t/ numConnectedNeighbours;\n\t\t}\n\n\t\t// Flag storing whether or not position has changed\n\t\tvar positionChanged = false;\n\t\t\n\t\tif (cellMedian < currentPosition - tolerance)\n\t\t{\n\t\t\tif (rankIndex == 0)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar leftCell = rank[rankValue][rankIndex - 1];\n\t\t\t\tvar leftLimit = leftCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\t\t\tif (leftLimit < cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (leftLimit < cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t- tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cellMedian > currentPosition + tolerance)\n\t\t{\n\t\t\tvar rankSize = rank[rankValue].length;\n\t\t\t\n\t\t\tif (rankIndex == rankSize - 1)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar rightCell = rank[rankValue][rankIndex + 1];\n\t\t\t\tvar rightLimit = rightCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\t\t\t\t\n\t\t\t\tif (rightLimit > cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (rightLimit > cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t+ tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (positionChanged)\n\t\t{\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < nextLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = nextLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\t\t\t\t\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < previousLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = previousLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcellWrapper.visited = false;\n\t\tcount++;\n\t}\n};\n\n/**\n * Function: medianPos\n * \n * Performs one median positioning sweep in one direction\n * \n * Parameters:\n * \n * i - the iteration of the whole process\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.medianPos = function(i, model)\n{\n\t// Reverse sweep direction each time through this method\n\tvar downwardSweep = (i % 2 == 0);\n\t\n\tif (downwardSweep)\n\t{\n\t\tfor (var j = model.maxRank; j > 0; j--)\n\t\t{\n\t\t\tthis.rankMedianPosition(j - 1, model, j);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (var j = 0; j < model.maxRank - 1; j++)\n\t\t{\n\t\t\tthis.rankMedianPosition(j + 1, model, j);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankMedianPosition\n * \n * Performs median minimisation over one rank.\n * \n * Parameters:\n * \n * rankValue - the layer number of this rank\n * model - an internal model of the hierarchical layout\n * nextRankValue - the layer number whose connected cels are to be laid out\n * relative to\n */\nmxCoordinateAssignment.prototype.rankMedianPosition = function(rankValue, model, nextRankValue)\n{\n\tvar rank = model.ranks[rankValue];\n\n\t// Form an array of the order in which the cell are to be processed\n\t// , the order is given by the weighted sum of the in or out edges,\n\t// depending on whether we're traveling up or down the hierarchy.\n\tvar weightedValues = [];\n\tvar cellMap = new Object();\n\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar currentCell = rank[i];\n\t\tweightedValues[i] = new WeightedCellSorter();\n\t\tweightedValues[i].cell = currentCell;\n\t\tweightedValues[i].rankIndex = i;\n\t\tcellMap[currentCell.id] = weightedValues[i];\n\t\tvar nextLayerConnectedCells = null;\n\t\t\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getPreviousLayerConnectedCells(rankValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getNextLayerConnectedCells(rankValue);\n\t\t}\n\n\t\t// Calculate the weighing based on this node type and those this\n\t\t// node is connected to on the next layer\n\t\tweightedValues[i].weightedValue = this.calculatedWeightedValue(\n\t\t\t\tcurrentCell, nextLayerConnectedCells);\n\t}\n\n\tweightedValues.sort(WeightedCellSorter.prototype.compare);\n\n\t// Set the new position of each node within the rank using\n\t// its temp variable\n\t\n\tfor (var i = 0; i < weightedValues.length; i++)\n\t{\n\t\tvar numConnectionsNextLevel = 0;\n\t\tvar cell = weightedValues[i].cell;\n\t\tvar nextLayerConnectedCells = null;\n\t\tvar medianNextLevel = 0;\n\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getPreviousLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getNextLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\n\t\tif (nextLayerConnectedCells != null)\n\t\t{\n\t\t\tnumConnectionsNextLevel = nextLayerConnectedCells.length;\n\t\t\t\n\t\t\tif (numConnectionsNextLevel > 0)\n\t\t\t{\n\t\t\t\tmedianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\t\t\tnextRankValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// For case of no connections on the next level set the\n\t\t\t\t// median to be the current position and try to be\n\t\t\t\t// positioned there\n\t\t\t\tmedianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n\t\t\t}\n\t\t}\n\n\t\tvar leftBuffer = 0.0;\n\t\tvar leftLimit = -100000000.0;\n\t\t\n\t\tfor (var j = weightedValues[i].rankIndex - 1; j >= 0;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\t\t\t\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar leftCell = weightedValue.cell;\n\t\t\t\t\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\tleftLimit = leftCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t+ leftCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t+ this.intraCellSpacing\n\t\t\t\t\t\t\t+ leftBuffer + cell.width / 2.0;\n\t\t\t\t\tj = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftBuffer += leftCell.width + this.intraCellSpacing;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar rightBuffer = 0.0;\n\t\tvar rightLimit = 100000000.0;\n\t\t\n\t\tfor (var j = weightedValues[i].rankIndex + 1; j < weightedValues.length;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\t\t\t\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar rightCell = weightedValue.cell;\n\t\t\t\t\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\trightLimit = rightCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t- rightCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t- this.intraCellSpacing\n\t\t\t\t\t\t\t- rightBuffer - cell.width / 2.0;\n\t\t\t\t\tj = weightedValues.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trightBuffer += rightCell.width + this.intraCellSpacing;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit)\n\t\t{\n\t\t\tcell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n\t\t}\n\t\telse if (medianNextLevel < leftLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\tthis.currentXDelta += leftLimit - medianNextLevel;\n\t\t}\n\t\telse if (medianNextLevel > rightLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\tthis.currentXDelta += medianNextLevel - rightLimit;\n\t\t}\n\n\t\tweightedValues[i].visited = true;\n\t}\n};\n\n/**\n * Function: calculatedWeightedValue\n * \n * Calculates the priority the specified cell has based on the type of its\n * cell and the cells it is connected to on the next layer\n * \n * Parameters:\n * \n * currentCell - the cell whose weight is to be calculated\n * collection - the cells the specified cell is connected to\n */\nmxCoordinateAssignment.prototype.calculatedWeightedValue = function(currentCell, collection)\n{\n\tvar totalWeight = 0;\n\t\n\tfor (var i = 0; i < collection.length; i++)\n\t{\n\t\tvar cell = collection[i];\n\n\t\tif (currentCell.isVertex() && cell.isVertex())\n\t\t{\n\t\t\ttotalWeight++;\n\t\t}\n\t\telse if (currentCell.isEdge() && cell.isEdge())\n\t\t{\n\t\t\ttotalWeight += 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalWeight += 2;\n\t\t}\n\t}\n\n\treturn totalWeight;\n};\n\n/**\n * Function: medianXValue\n * \n * Calculates the median position of the connected cell on the specified\n * rank\n * \n * Parameters:\n * \n * connectedCells - the cells the candidate connects to on this level\n * rankValue - the layer number of this rank\n */\nmxCoordinateAssignment.prototype.medianXValue = function(connectedCells, rankValue)\n{\n\tif (connectedCells.length == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tvar medianValues = [];\n\n\tfor (var i = 0; i < connectedCells.length; i++)\n\t{\n\t\tmedianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n\t}\n\n\tmedianValues.sort(function(a,b){return a - b;});\n\t\n\tif (connectedCells.length % 2 == 1)\n\t{\n\t\t// For odd numbers of adjacent vertices return the median\n\t\treturn medianValues[Math.floor(connectedCells.length / 2)];\n\t}\n\telse\n\t{\n\t\tvar medianPoint = connectedCells.length / 2;\n\t\tvar leftMedian = medianValues[medianPoint - 1];\n\t\tvar rightMedian = medianValues[medianPoint];\n\n\t\treturn ((leftMedian + rightMedian) / 2);\n\t}\n};\n\n/**\n * Function: initialCoords\n * \n * Sets up the layout in an initial positioning. The ranks are all centered\n * as much as possible along the middle vertex in each rank. The other cells\n * are then placed as close as possible on either side.\n * \n * Parameters:\n * \n * facade - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.initialCoords = function(facade, model)\n{\n\tthis.calculateWidestRank(facade, model);\n\n\t// Sweep up and down from the widest rank\n\tfor (var i = this.widestRank; i >= 0; i--)\n\t{\n\t\tif (i < model.maxRank)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n\n\tfor (var i = this.widestRank+1; i <= model.maxRank; i++)\n\t{\n\t\tif (i > 0)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankCoordinates\n * \n * Sets up the layout in an initial positioning. All the first cells in each\n * rank are moved to the left and the rest of the rank inserted as close\n * together as their size and buffering permits. This method works on just\n * the specified rank.\n * \n * Parameters:\n * \n * rankValue - the current rank being processed\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.rankCoordinates = function(rankValue, graph, model)\n{\n\tvar rank = model.ranks[rankValue];\n\tvar maxY = 0.0;\n\tvar localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue])\n\t\t\t/ 2;\n\n\t// Store whether or not any of the cells' bounds were unavailable so\n\t// to only issue the warning once for all cells\n\tvar boundsWarning = false;\n\t\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar node = rank[i];\n\t\t\n\t\tif (node.isVertex())\n\t\t{\n\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tboundsWarning = true;\n\t\t\t}\n\n\t\t\tmaxY = Math.max(maxY, node.height);\n\t\t}\n\t\telse if (node.isEdge())\n\t\t{\n\t\t\t// The width is the number of additional parallel edges\n\t\t\t// time the parallel edge spacing\n\t\t\tvar numEdges = 1;\n\n\t\t\tif (node.edges != null)\n\t\t\t{\n\t\t\t\tnumEdges = node.edges.length;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t}\n\n\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t}\n\n\t\t// Set the initial x-value as being the best result so far\n\t\tlocalX += node.width / 2.0;\n\t\tnode.setX(rankValue, localX);\n\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\tlocalX += node.width / 2.0;\n\t\tlocalX += this.intraCellSpacing;\n\t}\n\n\tif (boundsWarning == true)\n\t{\n\t\tmxLog.warn('At least one cell has no bounds');\n\t}\n};\n\n/**\n * Function: calculateWidestRank\n * \n * Calculates the width rank in the hierarchy. Also set the y value of each\n * rank whilst performing the calculation\n * \n * Parameters:\n * \n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.calculateWidestRank = function(graph, model)\n{\n\t// Starting y co-ordinate\n\tvar y = -this.interRankCellSpacing;\n\t\n\t// Track the widest cell on the last rank since the y\n\t// difference depends on it\n\tvar lastRankMaxCellHeight = 0.0;\n\tthis.rankWidths = [];\n\tthis.rankY = [];\n\n\tfor (var rankValue = model.maxRank; rankValue >= 0; rankValue--)\n\t{\n\t\t// Keep track of the widest cell on this rank\n\t\tvar maxCellHeight = 0.0;\n\t\tvar rank = model.ranks[rankValue];\n\t\tvar localX = this.initialX;\n\n\t\t// Store whether or not any of the cells' bounds were unavailable so\n\t\t// to only issue the warning once for all cells\n\t\tvar boundsWarning = false;\n\t\t\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar node = rank[i];\n\n\t\t\tif (node.isVertex())\n\t\t\t{\n\t\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tboundsWarning = true;\n\t\t\t\t}\n\n\t\t\t\tmaxCellHeight = Math.max(maxCellHeight, node.height);\n\t\t\t}\n\t\t\telse if (node.isEdge())\n\t\t\t{\n\t\t\t\t// The width is the number of additional parallel edges\n\t\t\t\t// time the parallel edge spacing\n\t\t\t\tvar numEdges = 1;\n\n\t\t\t\tif (node.edges != null)\n\t\t\t\t{\n\t\t\t\t\tnumEdges = node.edges.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t\t}\n\n\t\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t\t}\n\n\t\t\t// Set the initial x-value as being the best result so far\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tnode.setX(rankValue, localX);\n\t\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tlocalX += this.intraCellSpacing;\n\n\t\t\tif (localX > this.widestRankValue)\n\t\t\t{\n\t\t\t\tthis.widestRankValue = localX;\n\t\t\t\tthis.widestRank = rankValue;\n\t\t\t}\n\n\t\t\tthis.rankWidths[rankValue] = localX;\n\t\t}\n\n\t\tif (boundsWarning == true)\n\t\t{\n\t\t\tmxLog.warn('At least one cell has no bounds');\n\t\t}\n\n\t\tthis.rankY[rankValue] = y;\n\t\tvar distanceToNextRank = maxCellHeight / 2.0\n\t\t\t\t+ lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n\t\tlastRankMaxCellHeight = maxCellHeight;\n\n\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.orientation == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\ty += distanceToNextRank;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty -= distanceToNextRank;\n\t\t}\n\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar cell = rank[i];\n\t\t\tcell.setY(rankValue, y);\n\t\t}\n\t}\n};\n\n/**\n * Function: minPath\n * \n * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n * processing step has completed.\n * \n * Parameters:\n *\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.minPath = function(graph, model)\n{\n\t// Work down and up each edge with at least 2 control points\n\t// trying to straighten each one out. If the same number of\n\t// straight segments are formed in both directions, the \n\t// preferred direction used is the one where the final\n\t// control points have the least offset from the connectable \n\t// region of the terminating vertices\n\tvar edges = model.edgeMapper.getValues();\n\t\n\tfor (var j = 0; j < edges.length; j++)\n\t{\n\t\tvar cell = edges[j];\n\t\t\n\t\tif (cell.maxRank - cell.minRank - 1 < 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At least two virtual nodes in the edge\n\t\t// Check first whether the edge is already straight\n\t\tvar referenceX = cell\n\t\t\t\t.getGeneralPurposeVariable(cell.minRank + 1);\n\t\tvar edgeStraight = true;\n\t\tvar refSegCount = 0;\n\t\t\n\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t{\n\t\t\tvar x = cell.getGeneralPurposeVariable(i);\n\n\t\t\tif (referenceX != x)\n\t\t\t{\n\t\t\t\tedgeStraight = false;\n\t\t\t\treferenceX = x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trefSegCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (!edgeStraight)\n\t\t{\n\t\t\tvar upSegCount = 0;\n\t\t\tvar downSegCount = 0;\n\t\t\tvar upXPositions = [];\n\t\t\tvar downXPositions = [];\n\n\t\t\tvar currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n\n\t\t\tfor (var i = cell.minRank + 1; i < cell.maxRank - 1; i++)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment up with the current control point.\n\t\t\t\tvar nextX = cell.getX(i + 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i + 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = nextX;\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tcurrentX = cell.getX(i);\n\n\t\t\tfor (var i = cell.maxRank - 1; i > cell.minRank + 1; i--)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment down with the current control point.\n\t\t\t\tvar nextX = cell.getX(i - 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i - 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = cell.getX(i-1);\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (downSegCount > refSegCount || upSegCount > refSegCount)\n\t\t\t{\n\t\t\t\tif (downSegCount >= upSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply down calculation values\n\t\t\t\t\tfor (var i = cell.maxRank - 2; i > cell.minRank; i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, downXPositions[i - cell.minRank - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (upSegCount > downSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply up calculation values\n\t\t\t\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, upXPositions[i - cell.minRank - 2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Neither direction provided a favourable result\n\t\t\t\t\t// But both calculations are better than the\n\t\t\t\t\t// existing solution, so apply the one with minimal\n\t\t\t\t\t// offset to attached vertices at either end.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: repositionValid\n * \n * Determines whether or not a node may be moved to the specified x \n * position on the specified rank\n * \n * Parameters:\n *\n * model - the layout model\n * cell - the cell being analysed\n * rank - the layer of the cell\n * position - the x position being sought\n */\nmxCoordinateAssignment.prototype.repositionValid = function(model, cell, rank, position)\n{\n\tvar rankArray = model.ranks[rank];\n\tvar rankIndex = -1;\n\n\tfor (var i = 0; i < rankArray.length; i++)\n\t{\n\t\tif (cell == rankArray[i])\n\t\t{\n\t\t\trankIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rankIndex < 0)\n\t{\n\t\treturn false;\n\t}\n\n\tvar currentX = cell.getGeneralPurposeVariable(rank);\n\n\tif (position < currentX)\n\t{\n\t\t// Trying to move node to the left.\n\t\tif (rankIndex == 0)\n\t\t{\n\t\t\t// Left-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar leftCell = rankArray[rankIndex - 1];\n\t\tvar leftLimit = leftCell.getGeneralPurposeVariable(rank);\n\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\tif (leftLimit <= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse if (position > currentX)\n\t{\n\t\t// Trying to move node to the right.\n\t\tif (rankIndex == rankArray.length - 1)\n\t\t{\n\t\t\t// Right-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar rightCell = rankArray[rankIndex + 1];\n\t\tvar rightLimit = rightCell.getGeneralPurposeVariable(rank);\n\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\n\t\tif (rightLimit >= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * Function: setCellLocations\n * \n * Sets the cell locations in the facade to those stored after this layout\n * processing step has completed.\n * \n * Parameters:\n *\n * graph - the input graph\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.setCellLocations = function(graph, model)\n{\n\tthis.rankTopY = [];\n\tthis.rankBottomY = [];\n\n\tfor (var i = 0; i < model.ranks.length; i++)\n\t{\n\t\tthis.rankTopY[i] = Number.MAX_VALUE;\n\t\tthis.rankBottomY[i] = -Number.MAX_VALUE;\n\t}\n\t\n\tvar vertices = model.vertexMapper.getValues();\n\n\t// Process vertices all first, since they define the lower and \n\t// limits of each rank. Between these limits lie the channels\n\t// where the edges can be routed across the graph\n\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tthis.setVertexLocation(vertices[i]);\n\t}\n\t\n\t// Post process edge styles. Needs the vertex locations set for initial\n\t// values of the top and bottoms of each rank\n\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.ORTHOGONAL\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.POLYLINE\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t{\n\t\tthis.localEdgeProcessing(model);\n\t}\n\n\tvar edges = model.edgeMapper.getValues();\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.setEdgePosition(edges[i]);\n\t}\n};\n\n/**\n * Function: localEdgeProcessing\n * \n * Separates the x position of edges as they connect to vertices\n * \n * Parameters:\n *\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.localEdgeProcessing = function(model)\n{\n\t// Iterate through each vertex, look at the edges connected in\n\t// both directions.\n\tfor (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++)\n\t{\n\t\tvar rank = model.ranks[rankIndex];\n\n\t\tfor (var cellIndex = 0; cellIndex < rank.length; cellIndex++)\n\t\t{\n\t\t\tvar cell = rank[cellIndex];\n\n\t\t\tif (cell.isVertex())\n\t\t\t{\n\t\t\t\tvar currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n\n\t\t\t\tvar currentRank = rankIndex - 1;\n\n\t\t\t\t// Two loops, last connected cells, and next\n\t\t\t\tfor (var k = 0; k < 2; k++)\n\t\t\t\t{\n\t\t\t\t\tif (currentRank > -1\n\t\t\t\t\t\t\t&& currentRank < model.ranks.length\n\t\t\t\t\t\t\t&& currentCells != null\n\t\t\t\t\t\t\t&& currentCells.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sortedCells = [];\n\n\t\t\t\t\t\tfor (var j = 0; j < currentCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar sorter = new WeightedCellSorter(\n\t\t\t\t\t\t\t\t\tcurrentCells[j], currentCells[j].getX(currentRank));\n\t\t\t\t\t\t\tsortedCells.push(sorter);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsortedCells.sort(WeightedCellSorter.prototype.compare);\n\n\t\t\t\t\t\tvar leftLimit = cell.x[0] - cell.width / 2;\n\t\t\t\t\t\tvar rightLimit = leftLimit + cell.width;\n\n\t\t\t\t\t\t// Connected edge count starts at 1 to allow for buffer\n\t\t\t\t\t\t// with edge of vertex\n\t\t\t\t\t\tvar connectedEdgeCount = 0;\n\t\t\t\t\t\tvar connectedEdgeGroupCount = 0;\n\t\t\t\t\t\tvar connectedEdges = [];\n\t\t\t\t\t\t// Calculate width requirements for all connected edges\n\t\t\t\t\t\tfor (var j = 0; j < sortedCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar innerCell = sortedCells[j].cell;\n\t\t\t\t\t\t\tvar connections;\n\n\t\t\t\t\t\t\tif (innerCell.isVertex())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Get the connecting edge\n\t\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsSource;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsTarget;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (var connIndex = 0; connIndex < connections.length; connIndex++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (connections[connIndex].source == innerCell\n\t\t\t\t\t\t\t\t\t\t\t|| connections[connIndex].target == innerCell)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeCount += connections[connIndex].edges\n\t\t\t\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\n\t\t\t\t\t\t\t\t\t\tconnectedEdges.push(connections[connIndex]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconnectedEdgeCount += innerCell.edges.length;\n\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\t\t\t\t\t\t\t\tconnectedEdges.push(innerCell);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar requiredWidth = (connectedEdgeCount + 1)\n\t\t\t\t\t\t\t\t* this.prefHozEdgeSep;\n\n\t\t\t\t\t\t// Add a buffer on the edges of the vertex if the edge count allows\n\t\t\t\t\t\tif (cell.width > requiredWidth\n\t\t\t\t\t\t\t\t+ (2 * this.prefHozEdgeSep))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tleftLimit += this.prefHozEdgeSep;\n\t\t\t\t\t\t\trightLimit -= this.prefHozEdgeSep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar availableWidth = rightLimit - leftLimit;\n\t\t\t\t\t\tvar edgeSpacing = availableWidth / connectedEdgeCount;\n\n\t\t\t\t\t\tvar currentX = leftLimit + edgeSpacing / 2.0;\n\t\t\t\t\t\tvar currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n\t\t\t\t\t\tvar maxYOffset = 0;\n\n\t\t\t\t\t\tfor (var j = 0; j < connectedEdges.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar numActualEdges = connectedEdges[j].edges\n\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\tvar pos = this.jettyPositions[connectedEdges[j].ids[0]];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pos == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos = [];\n\t\t\t\t\t\t\t\tthis.jettyPositions[connectedEdges[j].ids[0]] = pos;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j < connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset += this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (j > connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset -= this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Ignore the case if equals, this means the second of 2\n\t\t\t\t\t\t\t// jettys with the same y (even number of edges)\n\n\t\t\t\t\t\t\tfor (var m = 0; m < numActualEdges; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2] = currentX;\n\t\t\t\t\t\t\t\tcurrentX += edgeSpacing;\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2 + 1] = currentYOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmaxYOffset = Math.max(maxYOffset,\n\t\t\t\t\t\t\t\t\tcurrentYOffset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCells = cell.getNextLayerConnectedCells(rankIndex);\n\n\t\t\t\t\tcurrentRank = rankIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: setEdgePosition\n * \n * Fixes the control points\n */\nmxCoordinateAssignment.prototype.setEdgePosition = function(cell)\n{\n\t// For parallel edges we need to seperate out the points a\n\t// little\n\tvar offsetX = 0;\n\t// Only set the edge control points once\n\n\tif (cell.temp[0] != 101207)\n\t{\n\t\tvar maxRank = cell.maxRank;\n\t\tvar minRank = cell.minRank;\n\t\t\n\t\tif (maxRank == minRank)\n\t\t{\n\t\t\tmaxRank = cell.source.maxRank;\n\t\t\tminRank = cell.target.minRank;\n\t\t}\n\t\t\n\t\tvar parallelEdgeCount = 0;\n\t\tvar jettys = this.jettyPositions[cell.ids[0]];\n\n\t\tvar source = cell.isReversed ? cell.target.cell : cell.source.cell;\n\t\tvar graph = this.layout.graph;\n\t\tvar layoutReversed = this.orientation == mxConstants.DIRECTION_EAST\n\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH;\n\n\t\tfor (var i = 0; i < cell.edges.length; i++)\n\t\t{\n\t\t\tvar realEdge = cell.edges[i];\n\t\t\tvar realSource = this.layout.getVisibleTerminal(realEdge, true);\n\n\t\t\t//List oldPoints = graph.getPoints(realEdge);\n\t\t\tvar newPoints = [];\n\n\t\t\t// Single length reversed edges end up with the jettys in the wrong\n\t\t\t// places. Since single length edges only have jettys, not segment\n\t\t\t// control points, we just say the edge isn't reversed in this section\n\t\t\tvar reversed = cell.isReversed;\n\t\t\t\n\t\t\tif (realSource != source)\n\t\t\t{\n\t\t\t\t// The real edges include all core model edges and these can go\n\t\t\t\t// in both directions. If the source of the hierarchical model edge\n\t\t\t\t// isn't the source of the specific real edge in this iteration\n\t\t\t\t// treat if as reversed\n\t\t\t\treversed = !reversed;\n\t\t\t}\n\n\t\t\t// First jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar y = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n\t\t\t\t\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ty += jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + arrayOffset];\n\t\t\t\t\n\t\t\t\tvar modelSource = graph.model.getTerminal(realEdge, true);\n\n\t\t\t\tif (this.layout.isPort(modelSource) && graph.model.getParent(modelSource) == realSource)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelSource);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realSource.geometry.x + cell.source.width * modelSource.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH\n\t\t\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\t\t\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y + jetty));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\t\t\t\t\t\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y + jetty, x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Declare variables to define loop through edge points and \n\t\t\t// change direction if edge is reversed\n\n\t\t\tvar loopStart = cell.x.length - 1;\n\t\t\tvar loopLimit = -1;\n\t\t\tvar loopDelta = -1;\n\t\t\tvar currentRank = cell.maxRank - 1;\n\n\t\t\tif (reversed)\n\t\t\t{\n\t\t\t\tloopStart = 0;\n\t\t\t\tloopLimit = cell.x.length;\n\t\t\t\tloopDelta = 1;\n\t\t\t\tcurrentRank = cell.minRank + 1;\n\t\t\t}\n\t\t\t// Reversed edges need the points inserted in\n\t\t\t// reverse order\n\t\t\tfor (var j = loopStart; (cell.maxRank != cell.minRank) && j != loopLimit; j += loopDelta)\n\t\t\t{\n\t\t\t\t// The horizontal position in a vertical layout\n\t\t\t\tvar positionX = cell.x[j] + offsetX;\n\n\t\t\t\t// Work out the vertical positions in a vertical layout\n\t\t\t\t// in the edge buffer channels above and below this rank\n\t\t\t\tvar topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2.0;\n\t\t\t\tvar bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2.0;\n\n\t\t\t\tif (reversed)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = topChannelY;\n\t\t\t\t\ttopChannelY = bottomChannelY;\n\t\t\t\t\tbottomChannelY = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, topChannelY));\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, bottomChannelY));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(topChannelY, positionX));\n\t\t\t\t\tnewPoints.push(new mxPoint(bottomChannelY, positionX));\n\t\t\t\t}\n\n\t\t\t\tthis.limitX = Math.max(this.limitX, positionX);\n\t\t\t\tcurrentRank += loopDelta;\n\t\t\t}\n\n\t\t\t// Second jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar rankY = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n\t\t\t\t\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\t\t\t\tvar y = rankY - jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n\t\t\t\t\n\t\t\t\tvar modelTarget = graph.model.getTerminal(realEdge, false);\n\t\t\t\tvar realTarget = this.layout.getVisibleTerminal(realEdge, false);\n\n\t\t\t\tif (this.layout.isPort(modelTarget) && graph.model.getParent(modelTarget) == realTarget)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelTarget);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realTarget.geometry.x + cell.target.width * modelTarget.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y - jetty));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y - jetty, x));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cell.isReversed)\n\t\t\t{\n\t\t\t\tthis.processReversedEdge(cell, realEdge);\n\t\t\t}\n\n\t\t\tthis.layout.setEdgePoints(realEdge, newPoints);\n\n\t\t\t// Increase offset so next edge is drawn next to\n\t\t\t// this one\n\t\t\tif (offsetX == 0.0)\n\t\t\t{\n\t\t\t\toffsetX = this.parallelEdgeSpacing;\n\t\t\t}\n\t\t\telse if (offsetX > 0)\n\t\t\t{\n\t\t\t\toffsetX = -offsetX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffsetX = -offsetX + this.parallelEdgeSpacing;\n\t\t\t}\n\t\t\t\n\t\t\tparallelEdgeCount++;\n\t\t}\n\n\t\tcell.temp[0] = 101207;\n\t}\n};\n\n\n/**\n * Function: setVertexLocation\n * \n * Fixes the position of the specified vertex.\n * \n * Parameters:\n * \n * cell - the vertex to position\n */\nmxCoordinateAssignment.prototype.setVertexLocation = function(cell)\n{\n\tvar realCell = cell.cell;\n\tvar positionX = cell.x[0] - cell.width / 2;\n\tvar positionY = cell.y[0] - cell.height / 2;\n\n\tthis.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n\tthis.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank],\n\t\t\tpositionY + cell.height);\n\n\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionX, positionY);\n\t}\n\telse\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionY, positionX);\n\t}\n\n\tthis.limitX = Math.max(this.limitX, positionX + cell.width);\n};\n\n/**\n * Function: processReversedEdge\n * \n * Hook to add additional processing\n * \n * Parameters:\n * \n * edge - the hierarchical model edge\n * realEdge - the real edge in the graph\n */\nmxCoordinateAssignment.prototype.processReversedEdge = function(graph, model)\n{\n\t// hook for subclassers\n};\n\n__mxOutput.mxCoordinateAssignment = typeof mxCoordinateAssignment !== 'undefined' ? mxCoordinateAssignment : undefined;\n"]}