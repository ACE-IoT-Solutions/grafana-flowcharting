{"version":3,"sources":["../../../../../../../../src/mxgraph/javascript/dist/js/layout/hierarchical/stage/mxSwimlaneOrdering.js"],"names":["mxSwimlaneOrdering","layout","prototype","mxHierarchicalLayoutStage","constructor","execute","parent","model","getModel","seenNodes","Object","unseenNodes","mxUtils","clone","vertexMapper","rootsArray","roots","modelRoots","i","length","nodeId","mxCellPath","create","get","visit","node","connectingEdge","layer","seen","isAncestor","swimlaneIndex","reversedOverSwimlane","source","invert","remove","connectsAsSource","push","connectsAsTarget","cellId","cell","__mxOutput","undefined"],"mappings":";;;;;AAAA;;;;AAIA;;;;;;;;;;AAUA,UAASA,kBAAT,CAA4BC,MAA5B,EACA;AACC,OAAKA,MAAL,GAAcA,MAAd;AACA,E;;;AAAA;;AAED;;;AAGAD,sBAAmBE,SAAnB,GAA+B,IAAIC,yBAAJ,EAA/B;AACAH,sBAAmBE,SAAnB,CAA6BE,WAA7B,GAA2CJ,kBAA3C;;AAEA;;;;;AAKAA,sBAAmBE,SAAnB,CAA6BD,MAA7B,GAAsC,IAAtC;;AAEA;;;;;;;AAOAD,sBAAmBE,SAAnB,CAA6BG,OAA7B,GAAuC,UAASC,MAAT,EACvC;AACC,QAAIC,QAAQ,KAAKN,MAAL,CAAYO,QAAZ,EAAZ;AACA,QAAIC,YAAY,IAAIC,MAAJ,EAAhB;AACA,QAAIC,cAAcC,QAAQC,KAAR,CAAcN,MAAMO,YAApB,EAAkC,IAAlC,EAAwC,IAAxC,CAAlB;;AAEA;AACA;AACA,QAAIC,aAAa,IAAjB;;AAEA,QAAIR,MAAMS,KAAN,IAAe,IAAnB,EACA;AACC,SAAIC,aAAaV,MAAMS,KAAvB;AACAD,kBAAa,EAAb;;AAEA,UAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAID,WAAWE,MAA/B,EAAuCD,GAAvC,EACA;AACC,UAAIE,SAASC,WAAWC,MAAX,CAAkBL,WAAWC,CAAX,CAAlB,CAAb;AACAH,iBAAWG,CAAX,IAAgBX,MAAMO,YAAN,CAAmBS,GAAnB,CAAuBN,WAAWC,CAAX,CAAvB,CAAhB;AACA;AACD;;AAEDX,UAAMiB,KAAN,CAAY,UAASlB,MAAT,EAAiBmB,IAAjB,EAAuBC,cAAvB,EAAuCC,KAAvC,EAA8CC,IAA9C,EACZ;AACC;AACA;AACA;AACA;AACA,SAAIC,aAAavB,UAAU,IAAV,IAAkBA,OAAOwB,aAAP,IAAwBL,KAAKK,aAA/C,IAAgEL,KAAKI,UAAL,CAAgBvB,MAAhB,CAAjF;;AAEA;AACA;AACA,SAAIyB,uBAAuBzB,UAAU,IAAV,IAAkBoB,kBAAkB,IAApC,IACvBpB,OAAOwB,aAAP,GAAuBL,KAAKK,aADL,IACsBJ,eAAeM,MAAf,IAAyBP,IAD1E;;AAGA,SAAII,UAAJ,EACA;AACCH,qBAAeO,MAAf;AACArB,cAAQsB,MAAR,CAAeR,cAAf,EAA+BpB,OAAO6B,gBAAtC;AACAV,WAAKU,gBAAL,CAAsBC,IAAtB,CAA2BV,cAA3B;AACApB,aAAO+B,gBAAP,CAAwBD,IAAxB,CAA6BV,cAA7B;AACAd,cAAQsB,MAAR,CAAeR,cAAf,EAA+BD,KAAKY,gBAApC;AACA,MAPD,MAQK,IAAIN,oBAAJ,EACL;AACCL,qBAAeO,MAAf;AACArB,cAAQsB,MAAR,CAAeR,cAAf,EAA+BpB,OAAO+B,gBAAtC;AACAZ,WAAKY,gBAAL,CAAsBD,IAAtB,CAA2BV,cAA3B;AACApB,aAAO6B,gBAAP,CAAwBC,IAAxB,CAA6BV,cAA7B;AACAd,cAAQsB,MAAR,CAAeR,cAAf,EAA+BD,KAAKU,gBAApC;AACA;;AAED,SAAIG,SAASjB,WAAWC,MAAX,CAAkBG,KAAKc,IAAvB,CAAb;AACA9B,eAAU6B,MAAV,IAAoBb,IAApB;AACA,YAAOd,YAAY2B,MAAZ,CAAP;AACA,KAjCD,EAiCGvB,UAjCH,EAiCe,IAjCf,EAiCqB,IAjCrB;AAkCA,IAxDD;;AA0DAyB,cAAWxC,kBAAX,GAAgC,OAAOA,kBAAP,KAA8B,WAA9B,GAA4CA,kBAA5C,GAAiEyC,SAAjG","file":"mxSwimlaneOrdering.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneOrdering\n * \n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n * \n * Constructor: mxSwimlaneOrdering\n *\n * Creates a cycle remover for the given internal model.\n */\nfunction mxSwimlaneOrdering(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage();\nmxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxSwimlaneOrdering.prototype.layout = null;\n\n/**\n * Function: execute\n * \n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxSwimlaneOrdering.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\tvar seenNodes = new Object();\n\tvar unseenNodes = mxUtils.clone(model.vertexMapper, null, true);\n\t\n\t// Perform a dfs through the internal model. If a cycle is found,\n\t// reverse it.\n\tvar rootsArray = null;\n\t\n\tif (model.roots != null)\n\t{\n\t\tvar modelRoots = model.roots;\n\t\trootsArray = [];\n\t\t\n\t\tfor (var i = 0; i < modelRoots.length; i++)\n\t\t{\n\t\t\tvar nodeId = mxCellPath.create(modelRoots[i]);\n\t\t\trootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n\t\t}\n\t}\n\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\t// Ancestor hashes only line up within a swimlane\n\t\tvar isAncestor = parent != null && parent.swimlaneIndex == node.swimlaneIndex && node.isAncestor(parent);\n\n\t\t// If the source->target swimlane indices go from higher to\n\t\t// lower, the edge is reverse\n\t\tvar reversedOverSwimlane = parent != null && connectingEdge != null &&\n\t\t\t\t\t\tparent.swimlaneIndex < node.swimlaneIndex && connectingEdge.source == node;\n\n\t\tif (isAncestor)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t}\n\t\telse if (reversedOverSwimlane)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsTarget);\n\t\t\tnode.connectsAsTarget.push(connectingEdge);\n\t\t\tparent.connectsAsSource.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsSource);\n\t\t}\n\t\t\n\t\tvar cellId = mxCellPath.create(node.cell);\n\t\tseenNodes[cellId] = node;\n\t\tdelete unseenNodes[cellId];\n\t}, rootsArray, true, null);\n};\n\n__mxOutput.mxSwimlaneOrdering = typeof mxSwimlaneOrdering !== 'undefined' ? mxSwimlaneOrdering : undefined;\n"]}