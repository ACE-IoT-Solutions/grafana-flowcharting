{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/io/mxCellCodec.js"],"names":["mxCodecRegistry","register","codec","mxObjectCodec","mxCell","isCellCodec","isNumericAttribute","dec","attr","obj","nodeName","prototype","apply","arguments","isExcluded","value","isWrite","nodeType","mxConstants","NODETYPE_ELEMENT","afterEncode","enc","node","tmp","mxUtils","importNode","document","appendChild","id","getAttribute","setAttribute","removeAttribute","beforeDecode","inner","cloneNode","classname","getName","getElementsByTagName","parentNode","removeWhitespace","removeChild","setId","i","idrefs","length","ref","object","objects","lookup","element","getElementById","decoder","codecs","decode","__mxOutput","mxCellCodec","undefined"],"mappings":"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","file":"mxCellCodec.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxCellCodec\n\t *\n\t * Codec for <mxCell>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - children\n\t * - edges\n\t * - overlays\n\t * - mxTransient\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t * - source\n\t * - target\n\t * \n\t * Transient fields can be added using the following code:\n\t * \n\t * mxCodecRegistry.getCodec(mxCell).exclude.push('name_of_field');\n\t * \n\t * To subclass <mxCell>, replace the template and add an alias as\n\t * follows.\n\t * \n\t * (code)\n\t * function CustomCell(value, geometry, style)\n\t * {\n\t *   mxCell.apply(this, arguments);\n\t * }\n\t * \n\t * mxUtils.extend(CustomCell, mxCell);\n\t * \n\t * mxCodecRegistry.getCodec(mxCell).template = new CustomCell();\n\t * mxCodecRegistry.addAlias('CustomCell', 'mxCell');\n\t * (end)\n\t */\n\tvar codec = new mxObjectCodec(new mxCell(),\n\t\t['children', 'edges', 'overlays', 'mxTransient'],\n\t\t['parent', 'source', 'target']);\n\n\t/**\n\t * Function: isCellCodec\n\t *\n\t * Returns true since this is a cell codec.\n\t */\n\tcodec.isCellCodec = function()\n\t{\n\t\treturn true;\n\t};\n\n\t/**\n\t * Overidden to disable conversion of value to number.\n\t */\n\tcodec.isNumericAttribute = function(dec, attr, obj)\n\t{\n\t\treturn attr.nodeName !== 'value' && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);\n\t};\n\t\n\t/**\n\t * Function: isExcluded\n\t *\n\t * Excludes user objects that are XML nodes.\n\t */ \n\tcodec.isExcluded = function(obj, attr, value, isWrite)\n\t{\n\t\treturn mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||\n\t\t\t(isWrite && attr == 'value' &&\n\t\t\tvalue.nodeType == mxConstants.NODETYPE_ELEMENT);\n\t};\n\t\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes an <mxCell> and wraps the XML up inside the\n\t * XML of the user object (inversion).\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (obj.value != null && obj.value.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Wraps the graphical annotation up in the user object (inversion)\n\t\t\t// by putting the result of the default encoding into a clone of the\n\t\t\t// user object (node type 1) and returning this cloned user object.\n\t\t\tvar tmp = node;\n\t\t\tnode = mxUtils.importNode(enc.document, obj.value, true);\n\t\t\tnode.appendChild(tmp);\n\t\t\t\n\t\t\t// Moves the id attribute to the outermost XML node, namely the\n\t\t\t// node which denotes the object boundaries in the file.\n\t\t\tvar id = tmp.getAttribute('id');\n\t\t\tnode.setAttribute('id', id);\n\t\t\ttmp.removeAttribute('id');\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes an <mxCell> and uses the enclosing XML node as\n\t * the user object for the cell (inversion).\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tvar inner = node.cloneNode(true);\n\t\tvar classname = this.getName();\n\t\t\n\t\tif (node.nodeName != classname)\n\t\t{\n\t\t\t// Passes the inner graphical annotation node to the\n\t\t\t// object codec for further processing of the cell.\n\t\t\tvar tmp = node.getElementsByTagName(classname)[0];\n\t\t\t\n\t\t\tif (tmp != null && tmp.parentNode == node)\n\t\t\t{\n\t\t\t\tmxUtils.removeWhitespace(tmp, true);\n\t\t\t\tmxUtils.removeWhitespace(tmp, false);\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\tinner = tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinner = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Creates the user object out of the XML node\n\t\t\tobj.value = node.cloneNode(true);\n\t\t\tvar id = obj.value.getAttribute('id');\n\t\t\t\n\t\t\tif (id != null)\n\t\t\t{\n\t\t\t\tobj.setId(id);\n\t\t\t\tobj.value.removeAttribute('id');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Uses ID from XML file as ID for cell in model\n\t\t\tobj.setId(node.getAttribute('id'));\n\t\t}\n\t\t\t\n\t\t// Preprocesses and removes all Id-references in order to use the\n\t\t// correct encoder (this) for the known references to cells (all).\n\t\tif (inner != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.idrefs.length; i++)\n\t\t\t{\n\t\t\t\tvar attr = this.idrefs[i];\n\t\t\t\tvar ref = inner.getAttribute(attr);\n\t\t\t\t\n\t\t\t\tif (ref != null)\n\t\t\t\t{\n\t\t\t\t\tinner.removeAttribute(attr);\n\t\t\t\t\tvar object = dec.objects[ref] || dec.lookup(ref);\n\t\t\t\t\t\n\t\t\t\t\tif (object == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Needs to decode forward reference\n\t\t\t\t\t\tvar element = dec.getElementById(ref);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (element != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar decoder = mxCodecRegistry.codecs[element.nodeName] || this;\n\t\t\t\t\t\t\tobject = decoder.decode(dec, element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tobj[attr] = object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inner;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxCellCodec = typeof mxCellCodec !== 'undefined' ? mxCellCodec : undefined;\n"]}