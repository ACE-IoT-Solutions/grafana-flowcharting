{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/io/mxCodec.js"],"names":["mxCodec","document","mxUtils","createXmlDocument","objects","prototype","elements","encodeDefaults","putObject","id","obj","getObject","lookup","node","getElementById","decode","Object","documentElement","addElement","nodeType","mxConstants","NODETYPE_ELEMENT","getAttribute","firstChild","nextSibling","getId","reference","mxCell","mxCellPath","create","length","encode","constructor","enc","mxCodecRegistry","getCodec","isNode","importNode","mxLog","warn","getFunctionName","into","ctor","window","nodeName","err","dec","cloneNode","removeAttribute","encodeCell","cell","includeChildren","appendChild","childCount","getChildCount","i","getChildAt","isCellCodec","codec","decodeCell","restoreStructures","decoder","child","insertIntoGraph","parent","source","getTerminal","target","setTerminal","insert","insertEdge","setAttribute","attribute","value","__mxOutput","undefined"],"mappings":"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","file":"mxCodec.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCodec\n *\n * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\n * description of the general encoding/decoding scheme. This class uses the\n * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\n * \n * References:\n * \n * In order to resolve references, especially forward references, the mxCodec\n * constructor must be given the document that contains the referenced\n * elements.\n *\n * Examples:\n *\n * The following code is used to encode a graph model.\n *\n * (code)\n * var encoder = new mxCodec();\n * var result = encoder.encode(graph.getModel());\n * var xml = mxUtils.getXml(result);\n * (end)\n * \n * Example:\n * \n * Using the code below, an XML document is decoded into an existing model. The\n * document may be obtained using one of the functions in mxUtils for loading\n * an XML file, eg. <mxUtils.get>, or using <mxUtils.parseXml> for parsing an\n * XML string.\n * \n * (code)\n * var doc = mxUtils.parseXml(xmlString);\n * var codec = new mxCodec(doc);\n * codec.decode(doc.documentElement, graph.getModel());\n * (end)\n * \n * Example:\n * \n * This example demonstrates parsing a list of isolated cells into an existing\n * graph model. Note that the cells do not have a parent reference so they can\n * be added anywhere in the cell hierarchy after parsing.\n * \n * (code)\n * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\n * var doc = mxUtils.parseXml(xml);\n * var codec = new mxCodec(doc);\n * var elt = doc.documentElement.firstChild;\n * var cells = [];\n * \n * while (elt != null)\n * {\n *   cells.push(codec.decode(elt));\n *   elt = elt.nextSibling;\n * }\n * \n * graph.addCells(cells);\n * (end)\n * \n * Example:\n * \n * Using the following code, the selection cells of a graph are encoded and the\n * output is displayed in a dialog box.\n * \n * (code)\n * var enc = new mxCodec();\n * var cells = graph.getSelectionCells();\n * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\n * (end)\n * \n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\n * must be passed to <mxUtils.getXml> as the second argument.\n * \n * Debugging:\n * \n * For debugging I/O you can use the following code to get the sequence of\n * encoded objects:\n * \n * (code)\n * var oldEncode = mxCodec.prototype.encode;\n * mxCodec.prototype.encode = function(obj)\n * {\n *   mxLog.show();\n *   mxLog.debug('mxCodec.encode: obj='+mxUtils.getFunctionName(obj.constructor));\n *   \n *   return oldEncode.apply(this, arguments);\n * };\n * (end)\n * \n * Note that the I/O system adds object codecs for new object automatically. For\n * decoding those objects, the constructor should be written as follows:\n * \n * (code)\n * var MyObj = function(name)\n * {\n *   // ...\n * };\n * (end)\n * \n * Constructor: mxCodec\n *\n * Constructs an XML encoder/decoder for the specified\n * owner document.\n *\n * Parameters:\n *\n * document - Optional XML document that contains the data.\n * If no document is specified then a new document is created\n * using <mxUtils.createXmlDocument>.\n */\nfunction mxCodec(document)\n{\n\tthis.document = document || mxUtils.createXmlDocument();\n\tthis.objects = [];\n};\n\n/**\n * Variable: document\n *\n * The owner document of the codec.\n */\nmxCodec.prototype.document = null;\n\n/**\n * Variable: objects\n *\n * Maps from IDs to objects.\n */\nmxCodec.prototype.objects = null;\n\n/**\n * Variable: elements\n * \n * Lookup table for resolving IDs to elements.\n */\nmxCodec.prototype.elements = null;\n\n/**\n * Variable: encodeDefaults\n *\n * Specifies if default values should be encoded. Default is false.\n */\nmxCodec.prototype.encodeDefaults = false;\n\n\n/**\n * Function: putObject\n * \n * Assoiates the given object with the given ID and returns the given object.\n * \n * Parameters\n * \n * id - ID for the object to be associated with.\n * obj - Object to be associated with the ID.\n */\nmxCodec.prototype.putObject = function(id, obj)\n{\n\tthis.objects[id] = obj;\n\t\n\treturn obj;\n};\n\n/**\n * Function: getObject\n *\n * Returns the decoded object for the element with the specified ID in\n * <document>. If the object is not known then <lookup> is used to find an\n * object. If no object is found, then the element with the respective ID\n * from the document is parsed using <decode>.\n */\nmxCodec.prototype.getObject = function(id)\n{\n\tvar obj = null;\n\n\tif (id != null)\n\t{\n\t\tobj = this.objects[id];\n\t\t\n\t\tif (obj == null)\n\t\t{\n\t\t\tobj = this.lookup(id);\n\t\t\t\n\t\t\tif (obj == null)\n\t\t\t{\n\t\t\t\tvar node = this.getElementById(id);\n\t\t\t\t\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tobj = this.decode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn obj;\n};\n\n/**\n * Function: lookup\n *\n * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\n * This implementation always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * };\n * (end)\n *\n * Parameters:\n *\n * id - ID of the object to be returned.\n */\nmxCodec.prototype.lookup = function(id)\n{\n\treturn null;\n};\n\n/**\n * Function: getElementById\n *\n * Returns the element with the given ID from <document>.\n *\n * Parameters:\n *\n * id - String that contains the ID.\n */\nmxCodec.prototype.getElementById = function(id)\n{\n\tif (this.elements == null)\n\t{\n\t\tthis.elements = new Object();\n\t\t\n\t\tif (this.document.documentElement != null)\n\t\t{\n\t\t\tthis.addElement(this.document.documentElement);\n\t\t}\n\t}\n\t\n\treturn this.elements[id];\n};\n\n/**\n * Function: addElement\n *\n * Adds the given element to <elements> if it has an ID.\n */\nmxCodec.prototype.addElement = function(node)\n{\n\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar id = node.getAttribute('id');\n\t\t\n\t\tif (id != null && this.elements[id] == null)\n\t\t{\n\t\t\tthis.elements[id] = node;\n\t\t}\n\t}\n\t\n\tnode = node.firstChild;\n\t\n\twhile (node != null)\n\t{\n\t\tthis.addElement(node);\n\t\tnode = node.nextSibling;\n\t}\n};\n\n/**\n * Function: getId\n *\n * Returns the ID of the specified object. This implementation\n * calls <reference> first and if that returns null handles\n * the object as an <mxCell> by returning their IDs using\n * <mxCell.getId>. If no ID exists for the given cell, then\n * an on-the-fly ID is generated using <mxCellPath.create>.\n *\n * Parameters:\n *\n * obj - Object to return the ID for.\n */\nmxCodec.prototype.getId = function(obj)\n{\n\tvar id = null;\n\t\n\tif (obj != null)\n\t{\n\t\tid = this.reference(obj);\n\t\t\n\t\tif (id == null && obj instanceof mxCell)\n\t\t{\n\t\t\tid = obj.getId();\n\t\t\t\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\t// Uses an on-the-fly Id\n\t\t\t\tid = mxCellPath.create(obj);\n\t\t\t\t\n\t\t\t\tif (id.length == 0)\n\t\t\t\t{\n\t\t\t\t\tid = 'root';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn id;\n};\n\n/**\n * Function: reference\n *\n * Hook for subclassers to implement a custom method\n * for retrieving IDs from objects. This implementation\n * always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.reference = function(obj)\n * {\n *   return obj.getCustomId();\n * };\n * (end)\n *\n * Parameters:\n *\n * obj - Object whose ID should be returned.\n */\nmxCodec.prototype.reference = function(obj)\n{\n\treturn null;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns the resulting\n * XML node.\n *\n * Parameters:\n *\n * obj - Object to be encoded. \n */\nmxCodec.prototype.encode = function(obj)\n{\n\tvar node = null;\n\t\n\tif (obj != null && obj.constructor != null)\n\t{\n\t\tvar enc = mxCodecRegistry.getCodec(obj.constructor);\n\t\t\n\t\tif (enc != null)\n\t\t{\n\t\t\tnode = enc.encode(this, obj);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxUtils.isNode(obj))\n\t\t\t{\n\t\t\t\tnode = mxUtils.importNode(this.document, obj, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t    \t\tmxLog.warn('mxCodec.encode: No codec for ' + mxUtils.getFunctionName(obj.constructor));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Decodes the given XML node. The optional \"into\"\n * argument specifies an existing object to be\n * used. If no object is given, then a new instance\n * is created using the constructor from the codec.\n *\n * The function returns the passed in object or\n * the new instance if no object was given.\n *\n * Parameters:\n *\n * node - XML node to be decoded.\n * into - Optional object to be decodec into.\n */\nmxCodec.prototype.decode = function(node, into)\n{\n\tvar obj = null;\n\t\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar ctor = null;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tctor = window[node.nodeName];\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tvar dec = mxCodecRegistry.getCodec(ctor);\n\t\t\n\t\tif (dec != null)\n\t\t{\n\t\t\tobj = dec.decode(this, node, into);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj = node.cloneNode(true);\n\t\t\tobj.removeAttribute('as');\n\t\t}\n\t}\n\t\n\treturn obj;\n};\n\n/**\n * Function: encodeCell\n *\n * Encoding of cell hierarchies is built-into the core, but\n * is a higher-level function that needs to be explicitely\n * used by the respective object encoders (eg. <mxModelCodec>,\n * <mxChildChangeCodec> and <mxRootChangeCodec>). This\n * implementation writes the given cell and its children as a\n * (flat) sequence into the given node. The children are not\n * encoded if the optional includeChildren is false. The\n * function is in charge of adding the result into the\n * given node and has no return value.\n *\n * Parameters:\n *\n * cell - <mxCell> to be encoded.\n * node - Parent XML node to add the encoded cell into.\n * includeChildren - Optional boolean indicating if the\n * function should include all descendents. Default is true. \n */\nmxCodec.prototype.encodeCell = function(cell, node, includeChildren)\n{\n\tnode.appendChild(this.encode(cell));\n\t\n\tif (includeChildren == null || includeChildren)\n\t{\n\t\tvar childCount = cell.getChildCount();\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.encodeCell(cell.getChildAt(i), node);\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellCodec\n * \n * Returns true if the given codec is a cell codec. This uses\n * <mxCellCodec.isCellCodec> to check if the codec is of the\n * given type.\n */\nmxCodec.prototype.isCellCodec = function(codec)\n{\n\tif (codec != null && typeof(codec.isCellCodec) == 'function')\n\t{\n\t\treturn codec.isCellCodec();\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: decodeCell\n *\n * Decodes cells that have been encoded using inversion, ie.\n * where the user object is the enclosing node in the XML,\n * and restores the group and graph structure in the cells.\n * Returns a new <mxCell> instance that represents the\n * given node.\n *\n * Parameters:\n *\n * node - XML node that contains the cell data.\n * restoreStructures - Optional boolean indicating whether\n * the graph structure should be restored by calling insert\n * and insertEdge on the parent and terminals, respectively.\n * Default is true.\n */\nmxCodec.prototype.decodeCell = function(node, restoreStructures)\n{\n\trestoreStructures = (restoreStructures != null) ? restoreStructures : true;\n\tvar cell = null;\n\t\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\t// Tries to find a codec for the given node name. If that does\n\t\t// not return a codec then the node is the user object (an XML node\n\t\t// that contains the mxCell, aka inversion).\n\t\tvar decoder = mxCodecRegistry.getCodec(node.nodeName);\n\t\t\n\t\t// Tries to find the codec for the cell inside the user object.\n\t\t// This assumes all node names inside the user object are either\n\t\t// not registered or they correspond to a class for cells.\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tvar child = node.firstChild;\n\t\t\t\n\t\t\twhile (child != null && !this.isCellCodec(decoder))\n\t\t\t{\n\t\t\t\tdecoder = mxCodecRegistry.getCodec(child.nodeName);\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tdecoder = mxCodecRegistry.getCodec(mxCell);\n\t\t}\n\n\t\tcell = decoder.decode(this, node);\n\t\t\n\t\tif (restoreStructures)\n\t\t{\n\t\t\tthis.insertIntoGraph(cell);\n\t\t}\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: insertIntoGraph\n *\n * Inserts the given cell into its parent and terminal cells.\n */\nmxCodec.prototype.insertIntoGraph = function(cell)\n{\n\tvar parent = cell.parent;\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\n\t// Fixes possible inconsistencies during insert into graph\n\tcell.setTerminal(null, false);\n\tcell.setTerminal(null, true);\n\tcell.parent = null;\n\t\n\tif (parent != null)\n\t{\n\t\tparent.insert(cell);\n\t}\n\n\tif (source != null)\n\t{\n\t\tsource.insertEdge(cell, true);\n\t}\n\n\tif (target != null)\n\t{\n\t\ttarget.insertEdge(cell, false);\n\t}\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the attribute on the specified node to value. This is a\n * helper method that makes sure the attribute and value arguments\n * are not null.\n *\n * Parameters:\n *\n * node - XML node to set the attribute for.\n * attributes - Attributename to be set.\n * value - New value of the attribute.\n */\nmxCodec.prototype.setAttribute = function(node, attribute, value)\n{\n\tif (attribute != null && value != null)\n\t{\n\t\tnode.setAttribute(attribute, value);\n\t}\n};\n\n__mxOutput.mxCodec = typeof mxCodec !== 'undefined' ? mxCodec : undefined;\n"]}