{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/io/mxChildChangeCodec.js"],"names":["mxCodecRegistry","register","codec","mxObjectCodec","mxChildChange","isReference","obj","attr","value","isWrite","previous","mxUtils","indexOf","idrefs","afterEncode","enc","node","child","setAttribute","getId","encodeCell","beforeDecode","dec","firstChild","nodeType","mxConstants","NODETYPE_ELEMENT","cloneNode","tmp","decodeCell","tmp2","nextSibling","parentNode","removeChild","id","getAttribute","lookup","childRef","getObject","afterDecode","parent","previousIndex","index","__mxOutput","mxChildChangeCodec","undefined"],"mappings":"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","file":"mxChildChangeCodec.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxChildChangeCodec\n\t *\n\t * Codec for <mxChildChange>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t * - previousIndex\n\t * - child\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t */\n\tvar codec = new mxObjectCodec(new mxChildChange(),\n\t\t['model', 'child', 'previousIndex'],\n\t\t['parent', 'previous']);\n\n\t/**\n\t * Function: isReference\n\t *\n\t * Returns true for the child attribute if the child\n\t * cell had a previous parent or if we're reading the\n\t * child as an attribute rather than a child node, in\n\t * which case it's always a reference.\n\t */\n\tcodec.isReference = function(obj, attr, value, isWrite)\n\t{\n\t\tif (attr == 'child' && (obj.previous != null || !isWrite))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n\t};\n\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes the child recusively and adds the result\n\t * to the given node.\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (this.isReference(obj, 'child',  obj.child, true))\n\t\t{\n\t\t\t// Encodes as reference (id)\n\t\t\tnode.setAttribute('child', enc.getId(obj.child));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// At this point, the encoder is no longer able to know which cells\n\t\t\t// are new, so we have to encode the complete cell hierarchy and\n\t\t\t// ignore the ones that are already there at decoding time. Note:\n\t\t\t// This can only be resolved by moving the notify event into the\n\t\t\t// execute of the edit.\n\t\t\tenc.encodeCell(obj.child, node);\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the any child nodes as using the respective\n\t * codec from the registry.\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tif (node.firstChild != null &&\n\t\t\tnode.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Makes sure the original node isn't modified\n\t\t\tnode = node.cloneNode(true);\n\t\t\t\n\t\t\tvar tmp = node.firstChild;\n\t\t\tobj.child = dec.decodeCell(tmp, false);\n\n\t\t\tvar tmp2 = tmp.nextSibling;\n\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\ttmp = tmp2;\n\t\t\t\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\ttmp2 = tmp.nextSibling;\n\t\t\t\t\n\t\t\t\tif (tmp.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t{\n\t\t\t\t\t// Ignores all existing cells because those do not need to\n\t\t\t\t\t// be re-inserted into the model. Since the encoded version\n\t\t\t\t\t// of these cells contains the new parent, this would leave\n\t\t\t\t\t// to an inconsistent state on the model (ie. a parent\n\t\t\t\t\t// change without a call to parentForCellChanged).\n\t\t\t\t\tvar id = tmp.getAttribute('id');\n\t\t\t\t\t\n\t\t\t\t\tif (dec.lookup(id) == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdec.decodeCell(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\ttmp = tmp2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar childRef = node.getAttribute('child');\n\t\t\tobj.child = dec.getObject(childRef);\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\t\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores object state in the child change.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Cells are encoded here after a complete transaction so the previous\n\t\t// parent must be restored on the cell for the case where the cell was\n\t\t// added. This is needed for the local model to identify the cell as a\n\t\t// new cell and register the ID.\n        if (obj.child != null)\n        {\n            if (obj.child.parent != null && obj.previous != null &&\n                obj.child.parent != obj.previous)\n            {\n            \t\n                obj.previous = obj.child.parent;\n            }\n\n            obj.child.parent = obj.previous;\n            obj.previous = obj.parent;\n            obj.previousIndex = obj.index;\n        }\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxChildChangeCodec = typeof mxChildChangeCodec !== 'undefined' ? mxChildChangeCodec : undefined;\n"]}