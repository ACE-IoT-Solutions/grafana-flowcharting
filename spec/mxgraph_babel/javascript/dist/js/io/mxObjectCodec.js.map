{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/io/mxObjectCodec.js"],"names":["mxObjectCodec","template","exclude","idrefs","mapping","reverse","Object","i","allowEval","prototype","getName","mxUtils","getFunctionName","constructor","cloneTemplate","getFieldName","attributename","mapped","getAttributeName","fieldname","isExcluded","obj","attr","value","write","mxObjectIdentity","FIELD_NAME","indexOf","isReference","encode","enc","node","document","createElement","beforeEncode","encodeObject","afterEncode","setAttribute","getId","name","isInteger","encodeValue","tmp","mxLog","warn","defaultValue","encodeDefaults","writeAttribute","writePrimitiveAttribute","writeComplexAttribute","convertAttributeToXml","child","appendChild","createTextNode","isBooleanAttribute","length","convertAttributeFromXml","dec","isNumericAttribute","parseFloat","isNaN","result","mxGeometry","mxPoint","isNumeric","decode","into","id","getAttribute","objects","putObject","beforeDecode","decodeNode","afterDecode","decodeAttributes","decodeChildren","attrs","attributes","decodeAttribute","isIgnoredAttribute","nodeName","getObject","firstChild","nextSibling","nodeType","mxConstants","NODETYPE_ELEMENT","processInclude","decodeChild","getFieldTemplate","eval","getTextContent","addObjectValue","Array","push","xml","load","getDocumentElement","e","__mxOutput","undefined"],"mappings":"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","file":"mxObjectCodec.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxObjectCodec\n *\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n * \n * Atomic Values:\n * \n * Consider the following example.\n * \n * (code)\n * var obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * (end)\n * \n * This object is encoded into an XML node using the following.\n * \n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(obj);\n * (end)\n * \n * The output of the encoding may be viewed using <mxLog> as follows.\n * \n * (code)\n * mxLog.show();\n * mxLog.debug(mxUtils.getPrettyXml(node));\n * (end)\n * \n * Finally, the result of the encoding looks as follows.\n * \n * (code)\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * (end)\n * \n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * nodename.\n * \n * Booleans:\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n * \n * Objects:\n * \n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the fieldname. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * fieldname.\n * \n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n * \n * (code)\n * var obj = {foo: {bar: \"Bar\"}};\n * (end)\n * \n * This will be mapped to the following XML structure by mxObjectCodec.\n * \n * (code)\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * (end)\n * \n * In the above output, the inner Object node contains the as-attribute that\n * specifies the fieldname in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n * \n * Arrays:\n * \n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the fieldname, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n * \n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n * \n * (code)\n * var obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * (end)\n * \n * This array is represented by the following XML nodes.\n * \n * (code)\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * (end)\n * \n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n * \n * References:\n * \n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within <mxCodec>. The\n * <isReference> function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the fieldname is in <idrefs>, an array of strings that is used to configure\n * the <mxObjectCodec>.\n * \n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n * \n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n * \n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in <isExcluded>, whose default implementation uses the array of excluded\n * fieldnames passed to the mxObjectCodec constructor.\n * \n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing <mxCodec.reference>. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, <mxCodec.lookup> may be implemented.\n * \n * Expressions:\n * \n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of <mxConstants.ALIGN_LEFT>.\n * \n * (code)\n * <Object>\n *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>\n * </Object>\n * (end)\n * \n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n * \n * (code)\n * <Object foo=\"left\"/>\n * (end)\n * \n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n * \n * Expressions are only evaluated if <allowEval> is true.\n * \n * Constructor: mxObjectCodec\n *\n * Constructs a new codec for the specified template object.\n * The variables in the optional exclude array are ignored by\n * the codec. Variables in the optional idrefs array are\n * turned into references in the XML. The optional mapping\n * may be used to map from variable names to XML attributes.\n * The argument is created as follows:\n *\n * (code)\n * var mapping = new Object();\n * mapping['variableName'] = 'attribute-name';\n * (end)\n *\n * Parameters:\n *\n * template - Prototypical instance of the object to be\n * encoded/decoded.\n * exclude - Optional array of fieldnames to be ignored.\n * idrefs - Optional array of fieldnames to be converted to/from\n * references.\n * mapping - Optional mapping from field- to attributenames.\n */\nfunction mxObjectCodec(template, exclude, idrefs, mapping)\n{\n\tthis.template = template;\n\t\n\tthis.exclude = (exclude != null) ? exclude : [];\n\tthis.idrefs = (idrefs != null) ? idrefs : [];\n\tthis.mapping = (mapping != null) ? mapping : [];\n\t\n\tthis.reverse = new Object();\n\t\n\tfor (var i in this.mapping)\n\t{\n\t\tthis.reverse[this.mapping[i]] = i;\n\t}\n};\n\n/**\n * Variable: allowEval\n *\n * Static global switch that specifies if expressions in arrays are allowed.\n * Default is false. NOTE: Enabling this carries a possible security risk.\n */\nmxObjectCodec.allowEval = false;\n\n/**\n * Variable: template\n *\n * Holds the template object associated with this codec.\n */\nmxObjectCodec.prototype.template = null;\n\n/**\n * Variable: exclude\n *\n * Array containing the variable names that should be\n * ignored by the codec.\n */\nmxObjectCodec.prototype.exclude = null;\n\n/**\n * Variable: idrefs\n *\n * Array containing the variable names that should be\n * turned into or converted from references. See\n * <mxCodec.getId> and <mxCodec.getObject>.\n */\nmxObjectCodec.prototype.idrefs = null;\n\n/**\n * Variable: mapping\n *\n * Maps from from fieldnames to XML attribute names.\n */\nmxObjectCodec.prototype.mapping = null;\n\n/**\n * Variable: reverse\n *\n * Maps from from XML attribute names to fieldnames.\n */\nmxObjectCodec.prototype.reverse = null;\n\n/**\n * Function: getName\n * \n * Returns the name used for the nodenames and lookup of the codec when\n * classes are encoded and nodes are decoded. For classes to work with\n * this the codec registry automatically adds an alias for the classname\n * if that is different than what this returns. The default implementation\n * returns the classname of the template class.\n */\nmxObjectCodec.prototype.getName = function()\n{\n\treturn mxUtils.getFunctionName(this.template.constructor);\n};\n\n/**\n * Function: cloneTemplate\n * \n * Returns a new instance of the template for this codec.\n */\nmxObjectCodec.prototype.cloneTemplate = function()\n{\n\treturn new this.template.constructor();\n};\n\n/**\n * Function: getFieldName\n * \n * Returns the fieldname for the given attributename.\n * Looks up the value in the <reverse> mapping or returns\n * the input if there is no reverse mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getFieldName = function(attributename)\n{\n\tif (attributename != null)\n\t{\n\t\tvar mapped = this.reverse[attributename];\n\t\t\n\t\tif (mapped != null)\n\t\t{\n\t\t\tattributename = mapped;\n\t\t}\n\t}\n\t\n\treturn attributename;\n};\n\n/**\n * Function: getAttributeName\n * \n * Returns the attributename for the given fieldname.\n * Looks up the value in the <mapping> or returns\n * the input if there is no mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getAttributeName = function(fieldname)\n{\n\tif (fieldname != null)\n\t{\n\t\tvar mapped = this.mapping[fieldname];\n\t\t\n\t\tif (mapped != null)\n\t\t{\n\t\t\tfieldname = mapped;\n\t\t}\n\t}\n\t\n\treturn fieldname;\n};\n\n/**\n * Function: isExcluded\n *\n * Returns true if the given attribute is to be ignored by the codec. This\n * implementation returns true if the given fieldname is in <exclude> or\n * if the fieldname equals <mxObjectIdentity.FIELD_NAME>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field.\n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isExcluded = function(obj, attr, value, write)\n{\n\treturn attr == mxObjectIdentity.FIELD_NAME ||\n\t\tmxUtils.indexOf(this.exclude, attr) >= 0;\n};\n\n/**\n * Function: isReference\n *\n * Returns true if the given fieldname is to be treated\n * as a textual reference (ID). This implementation returns\n * true if the given fieldname is in <idrefs>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field. \n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isReference = function(obj, attr, value, write)\n{\n\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns a node\n * representing then given object. Calls <beforeEncode>\n * after creating the node and <afterEncode> with the \n * resulting node after processing.\n *\n * Enc is a reference to the calling encoder. It is used\n * to encode complex objects and create references.\n *\n * This implementation encodes all variables of an\n * object according to the following rules:\n *\n * - If the variable name is in <exclude> then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getId>\n * is used to replace the object with its ID.\n * - The variable name is mapped using <mapping>.\n * - If obj is an array and the variable name is numeric\n * (ie. an index) then it is not encoded.\n * - If the value is an object, then the codec is used to\n * create a child node with the variable name encoded into\n * the \"as\" attribute.\n * - Else, if <encodeDefaults> is true or the value differs\n * from the template value, then ...\n * - ... if obj is not an array, then the value is mapped to\n * an attribute.\n * - ... else if obj is an array, the value is mapped to an\n * add child with a value attribute or a text child node,\n * if the value is a function.\n *\n * If no ID exists for a variable in <idrefs> or if an object\n * cannot be encoded, a warning is issued using <mxLog.warn>.\n *\n * Returns the resulting XML node that represents the given\n * object.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n */\nmxObjectCodec.prototype.encode = function(enc, obj)\n{\n\tvar node = enc.document.createElement(this.getName());\n\t\n\tobj = this.beforeEncode(enc, obj, node);\n\tthis.encodeObject(enc, obj, node);\n\t\n\treturn this.afterEncode(enc, obj, node);\n};\n\t\n/**\n * Function: encodeObject\n *\n * Encodes the value of each member in then given obj into the given node using\n * <encodeValue>.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeObject = function(enc, obj, node)\n{\n\tenc.setAttribute(node, 'id', enc.getId(obj));\n\t\n    for (var i in obj)\n    {\n\t\tvar name = i;\n\t\tvar value = obj[name];\n\t\t\n    \tif (value != null && !this.isExcluded(obj, name, value, true))\n    \t{\n    \t\tif (mxUtils.isInteger(name))\n    \t\t{\n    \t\t\tname = null;\n    \t\t}\n    \t\t\n    \t\tthis.encodeValue(enc, obj, name, value, node);\n    \t}\n    }\n};\n\n/**\n * Function: encodeValue\n * \n * Converts the given value according to the mappings\n * and id-refs in this codec and uses <writeAttribute>\n * to write the attribute into the given node.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object whose property is going to be encoded.\n * name - XML node that contains the encoded object.\n * value - Value of the property to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeValue = function(enc, obj, name, value, node)\n{\n\tif (value != null)\n\t{\n\t\tif (this.isReference(obj, name, value, true))\n\t\t{\n\t\t\tvar tmp = enc.getId(value);\n\t\t\t\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.encode: No ID for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\t\t    \n\t\t    value = tmp;\n\t\t}\n\n\t\tvar defaultValue = this.template[name];\n\t\t\n\t\t// Checks if the value is a default value and\n\t\t// the name is correct\n\t\tif (name == null || enc.encodeDefaults || defaultValue != value)\n\t\t{\n\t\t\tname = this.getAttributeName(name);\n\t\t\tthis.writeAttribute(enc, obj, name, value, node);\t\n\t\t}\n\t}\n};\n\n/**\n * Function: writeAttribute\n * \n * Writes the given value into node using <writePrimitiveAttribute>\n * or <writeComplexAttribute> depending on the type of the value.\n */\nmxObjectCodec.prototype.writeAttribute = function(enc, obj, name, value, node)\n{\n\tif (typeof(value) != 'object' /* primitive type */)\n\t{\n\t\tthis.writePrimitiveAttribute(enc, obj, name, value, node);\n\t}\n\telse /* complex type */\n\t{\n\t\tthis.writeComplexAttribute(enc, obj, name, value, node);\n\t}\n};\n\n/**\n * Function: writePrimitiveAttribute\n * \n * Writes the given value as an attribute of the given node.\n */\nmxObjectCodec.prototype.writePrimitiveAttribute = function(enc, obj, name, value, node)\n{\n\tvalue = this.convertAttributeToXml(enc, obj, name, value, node);\n\t\n\tif (name == null)\n\t{\n\t\tvar child = enc.document.createElement('add');\n\t\t\n\t\tif (typeof(value) == 'function')\n\t\t{\n    \t\tchild.appendChild(enc.document.createTextNode(value));\n    \t}\n    \telse\n    \t{\n    \t\tenc.setAttribute(child, 'value', value);\n    \t}\n    \t\n\t\tnode.appendChild(child);\n\t}\n\telse if (typeof(value) != 'function')\n\t{\n    \tenc.setAttribute(node, name, value);\n\t}\t\t\n};\n\t\n/**\n * Function: writeComplexAttribute\n * \n * Writes the given value as a child node of the given node.\n */\nmxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name, value, node)\n{\n\tvar child = enc.encode(value);\n\t\n\tif (child != null)\n\t{\n\t\tif (name != null)\n\t\t{\n    \t\tchild.setAttribute('as', name);\n    \t}\n    \t\n    \tnode.appendChild(child);\n\t}\n\telse\n\t{\n\t\tmxLog.warn('mxObjectCodec.encode: No node for ' + this.getName() + '.' + name + ': ' + value);\n\t}\n};\n\n/**\n * Function: convertAttributeToXml\n * \n * Converts true to \"1\" and false to \"0\" is <isBooleanAttribute> returns true.\n * All other values are not converted.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value to be converted.\n */\nmxObjectCodec.prototype.convertAttributeToXml = function(enc, obj, name, value)\n{\n\t// Makes sure to encode boolean values as numeric values\n\tif (this.isBooleanAttribute(enc, obj, name, value))\n\t{\t\n\t\t// Checks if the value is true (do not use the value as is, because\n\t\t// this would check if the value is not null, so 0 would be true)\n\t\tvalue = (value == true) ? '1' : '0';\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: isBooleanAttribute\n * \n * Returns true if the given object attribute is a boolean value.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value of the attribute to be converted.\n */\nmxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name, value)\n{\n\treturn (typeof(value.length) == 'undefined' && (value == true || value == false));\n};\n\n/**\n * Function: convertAttributeFromXml\n * \n * Converts booleans and numeric values to the respective types. Values are\n * numeric if <isNumericAttribute> returns true.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr, obj)\n{\n\tvar value = attr.value;\n\t\n\tif (this.isNumericAttribute(dec, attr, obj))\n\t{\n\t\tvalue = parseFloat(value);\n\t\t\n\t\tif (isNaN(value))\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: isNumericAttribute\n * \n * Returns true if the given XML attribute is or should be a numeric value.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.isNumericAttribute = function(dec, attr, obj)\n{\n\t// Handles known numeric attributes for generic objects\n\tvar result = (obj.constructor == mxGeometry &&\n\t\t(attr.name == 'x' || attr.name == 'y' ||\n\t\tattr.name == 'width' || attr.name == 'height')) ||\n\t\t(obj.constructor == mxPoint &&\n\t\t(attr.name == 'x' || attr.name == 'y')) ||\n\t\tmxUtils.isNumeric(attr.value);\n\t\n\treturn result;\n};\n\n/**\n * Function: beforeEncode\n *\n * Hook for subclassers to pre-process the object before\n * encoding. This returns the input object. The return\n * value of this function is used in <encode> to perform\n * the default encoding into the given node.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node to encode the object into.\n */\nmxObjectCodec.prototype.beforeEncode = function(enc, obj, node)\n{\n\treturn obj;\n};\n\n/**\n * Function: afterEncode\n *\n * Hook for subclassers to post-process the node\n * for the given object after encoding and return the\n * post-processed node. This implementation returns \n * the input node. The return value of this method\n * is returned to the encoder from <encode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that represents the default encoding.\n */\nmxObjectCodec.prototype.afterEncode = function(enc, obj, node)\n{\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Parses the given node into the object or returns a new object\n * representing the given node.\n *\n * Dec is a reference to the calling decoder. It is used to decode\n * complex objects and resolve references.\n *\n * If a node has an id attribute then the object cache is checked for the\n * object. If the object is not yet in the cache then it is constructed\n * using the constructor of <template> and cached in <mxCodec.objects>.\n *\n * This implementation decodes all attributes and childs of a node\n * according to the following rules:\n *\n * - If the variable name is in <exclude> or if the attribute name is \"id\"\n * or \"as\" then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getObject> is used\n * to replace the reference with an object.\n * - The variable name is mapped using a reverse <mapping>.\n * - If the value has a child node, then the codec is used to create a\n * child object with the variable name taken from the \"as\" attribute.\n * - If the object is an array and the variable name is empty then the\n * value or child object is appended to the array.\n * - If an add child has no value or the object is not an array then\n * the child text content is evaluated using <mxUtils.eval>.\n *\n * For add nodes where the object is not an array and the variable name\n * is defined, the default mechanism is used, allowing to override/add\n * methods as follows:\n *\n * (code)\n * <Object>\n *   <add as=\"hello\"><![CDATA[\n *     function(arg1) {\n *       mxUtils.alert('Hello '+arg1);\n *     }\n *   ]]></add>\n * </Object>\n * (end) \n *\n * If no object exists for an ID in <idrefs> a warning is issued\n * using <mxLog.warn>.\n *\n * Returns the resulting object that represents the given XML node\n * or the object given to the method as the into parameter.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * into - Optional objec to encode the node into.\n */\nmxObjectCodec.prototype.decode = function(dec, node, into)\n{\n\tvar id = node.getAttribute('id');\n\tvar obj = dec.objects[id];\n\t\n\tif (obj == null)\n\t{\n\t\tobj = into || this.cloneTemplate();\n\t\t\n\t\tif (id != null)\n\t\t{\n\t\t\tdec.putObject(id, obj);\n\t\t}\n\t}\n\t\n\tnode = this.beforeDecode(dec, node, obj);\n\tthis.decodeNode(dec, node, obj);\n\t\n    return this.afterDecode(dec, node, obj);\n};\t\n\n/**\n * Function: decodeNode\n * \n * Calls <decodeAttributes> and <decodeChildren> for the given node.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeNode = function(dec, node, obj)\n{\n\tif (node != null)\n\t{\n\t\tthis.decodeAttributes(dec, node, obj);\n\t\tthis.decodeChildren(dec, node, obj);\n\t}\n};\n\n/**\n * Function: decodeAttributes\n * \n * Decodes all attributes of the given node using <decodeAttribute>.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeAttributes = function(dec, node, obj)\n{\n\tvar attrs = node.attributes;\n\t\n\tif (attrs != null)\n\t{\n\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t{\n\t\t\tthis.decodeAttribute(dec, attrs[i], obj);\n\t\t}\n\t}\n};\n\n/**\n * Function: isIgnoredAttribute\n * \n * Returns true if the given attribute should be ignored. This implementation\n * returns true if the attribute name is \"as\" or \"id\".\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\t\nmxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr, obj)\n{\n\treturn attr.nodeName == 'as' || attr.nodeName == 'id';\n};\n\n/**\n * Function: decodeAttribute\n * \n * Reads the given attribute into the specified object.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\t\nmxObjectCodec.prototype.decodeAttribute = function(dec, attr, obj)\n{\n\tif (!this.isIgnoredAttribute(dec, attr, obj))\n\t{\n\t\tvar name = attr.nodeName;\n\t\t\n\t\t// Converts the string true and false to their boolean values.\n\t\t// This may require an additional check on the obj to see if\n\t\t// the existing field is a boolean value or uninitialized, in\n\t\t// which case we may want to convert true and false to a string.\n\t\tvar value = this.convertAttributeFromXml(dec, attr, obj);\n\t\tvar fieldname = this.getFieldName(name);\n\t\t\n\t\tif (this.isReference(obj, fieldname, value, false))\n\t\t{\n\t\t\tvar tmp = dec.getObject(value);\n\t\t\t\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.decode: No object for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\t\t    \n\t\t    value = tmp;\n\t\t}\n\n\t\tif (!this.isExcluded(obj, name, value, false))\n\t\t{\n\t\t\t//mxLog.debug(mxUtils.getFunctionName(obj.constructor)+'.'+name+'='+value);\n\t\t\tobj[name] = value;\n\t\t}\n\t}\n};\n\n/**\n * Function: decodeChildren\n * \n * Decodes all children of the given node using <decodeChild>.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeChildren = function(dec, node, obj)\n{\n\tvar child = node.firstChild;\n\t\n\twhile (child != null)\n\t{\n\t\tvar tmp = child.nextSibling;\n\t\t\n\t\tif (child.nodeType == mxConstants.NODETYPE_ELEMENT &&\n\t\t\t!this.processInclude(dec, child, obj))\n\t\t{\n\t\t\tthis.decodeChild(dec, child, obj);\n\t\t}\n\t\t\n\t\tchild = tmp;\n\t}\n};\n\n/**\n * Function: decodeChild\n * \n * Reads the specified child into the given object.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * child - XML child element to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeChild = function(dec, child, obj)\n{\n\tvar fieldname = this.getFieldName(child.getAttribute('as'));\n\t\n\tif (fieldname == null || !this.isExcluded(obj, fieldname, child, false))\n\t{\n\t\tvar template = this.getFieldTemplate(obj, fieldname, child);\n\t\tvar value = null;\n\t\t\n\t\tif (child.nodeName == 'add')\n\t\t{\n\t\t\tvalue = child.getAttribute('value');\n\t\t\t\n\t\t\tif (value == null && mxObjectCodec.allowEval)\n\t\t\t{\n\t\t\t\tvalue = mxUtils.eval(mxUtils.getTextContent(child));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = dec.decode(child, template);\n\t\t}\n\n\t\tthis.addObjectValue(obj, fieldname, value, template);\n\t}\n};\n\n/**\n * Function: getFieldTemplate\n * \n * Returns the template instance for the given field. This returns the\n * value of the field, null if the value is an array or an empty collection\n * if the value is a collection. The value is then used to populate the\n * field for a new instance. For strongly typed languages it may be\n * required to override this to return the correct collection instance\n * based on the encoded child.\n */\t\nmxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child)\n{\n\tvar template = obj[fieldname];\n\t\n\t// Non-empty arrays are replaced completely\n    if (template instanceof Array && template.length > 0)\n    {\n        template = null;\n    }\n    \n    return template;\n};\n\n/**\n * Function: addObjectValue\n * \n * Sets the decoded child node as a value of the given object. If the\n * object is a map, then the value is added with the given fieldname as a\n * key. If the fieldname is not empty, then setFieldValue is called or\n * else, if the object is a collection, the value is added to the\n * collection. For strongly typed languages it may be required to\n * override this with the correct code to add an entry to an object.\n */\t\nmxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template)\n{\n\tif (value != null && value != template)\n\t{\n\t\tif (fieldname != null && fieldname.length > 0)\n\t\t{\n\t\t\tobj[fieldname] = value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj.push(value);\n\t\t}\n\t\t//mxLog.debug('Decoded '+mxUtils.getFunctionName(obj.constructor)+'.'+fieldname+': '+value);\n\t}\n};\n\n/**\n * Function: processInclude\n *\n * Returns true if the given node is an include directive and\n * executes the include by decoding the XML document. Returns\n * false if the given node is not an include directive.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the encoding/decoding process.\n * node - XML node to be checked.\n * into - Optional object to pass-thru to the codec.\n */\nmxObjectCodec.prototype.processInclude = function(dec, node, into)\n{\n\tif (node.nodeName == 'include')\n\t{\n\t\tvar name = node.getAttribute('name');\n\t\t\n\t\tif (name != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar xml = mxUtils.load(name).getDocumentElement();\n\t\t\t\t\n\t\t\t\tif (xml != null)\n\t\t\t\t{\n\t\t\t\t\tdec.decode(xml, into);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: beforeDecode\n *\n * Hook for subclassers to pre-process the node for\n * the specified object and return the node to be\n * used for further processing by <decode>.\n * The object is created based on the template in the \n * calling method and is never null. This implementation\n * returns the input node. The return value of this\n * function is used in <decode> to perform\n * the default decoding into the given object.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Object to encode the node into.\n */\nmxObjectCodec.prototype.beforeDecode = function(dec, node, obj)\n{\n\treturn node;\n};\n\n/**\n * Function: afterDecode\n *\n * Hook for subclassers to post-process the object after\n * decoding. This implementation returns the given object\n * without any changes. The return value of this method\n * is returned to the decoder from <decode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * node - XML node to be decoded.\n * obj - Object that represents the default decoding.\n */\nmxObjectCodec.prototype.afterDecode = function(dec, node, obj)\n{\n\treturn obj;\n};\n\n__mxOutput.mxObjectCodec = typeof mxObjectCodec !== 'undefined' ? mxObjectCodec : undefined;\n"]}