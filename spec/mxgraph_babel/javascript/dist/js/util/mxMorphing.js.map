{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/util/mxMorphing.js"],"names":["mxMorphing","graph","steps","ease","delay","mxAnimation","call","prototype","constructor","step","cells","updateAnimation","apply","arguments","move","mxCellStatePreview","i","length","animateCell","getModel","getRoot","show","isEmpty","stopAnimation","cell","recurse","state","getView","getState","delta","getDelta","isVertex","x","y","translate","view","getTranslate","scale","getScale","moveState","stopRecursion","childCount","getChildCount","getChildAt","origin","getOriginForCell","mxPoint","result","parent","getParent","geo","getCellGeometry","relative","pgeo","width","height","t","__mxOutput","undefined"],"mappings":"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","file":"mxMorphing.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxMorphing\n * \n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n * \n * (code)\n * graph.getModel().beginUpdate();\n * try\n * {\n *   var circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   var morph = new mxMorphing(graph);\n *   morph.addListener(mxEvent.DONE, function()\n *   {\n *     graph.getModel().endUpdate();\n *   });\n *   \n *   morph.startAnimation();\n * }\n * (end)\n * \n * Constructor: mxMorphing\n * \n * Constructs an animation.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * steps - Optional number of steps in the morphing animation. Default is 6.\n * ease - Optional easing constant for the animation. Default is 1.5.\n * delay - Optional delay between the animation steps. Passed to <mxAnimation>.\n */\nfunction mxMorphing(graph, steps, ease, delay)\n{\n\tmxAnimation.call(this, delay);\n\tthis.graph = graph;\n\tthis.steps = (steps != null) ? steps : 6;\n\tthis.ease = (ease != null) ? ease : 1.5;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxMorphing.prototype = new mxAnimation();\nmxMorphing.prototype.constructor = mxMorphing;\n\n/**\n * Variable: graph\n * \n * Specifies the delay between the animation steps. Defaul is 30ms.\n */\nmxMorphing.prototype.graph = null;\n\n/**\n * Variable: steps\n * \n * Specifies the maximum number of steps for the morphing.\n */\nmxMorphing.prototype.steps = null;\n\n/**\n * Variable: step\n * \n * Contains the current step.\n */\nmxMorphing.prototype.step = 0;\n\n/**\n * Variable: ease\n * \n * Ease-off for movement towards the given vector. Larger values are\n * slower and smoother. Default is 4.\n */\nmxMorphing.prototype.ease = null;\n\n/**\n * Variable: cells\n * \n * Optional array of cells to be animated. If this is not specified\n * then all cells are checked and animated if they have been moved\n * in the current transaction.\n */\nmxMorphing.prototype.cells = null;\n\n/**\n * Function: updateAnimation\n *\n * Animation step.\n */\nmxMorphing.prototype.updateAnimation = function()\n{\n\tmxAnimation.prototype.updateAnimation.apply(this, arguments);\n\tvar move = new mxCellStatePreview(this.graph);\n\n\tif (this.cells != null)\n\t{\n\t\t// Animates the given cells individually without recursion\n\t\tfor (var i = 0; i < this.cells.length; i++)\n\t\t{\n\t\t\tthis.animateCell(this.cells[i], move, false);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Animates all changed cells by using recursion to find\n\t\t// the changed cells but not for the animation itself\n\t\tthis.animateCell(this.graph.getModel().getRoot(), move, true);\n\t}\n\t\n\tthis.show(move);\n\t\n\tif (move.isEmpty() || this.step++ >= this.steps)\n\t{\n\t\tthis.stopAnimation();\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the changes in the given <mxCellStatePreview>.\n */\nmxMorphing.prototype.show = function(move)\n{\n\tmove.show();\n};\n\n/**\n * Function: animateCell\n *\n * Animates the given cell state using <mxCellStatePreview.moveState>.\n */\nmxMorphing.prototype.animateCell = function(cell, move, recurse)\n{\n\tvar state = this.graph.getView().getState(cell);\n\tvar delta = null;\n\n\tif (state != null)\n\t{\n\t\t// Moves the animated state from where it will be after the model\n\t\t// change by subtracting the given delta vector from that location\n\t\tdelta = this.getDelta(state);\n\n\t\tif (this.graph.getModel().isVertex(cell) && (delta.x != 0 || delta.y != 0))\n\t\t{\n\t\t\tvar translate = this.graph.view.getTranslate();\n\t\t\tvar scale = this.graph.view.getScale();\n\t\t\t\n\t\t\tdelta.x += translate.x * scale;\n\t\t\tdelta.y += translate.y * scale;\n\t\t\t\n\t\t\tmove.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n\t\t}\n\t}\n\t\n\tif (recurse && !this.stopRecursion(state, delta))\n\t{\n\t\tvar childCount = this.graph.getModel().getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.animateCell(this.graph.getModel().getChildAt(cell, i), move, recurse);\n\t\t}\n\t}\n};\n\n/**\n * Function: stopRecursion\n *\n * Returns true if the animation should not recursively find more\n * deltas for children if the given parent state has been animated.\n */\nmxMorphing.prototype.stopRecursion = function(state, delta)\n{\n\treturn delta != null && (delta.x != 0 || delta.y != 0);\n};\n\n/**\n * Function: getDelta\n *\n * Returns the vector between the current rendered state and the future\n * location of the state after the display will be updated.\n */\nmxMorphing.prototype.getDelta = function(state)\n{\n\tvar origin = this.getOriginForCell(state.cell);\n\tvar translate = this.graph.getView().getTranslate();\n\tvar scale = this.graph.getView().getScale();\n\tvar x = state.x / scale - translate.x;\n\tvar y = state.y / scale - translate.y;\n\n\treturn new mxPoint((origin.x - x) * scale, (origin.y - y) * scale);\n};\n\n/**\n * Function: getOriginForCell\n *\n * Returns the top, left corner of the given cell. TODO: Improve performance\n * by using caching inside this method as the result per cell never changes\n * during the lifecycle of this object.\n */\nmxMorphing.prototype.getOriginForCell = function(cell)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tvar geo = this.graph.getCellGeometry(cell);\n\t\tresult = this.getOriginForCell(parent);\n\t\t\n\t\t// TODO: Handle offsets\n\t\tif (geo != null)\n\t\t{\n\t\t\tif (geo.relative)\n\t\t\t{\n\t\t\t\tvar pgeo = this.graph.getCellGeometry(parent);\n\t\t\t\t\n\t\t\t\tif (pgeo != null)\n\t\t\t\t{\n\t\t\t\t\tresult.x += geo.x * pgeo.width;\n\t\t\t\t\tresult.y += geo.y * pgeo.height;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (result == null)\n\t{\n\t\tvar t = this.graph.view.getTranslate();\n\t\tresult = new mxPoint(-t.x, -t.y);\n\t}\n\t\n\treturn result;\n};\n\n__mxOutput.mxMorphing = typeof mxMorphing !== 'undefined' ? mxMorphing : undefined;\n"]}