{"version":3,"sources":["../../../../../../src/mxgraph/javascript/dist/js/util/mxUndoManager.js"],"names":["mxUndoManager","size","clear","prototype","mxEventSource","constructor","history","indexOfNextAdd","isEmpty","length","fireEvent","mxEventObject","mxEvent","CLEAR","canUndo","undo","edit","isSignificant","UNDO","canRedo","redo","n","REDO","undoableEditHappened","undoableEdit","trim","shift","push","ADD","edits","splice","i","die","__mxOutput","undefined"],"mappings":"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","file":"mxUndoManager.js","sourcesContent":["/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxUndoManager\n *\n * Implements a command history. When changing the graph model, an\n * <mxUndoableChange> object is created at the start of the transaction (when\n * model.beginUpdate is called). All atomic changes are then added to this\n * object until the last model.endUpdate call, at which point the\n * <mxUndoableEdit> is dispatched in an event, and added to the history inside\n * <mxUndoManager>. This is done by an event listener in\n * <mxEditor.installUndoHandler>.\n * \n * Each atomic change of the model is represented by an object (eg.\n * <mxRootChange>, <mxChildChange>, <mxTerminalChange> etc) which contains the\n * complete undo information. The <mxUndoManager> also listens to the\n * <mxGraphView> and stores it's changes to the current root as insignificant\n * undoable changes, so that drilling (step into, step up) is undone.\n * \n * This means when you execute an atomic change on the model, then change the\n * current root on the view and click undo, the change of the root will be\n * undone together with the change of the model so that the display represents\n * the state at which the model was changed. However, these changes are not\n * transmitted for sharing as they do not represent a state change.\n *\n * Example:\n * \n * When adding an undo manager to a graph, make sure to add it\n * to the model and the view as well to maintain a consistent\n * display across multiple undo/redo steps.\n *\n * (code)\n * var undoManager = new mxUndoManager();\n * var listener = function(sender, evt)\n * {\n *   undoManager.undoableEditHappened(evt.getProperty('edit'));\n * };\n * graph.getModel().addListener(mxEvent.UNDO, listener);\n * graph.getView().addListener(mxEvent.UNDO, listener);\n * (end)\n * \n * The code creates a function that informs the undoManager\n * of an undoable edit and binds it to the undo event of\n * <mxGraphModel> and <mxGraphView> using\n * <mxEventSource.addListener>.\n * \n * Event: mxEvent.CLEAR\n * \n * Fires after <clear> was invoked. This event has no properties.\n * \n * Event: mxEvent.UNDO\n * \n * Fires afer a significant edit was undone in <undo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was undone.\n * \n * Event: mxEvent.REDO\n * \n * Fires afer a significant edit was redone in <redo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was redone.\n * \n * Event: mxEvent.ADD\n * \n * Fires after an undoable edit was added to the history. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was added.\n * \n * Constructor: mxUndoManager\n *\n * Constructs a new undo manager with the given history size. If no history\n * size is given, then a default size of 100 steps is used.\n */\nfunction mxUndoManager(size)\n{\n\tthis.size = (size != null) ? size : 100;\n\tthis.clear();\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUndoManager.prototype = new mxEventSource();\nmxUndoManager.prototype.constructor = mxUndoManager;\n\n/**\n * Variable: size\n * \n * Maximum command history size. 0 means unlimited history. Default is\n * 100.\n */\nmxUndoManager.prototype.size = null;\n\n/**\n * Variable: history\n * \n * Array that contains the steps of the command history.\n */\nmxUndoManager.prototype.history = null;\n\n/**\n * Variable: indexOfNextAdd\n * \n * Index of the element to be added next.\n */\nmxUndoManager.prototype.indexOfNextAdd = 0;\n\n/**\n * Function: isEmpty\n * \n * Returns true if the history is empty.\n */\nmxUndoManager.prototype.isEmpty = function()\n{\n\treturn this.history.length == 0;\n};\n\n/**\n * Function: clear\n * \n * Clears the command history.\n */\nmxUndoManager.prototype.clear = function()\n{\n\tthis.history = [];\n\tthis.indexOfNextAdd = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.CLEAR));\n};\n\n/**\n * Function: canUndo\n * \n * Returns true if an undo is possible.\n */\nmxUndoManager.prototype.canUndo = function()\n{\n\treturn this.indexOfNextAdd > 0;\n};\n\n/**\n * Function: undo\n * \n * Undoes the last change.\n */\nmxUndoManager.prototype.undo = function()\n{\n    while (this.indexOfNextAdd > 0)\n    {\n        var edit = this.history[--this.indexOfNextAdd];\n        edit.undo();\n\n\t\tif (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: canRedo\n * \n * Returns true if a redo is possible.\n */\nmxUndoManager.prototype.canRedo = function()\n{\n\treturn this.indexOfNextAdd < this.history.length;\n};\n\n/**\n * Function: redo\n * \n * Redoes the last change.\n */\nmxUndoManager.prototype.redo = function()\n{\n    var n = this.history.length;\n    \n    while (this.indexOfNextAdd < n)\n    {\n        var edit =  this.history[this.indexOfNextAdd++];\n        edit.redo();\n        \n        if (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.REDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: undoableEditHappened\n * \n * Method to be called to add new undoable edits to the <history>.\n */\nmxUndoManager.prototype.undoableEditHappened = function(undoableEdit)\n{\n\tthis.trim();\n\t\n\tif (this.size > 0 &&\n\t\tthis.size == this.history.length)\n\t{\n\t\tthis.history.shift();\n\t}\n\t\n\tthis.history.push(undoableEdit);\n\tthis.indexOfNextAdd = this.history.length;\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD, 'edit', undoableEdit));\n};\n\n/**\n * Function: trim\n * \n * Removes all pending steps after <indexOfNextAdd> from the history,\n * invoking die on each edit. This is called from <undoableEditHappened>.\n */\nmxUndoManager.prototype.trim = function()\n{\n\tif (this.history.length > this.indexOfNextAdd)\n\t{\n\t\tvar edits = this.history.splice(this.indexOfNextAdd,\n\t\t\tthis.history.length - this.indexOfNextAdd);\n\t\t\t\n\t\tfor (var i = 0; i < edits.length; i++)\n\t\t{\n\t\t\tedits[i].die();\n\t\t}\n\t}\n};\n\n__mxOutput.mxUndoManager = typeof mxUndoManager !== 'undefined' ? mxUndoManager : undefined;\n"]}